
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ExportHistory
 * 
 */
export type ExportHistory = $Result.DefaultSelection<Prisma.$ExportHistoryPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model ParsedDocument
 * 
 */
export type ParsedDocument = $Result.DefaultSelection<Prisma.$ParsedDocumentPayload>
/**
 * Model Experience
 * 
 */
export type Experience = $Result.DefaultSelection<Prisma.$ExperiencePayload>
/**
 * Model Education
 * 
 */
export type Education = $Result.DefaultSelection<Prisma.$EducationPayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model Certification
 * 
 */
export type Certification = $Result.DefaultSelection<Prisma.$CertificationPayload>
/**
 * Model ParsingJob
 * 
 */
export type ParsingJob = $Result.DefaultSelection<Prisma.$ParsingJobPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Volunteering
 * 
 */
export type Volunteering = $Result.DefaultSelection<Prisma.$VolunteeringPayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model MediaLibrary
 * 
 */
export type MediaLibrary = $Result.DefaultSelection<Prisma.$MediaLibraryPayload>
/**
 * Model PersonalityAssessment
 * 
 */
export type PersonalityAssessment = $Result.DefaultSelection<Prisma.$PersonalityAssessmentPayload>
/**
 * Model PersonalityResponse
 * 
 */
export type PersonalityResponse = $Result.DefaultSelection<Prisma.$PersonalityResponsePayload>
/**
 * Model AppAdmin
 * 
 */
export type AppAdmin = $Result.DefaultSelection<Prisma.$AppAdminPayload>
/**
 * Model TalentStory
 * 
 */
export type TalentStory = $Result.DefaultSelection<Prisma.$TalentStoryPayload>
/**
 * Model JobPost
 * 
 */
export type JobPost = $Result.DefaultSelection<Prisma.$JobPostPayload>
/**
 * Model CustomizedStory
 * 
 */
export type CustomizedStory = $Result.DefaultSelection<Prisma.$CustomizedStoryPayload>
/**
 * Model Story
 * 
 */
export type Story = $Result.DefaultSelection<Prisma.$StoryPayload>
/**
 * Model StoryVersion
 * 
 */
export type StoryVersion = $Result.DefaultSelection<Prisma.$StoryVersionPayload>
/**
 * Model StorySkill
 * 
 */
export type StorySkill = $Result.DefaultSelection<Prisma.$StorySkillPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exportHistory`: Exposes CRUD operations for the **ExportHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExportHistories
    * const exportHistories = await prisma.exportHistory.findMany()
    * ```
    */
  get exportHistory(): Prisma.ExportHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parsedDocument`: Exposes CRUD operations for the **ParsedDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParsedDocuments
    * const parsedDocuments = await prisma.parsedDocument.findMany()
    * ```
    */
  get parsedDocument(): Prisma.ParsedDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.experience`: Exposes CRUD operations for the **Experience** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Experiences
    * const experiences = await prisma.experience.findMany()
    * ```
    */
  get experience(): Prisma.ExperienceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.education`: Exposes CRUD operations for the **Education** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Educations
    * const educations = await prisma.education.findMany()
    * ```
    */
  get education(): Prisma.EducationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certification`: Exposes CRUD operations for the **Certification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certifications
    * const certifications = await prisma.certification.findMany()
    * ```
    */
  get certification(): Prisma.CertificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parsingJob`: Exposes CRUD operations for the **ParsingJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParsingJobs
    * const parsingJobs = await prisma.parsingJob.findMany()
    * ```
    */
  get parsingJob(): Prisma.ParsingJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.volunteering`: Exposes CRUD operations for the **Volunteering** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Volunteerings
    * const volunteerings = await prisma.volunteering.findMany()
    * ```
    */
  get volunteering(): Prisma.VolunteeringDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mediaLibrary`: Exposes CRUD operations for the **MediaLibrary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaLibraries
    * const mediaLibraries = await prisma.mediaLibrary.findMany()
    * ```
    */
  get mediaLibrary(): Prisma.MediaLibraryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personalityAssessment`: Exposes CRUD operations for the **PersonalityAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonalityAssessments
    * const personalityAssessments = await prisma.personalityAssessment.findMany()
    * ```
    */
  get personalityAssessment(): Prisma.PersonalityAssessmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personalityResponse`: Exposes CRUD operations for the **PersonalityResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonalityResponses
    * const personalityResponses = await prisma.personalityResponse.findMany()
    * ```
    */
  get personalityResponse(): Prisma.PersonalityResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appAdmin`: Exposes CRUD operations for the **AppAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppAdmins
    * const appAdmins = await prisma.appAdmin.findMany()
    * ```
    */
  get appAdmin(): Prisma.AppAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.talentStory`: Exposes CRUD operations for the **TalentStory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TalentStories
    * const talentStories = await prisma.talentStory.findMany()
    * ```
    */
  get talentStory(): Prisma.TalentStoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobPost`: Exposes CRUD operations for the **JobPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPosts
    * const jobPosts = await prisma.jobPost.findMany()
    * ```
    */
  get jobPost(): Prisma.JobPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customizedStory`: Exposes CRUD operations for the **CustomizedStory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomizedStories
    * const customizedStories = await prisma.customizedStory.findMany()
    * ```
    */
  get customizedStory(): Prisma.CustomizedStoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.story`: Exposes CRUD operations for the **Story** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stories
    * const stories = await prisma.story.findMany()
    * ```
    */
  get story(): Prisma.StoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storyVersion`: Exposes CRUD operations for the **StoryVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoryVersions
    * const storyVersions = await prisma.storyVersion.findMany()
    * ```
    */
  get storyVersion(): Prisma.StoryVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storySkill`: Exposes CRUD operations for the **StorySkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorySkills
    * const storySkills = await prisma.storySkill.findMany()
    * ```
    */
  get storySkill(): Prisma.StorySkillDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ExportHistory: 'ExportHistory',
    Profile: 'Profile',
    ParsedDocument: 'ParsedDocument',
    Experience: 'Experience',
    Education: 'Education',
    Skill: 'Skill',
    Certification: 'Certification',
    ParsingJob: 'ParsingJob',
    Project: 'Project',
    Volunteering: 'Volunteering',
    Language: 'Language',
    Organization: 'Organization',
    MediaLibrary: 'MediaLibrary',
    PersonalityAssessment: 'PersonalityAssessment',
    PersonalityResponse: 'PersonalityResponse',
    AppAdmin: 'AppAdmin',
    TalentStory: 'TalentStory',
    JobPost: 'JobPost',
    CustomizedStory: 'CustomizedStory',
    Story: 'Story',
    StoryVersion: 'StoryVersion',
    StorySkill: 'StorySkill'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "exportHistory" | "profile" | "parsedDocument" | "experience" | "education" | "skill" | "certification" | "parsingJob" | "project" | "volunteering" | "language" | "organization" | "mediaLibrary" | "personalityAssessment" | "personalityResponse" | "appAdmin" | "talentStory" | "jobPost" | "customizedStory" | "story" | "storyVersion" | "storySkill"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ExportHistory: {
        payload: Prisma.$ExportHistoryPayload<ExtArgs>
        fields: Prisma.ExportHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExportHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExportHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>
          }
          findFirst: {
            args: Prisma.ExportHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExportHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>
          }
          findMany: {
            args: Prisma.ExportHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>[]
          }
          create: {
            args: Prisma.ExportHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>
          }
          createMany: {
            args: Prisma.ExportHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExportHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>[]
          }
          delete: {
            args: Prisma.ExportHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>
          }
          update: {
            args: Prisma.ExportHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ExportHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExportHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExportHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ExportHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportHistoryPayload>
          }
          aggregate: {
            args: Prisma.ExportHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExportHistory>
          }
          groupBy: {
            args: Prisma.ExportHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExportHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExportHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ExportHistoryCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      ParsedDocument: {
        payload: Prisma.$ParsedDocumentPayload<ExtArgs>
        fields: Prisma.ParsedDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParsedDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParsedDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedDocumentPayload>
          }
          findFirst: {
            args: Prisma.ParsedDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParsedDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedDocumentPayload>
          }
          findMany: {
            args: Prisma.ParsedDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedDocumentPayload>[]
          }
          create: {
            args: Prisma.ParsedDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedDocumentPayload>
          }
          createMany: {
            args: Prisma.ParsedDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParsedDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedDocumentPayload>[]
          }
          delete: {
            args: Prisma.ParsedDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedDocumentPayload>
          }
          update: {
            args: Prisma.ParsedDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedDocumentPayload>
          }
          deleteMany: {
            args: Prisma.ParsedDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParsedDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParsedDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedDocumentPayload>[]
          }
          upsert: {
            args: Prisma.ParsedDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedDocumentPayload>
          }
          aggregate: {
            args: Prisma.ParsedDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParsedDocument>
          }
          groupBy: {
            args: Prisma.ParsedDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParsedDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParsedDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<ParsedDocumentCountAggregateOutputType> | number
          }
        }
      }
      Experience: {
        payload: Prisma.$ExperiencePayload<ExtArgs>
        fields: Prisma.ExperienceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExperienceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExperienceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          findFirst: {
            args: Prisma.ExperienceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExperienceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          findMany: {
            args: Prisma.ExperienceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>[]
          }
          create: {
            args: Prisma.ExperienceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          createMany: {
            args: Prisma.ExperienceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExperienceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>[]
          }
          delete: {
            args: Prisma.ExperienceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          update: {
            args: Prisma.ExperienceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          deleteMany: {
            args: Prisma.ExperienceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExperienceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExperienceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>[]
          }
          upsert: {
            args: Prisma.ExperienceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          aggregate: {
            args: Prisma.ExperienceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExperience>
          }
          groupBy: {
            args: Prisma.ExperienceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExperienceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExperienceCountArgs<ExtArgs>
            result: $Utils.Optional<ExperienceCountAggregateOutputType> | number
          }
        }
      }
      Education: {
        payload: Prisma.$EducationPayload<ExtArgs>
        fields: Prisma.EducationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          findFirst: {
            args: Prisma.EducationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          findMany: {
            args: Prisma.EducationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          create: {
            args: Prisma.EducationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          createMany: {
            args: Prisma.EducationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EducationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          delete: {
            args: Prisma.EducationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          update: {
            args: Prisma.EducationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          deleteMany: {
            args: Prisma.EducationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EducationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          upsert: {
            args: Prisma.EducationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          aggregate: {
            args: Prisma.EducationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducation>
          }
          groupBy: {
            args: Prisma.EducationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EducationCountArgs<ExtArgs>
            result: $Utils.Optional<EducationCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      Certification: {
        payload: Prisma.$CertificationPayload<ExtArgs>
        fields: Prisma.CertificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          findFirst: {
            args: Prisma.CertificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          findMany: {
            args: Prisma.CertificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>[]
          }
          create: {
            args: Prisma.CertificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          createMany: {
            args: Prisma.CertificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>[]
          }
          delete: {
            args: Prisma.CertificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          update: {
            args: Prisma.CertificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          deleteMany: {
            args: Prisma.CertificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CertificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>[]
          }
          upsert: {
            args: Prisma.CertificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          aggregate: {
            args: Prisma.CertificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertification>
          }
          groupBy: {
            args: Prisma.CertificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificationCountArgs<ExtArgs>
            result: $Utils.Optional<CertificationCountAggregateOutputType> | number
          }
        }
      }
      ParsingJob: {
        payload: Prisma.$ParsingJobPayload<ExtArgs>
        fields: Prisma.ParsingJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParsingJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsingJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParsingJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsingJobPayload>
          }
          findFirst: {
            args: Prisma.ParsingJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsingJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParsingJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsingJobPayload>
          }
          findMany: {
            args: Prisma.ParsingJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsingJobPayload>[]
          }
          create: {
            args: Prisma.ParsingJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsingJobPayload>
          }
          createMany: {
            args: Prisma.ParsingJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParsingJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsingJobPayload>[]
          }
          delete: {
            args: Prisma.ParsingJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsingJobPayload>
          }
          update: {
            args: Prisma.ParsingJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsingJobPayload>
          }
          deleteMany: {
            args: Prisma.ParsingJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParsingJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParsingJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsingJobPayload>[]
          }
          upsert: {
            args: Prisma.ParsingJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsingJobPayload>
          }
          aggregate: {
            args: Prisma.ParsingJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParsingJob>
          }
          groupBy: {
            args: Prisma.ParsingJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParsingJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParsingJobCountArgs<ExtArgs>
            result: $Utils.Optional<ParsingJobCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Volunteering: {
        payload: Prisma.$VolunteeringPayload<ExtArgs>
        fields: Prisma.VolunteeringFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VolunteeringFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VolunteeringFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringPayload>
          }
          findFirst: {
            args: Prisma.VolunteeringFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VolunteeringFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringPayload>
          }
          findMany: {
            args: Prisma.VolunteeringFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringPayload>[]
          }
          create: {
            args: Prisma.VolunteeringCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringPayload>
          }
          createMany: {
            args: Prisma.VolunteeringCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VolunteeringCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringPayload>[]
          }
          delete: {
            args: Prisma.VolunteeringDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringPayload>
          }
          update: {
            args: Prisma.VolunteeringUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringPayload>
          }
          deleteMany: {
            args: Prisma.VolunteeringDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VolunteeringUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VolunteeringUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringPayload>[]
          }
          upsert: {
            args: Prisma.VolunteeringUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringPayload>
          }
          aggregate: {
            args: Prisma.VolunteeringAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVolunteering>
          }
          groupBy: {
            args: Prisma.VolunteeringGroupByArgs<ExtArgs>
            result: $Utils.Optional<VolunteeringGroupByOutputType>[]
          }
          count: {
            args: Prisma.VolunteeringCountArgs<ExtArgs>
            result: $Utils.Optional<VolunteeringCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      MediaLibrary: {
        payload: Prisma.$MediaLibraryPayload<ExtArgs>
        fields: Prisma.MediaLibraryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaLibraryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaLibraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaLibraryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaLibraryPayload>
          }
          findFirst: {
            args: Prisma.MediaLibraryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaLibraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaLibraryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaLibraryPayload>
          }
          findMany: {
            args: Prisma.MediaLibraryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaLibraryPayload>[]
          }
          create: {
            args: Prisma.MediaLibraryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaLibraryPayload>
          }
          createMany: {
            args: Prisma.MediaLibraryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaLibraryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaLibraryPayload>[]
          }
          delete: {
            args: Prisma.MediaLibraryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaLibraryPayload>
          }
          update: {
            args: Prisma.MediaLibraryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaLibraryPayload>
          }
          deleteMany: {
            args: Prisma.MediaLibraryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaLibraryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaLibraryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaLibraryPayload>[]
          }
          upsert: {
            args: Prisma.MediaLibraryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaLibraryPayload>
          }
          aggregate: {
            args: Prisma.MediaLibraryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaLibrary>
          }
          groupBy: {
            args: Prisma.MediaLibraryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaLibraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaLibraryCountArgs<ExtArgs>
            result: $Utils.Optional<MediaLibraryCountAggregateOutputType> | number
          }
        }
      }
      PersonalityAssessment: {
        payload: Prisma.$PersonalityAssessmentPayload<ExtArgs>
        fields: Prisma.PersonalityAssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonalityAssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityAssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonalityAssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityAssessmentPayload>
          }
          findFirst: {
            args: Prisma.PersonalityAssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityAssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonalityAssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityAssessmentPayload>
          }
          findMany: {
            args: Prisma.PersonalityAssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityAssessmentPayload>[]
          }
          create: {
            args: Prisma.PersonalityAssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityAssessmentPayload>
          }
          createMany: {
            args: Prisma.PersonalityAssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonalityAssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityAssessmentPayload>[]
          }
          delete: {
            args: Prisma.PersonalityAssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityAssessmentPayload>
          }
          update: {
            args: Prisma.PersonalityAssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityAssessmentPayload>
          }
          deleteMany: {
            args: Prisma.PersonalityAssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonalityAssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonalityAssessmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityAssessmentPayload>[]
          }
          upsert: {
            args: Prisma.PersonalityAssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityAssessmentPayload>
          }
          aggregate: {
            args: Prisma.PersonalityAssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonalityAssessment>
          }
          groupBy: {
            args: Prisma.PersonalityAssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonalityAssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonalityAssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<PersonalityAssessmentCountAggregateOutputType> | number
          }
        }
      }
      PersonalityResponse: {
        payload: Prisma.$PersonalityResponsePayload<ExtArgs>
        fields: Prisma.PersonalityResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonalityResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonalityResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityResponsePayload>
          }
          findFirst: {
            args: Prisma.PersonalityResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonalityResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityResponsePayload>
          }
          findMany: {
            args: Prisma.PersonalityResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityResponsePayload>[]
          }
          create: {
            args: Prisma.PersonalityResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityResponsePayload>
          }
          createMany: {
            args: Prisma.PersonalityResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonalityResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityResponsePayload>[]
          }
          delete: {
            args: Prisma.PersonalityResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityResponsePayload>
          }
          update: {
            args: Prisma.PersonalityResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityResponsePayload>
          }
          deleteMany: {
            args: Prisma.PersonalityResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonalityResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonalityResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityResponsePayload>[]
          }
          upsert: {
            args: Prisma.PersonalityResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityResponsePayload>
          }
          aggregate: {
            args: Prisma.PersonalityResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonalityResponse>
          }
          groupBy: {
            args: Prisma.PersonalityResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonalityResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonalityResponseCountArgs<ExtArgs>
            result: $Utils.Optional<PersonalityResponseCountAggregateOutputType> | number
          }
        }
      }
      AppAdmin: {
        payload: Prisma.$AppAdminPayload<ExtArgs>
        fields: Prisma.AppAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppAdminPayload>
          }
          findFirst: {
            args: Prisma.AppAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppAdminPayload>
          }
          findMany: {
            args: Prisma.AppAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppAdminPayload>[]
          }
          create: {
            args: Prisma.AppAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppAdminPayload>
          }
          createMany: {
            args: Prisma.AppAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppAdminPayload>[]
          }
          delete: {
            args: Prisma.AppAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppAdminPayload>
          }
          update: {
            args: Prisma.AppAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppAdminPayload>
          }
          deleteMany: {
            args: Prisma.AppAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppAdminPayload>[]
          }
          upsert: {
            args: Prisma.AppAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppAdminPayload>
          }
          aggregate: {
            args: Prisma.AppAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppAdmin>
          }
          groupBy: {
            args: Prisma.AppAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppAdminCountArgs<ExtArgs>
            result: $Utils.Optional<AppAdminCountAggregateOutputType> | number
          }
        }
      }
      TalentStory: {
        payload: Prisma.$TalentStoryPayload<ExtArgs>
        fields: Prisma.TalentStoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TalentStoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentStoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TalentStoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentStoryPayload>
          }
          findFirst: {
            args: Prisma.TalentStoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentStoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TalentStoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentStoryPayload>
          }
          findMany: {
            args: Prisma.TalentStoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentStoryPayload>[]
          }
          create: {
            args: Prisma.TalentStoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentStoryPayload>
          }
          createMany: {
            args: Prisma.TalentStoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TalentStoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentStoryPayload>[]
          }
          delete: {
            args: Prisma.TalentStoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentStoryPayload>
          }
          update: {
            args: Prisma.TalentStoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentStoryPayload>
          }
          deleteMany: {
            args: Prisma.TalentStoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TalentStoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TalentStoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentStoryPayload>[]
          }
          upsert: {
            args: Prisma.TalentStoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TalentStoryPayload>
          }
          aggregate: {
            args: Prisma.TalentStoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTalentStory>
          }
          groupBy: {
            args: Prisma.TalentStoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TalentStoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TalentStoryCountArgs<ExtArgs>
            result: $Utils.Optional<TalentStoryCountAggregateOutputType> | number
          }
        }
      }
      JobPost: {
        payload: Prisma.$JobPostPayload<ExtArgs>
        fields: Prisma.JobPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          findFirst: {
            args: Prisma.JobPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          findMany: {
            args: Prisma.JobPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>[]
          }
          create: {
            args: Prisma.JobPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          createMany: {
            args: Prisma.JobPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>[]
          }
          delete: {
            args: Prisma.JobPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          update: {
            args: Prisma.JobPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          deleteMany: {
            args: Prisma.JobPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>[]
          }
          upsert: {
            args: Prisma.JobPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          aggregate: {
            args: Prisma.JobPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobPost>
          }
          groupBy: {
            args: Prisma.JobPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPostCountArgs<ExtArgs>
            result: $Utils.Optional<JobPostCountAggregateOutputType> | number
          }
        }
      }
      CustomizedStory: {
        payload: Prisma.$CustomizedStoryPayload<ExtArgs>
        fields: Prisma.CustomizedStoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomizedStoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomizedStoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomizedStoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomizedStoryPayload>
          }
          findFirst: {
            args: Prisma.CustomizedStoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomizedStoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomizedStoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomizedStoryPayload>
          }
          findMany: {
            args: Prisma.CustomizedStoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomizedStoryPayload>[]
          }
          create: {
            args: Prisma.CustomizedStoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomizedStoryPayload>
          }
          createMany: {
            args: Prisma.CustomizedStoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomizedStoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomizedStoryPayload>[]
          }
          delete: {
            args: Prisma.CustomizedStoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomizedStoryPayload>
          }
          update: {
            args: Prisma.CustomizedStoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomizedStoryPayload>
          }
          deleteMany: {
            args: Prisma.CustomizedStoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomizedStoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomizedStoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomizedStoryPayload>[]
          }
          upsert: {
            args: Prisma.CustomizedStoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomizedStoryPayload>
          }
          aggregate: {
            args: Prisma.CustomizedStoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomizedStory>
          }
          groupBy: {
            args: Prisma.CustomizedStoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomizedStoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomizedStoryCountArgs<ExtArgs>
            result: $Utils.Optional<CustomizedStoryCountAggregateOutputType> | number
          }
        }
      }
      Story: {
        payload: Prisma.$StoryPayload<ExtArgs>
        fields: Prisma.StoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          findFirst: {
            args: Prisma.StoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          findMany: {
            args: Prisma.StoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          create: {
            args: Prisma.StoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          createMany: {
            args: Prisma.StoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          delete: {
            args: Prisma.StoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          update: {
            args: Prisma.StoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          deleteMany: {
            args: Prisma.StoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          upsert: {
            args: Prisma.StoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          aggregate: {
            args: Prisma.StoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStory>
          }
          groupBy: {
            args: Prisma.StoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryCountArgs<ExtArgs>
            result: $Utils.Optional<StoryCountAggregateOutputType> | number
          }
        }
      }
      StoryVersion: {
        payload: Prisma.$StoryVersionPayload<ExtArgs>
        fields: Prisma.StoryVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>
          }
          findFirst: {
            args: Prisma.StoryVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>
          }
          findMany: {
            args: Prisma.StoryVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>[]
          }
          create: {
            args: Prisma.StoryVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>
          }
          createMany: {
            args: Prisma.StoryVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>[]
          }
          delete: {
            args: Prisma.StoryVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>
          }
          update: {
            args: Prisma.StoryVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>
          }
          deleteMany: {
            args: Prisma.StoryVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>[]
          }
          upsert: {
            args: Prisma.StoryVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryVersionPayload>
          }
          aggregate: {
            args: Prisma.StoryVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoryVersion>
          }
          groupBy: {
            args: Prisma.StoryVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryVersionCountArgs<ExtArgs>
            result: $Utils.Optional<StoryVersionCountAggregateOutputType> | number
          }
        }
      }
      StorySkill: {
        payload: Prisma.$StorySkillPayload<ExtArgs>
        fields: Prisma.StorySkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorySkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorySkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorySkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorySkillPayload>
          }
          findFirst: {
            args: Prisma.StorySkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorySkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorySkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorySkillPayload>
          }
          findMany: {
            args: Prisma.StorySkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorySkillPayload>[]
          }
          create: {
            args: Prisma.StorySkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorySkillPayload>
          }
          createMany: {
            args: Prisma.StorySkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StorySkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorySkillPayload>[]
          }
          delete: {
            args: Prisma.StorySkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorySkillPayload>
          }
          update: {
            args: Prisma.StorySkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorySkillPayload>
          }
          deleteMany: {
            args: Prisma.StorySkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StorySkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StorySkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorySkillPayload>[]
          }
          upsert: {
            args: Prisma.StorySkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorySkillPayload>
          }
          aggregate: {
            args: Prisma.StorySkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStorySkill>
          }
          groupBy: {
            args: Prisma.StorySkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<StorySkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorySkillCountArgs<ExtArgs>
            result: $Utils.Optional<StorySkillCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    exportHistory?: ExportHistoryOmit
    profile?: ProfileOmit
    parsedDocument?: ParsedDocumentOmit
    experience?: ExperienceOmit
    education?: EducationOmit
    skill?: SkillOmit
    certification?: CertificationOmit
    parsingJob?: ParsingJobOmit
    project?: ProjectOmit
    volunteering?: VolunteeringOmit
    language?: LanguageOmit
    organization?: OrganizationOmit
    mediaLibrary?: MediaLibraryOmit
    personalityAssessment?: PersonalityAssessmentOmit
    personalityResponse?: PersonalityResponseOmit
    appAdmin?: AppAdminOmit
    talentStory?: TalentStoryOmit
    jobPost?: JobPostOmit
    customizedStory?: CustomizedStoryOmit
    story?: StoryOmit
    storyVersion?: StoryVersionOmit
    storySkill?: StorySkillOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    experiences: number
    education: number
    skills: number
    certifications: number
    projects: number
    volunteering: number
    languages: number
    organizations: number
    parsed_documents: number
    mediaLibrary: number
    customizedStories: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiences?: boolean | ProfileCountOutputTypeCountExperiencesArgs
    education?: boolean | ProfileCountOutputTypeCountEducationArgs
    skills?: boolean | ProfileCountOutputTypeCountSkillsArgs
    certifications?: boolean | ProfileCountOutputTypeCountCertificationsArgs
    projects?: boolean | ProfileCountOutputTypeCountProjectsArgs
    volunteering?: boolean | ProfileCountOutputTypeCountVolunteeringArgs
    languages?: boolean | ProfileCountOutputTypeCountLanguagesArgs
    organizations?: boolean | ProfileCountOutputTypeCountOrganizationsArgs
    parsed_documents?: boolean | ProfileCountOutputTypeCountParsed_documentsArgs
    mediaLibrary?: boolean | ProfileCountOutputTypeCountMediaLibraryArgs
    customizedStories?: boolean | ProfileCountOutputTypeCountCustomizedStoriesArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountExperiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperienceWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountEducationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountCertificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountVolunteeringArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolunteeringWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountParsed_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedDocumentWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountMediaLibraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaLibraryWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountCustomizedStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomizedStoryWhereInput
  }


  /**
   * Count Type ParsedDocumentCountOutputType
   */

  export type ParsedDocumentCountOutputType = {
    parsing_jobs: number
  }

  export type ParsedDocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parsing_jobs?: boolean | ParsedDocumentCountOutputTypeCountParsing_jobsArgs
  }

  // Custom InputTypes
  /**
   * ParsedDocumentCountOutputType without action
   */
  export type ParsedDocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedDocumentCountOutputType
     */
    select?: ParsedDocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParsedDocumentCountOutputType without action
   */
  export type ParsedDocumentCountOutputTypeCountParsing_jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsingJobWhereInput
  }


  /**
   * Count Type ExperienceCountOutputType
   */

  export type ExperienceCountOutputType = {
    stories: number
  }

  export type ExperienceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stories?: boolean | ExperienceCountOutputTypeCountStoriesArgs
  }

  // Custom InputTypes
  /**
   * ExperienceCountOutputType without action
   */
  export type ExperienceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceCountOutputType
     */
    select?: ExperienceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExperienceCountOutputType without action
   */
  export type ExperienceCountOutputTypeCountStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    storySkills: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storySkills?: boolean | SkillCountOutputTypeCountStorySkillsArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountStorySkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorySkillWhereInput
  }


  /**
   * Count Type PersonalityAssessmentCountOutputType
   */

  export type PersonalityAssessmentCountOutputType = {
    responses_rel: number
  }

  export type PersonalityAssessmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses_rel?: boolean | PersonalityAssessmentCountOutputTypeCountResponses_relArgs
  }

  // Custom InputTypes
  /**
   * PersonalityAssessmentCountOutputType without action
   */
  export type PersonalityAssessmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityAssessmentCountOutputType
     */
    select?: PersonalityAssessmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonalityAssessmentCountOutputType without action
   */
  export type PersonalityAssessmentCountOutputTypeCountResponses_relArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalityResponseWhereInput
  }


  /**
   * Count Type JobPostCountOutputType
   */

  export type JobPostCountOutputType = {
    customized_stories: number
  }

  export type JobPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customized_stories?: boolean | JobPostCountOutputTypeCountCustomized_storiesArgs
  }

  // Custom InputTypes
  /**
   * JobPostCountOutputType without action
   */
  export type JobPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostCountOutputType
     */
    select?: JobPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobPostCountOutputType without action
   */
  export type JobPostCountOutputTypeCountCustomized_storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomizedStoryWhereInput
  }


  /**
   * Count Type StoryCountOutputType
   */

  export type StoryCountOutputType = {
    versions: number
    skills: number
  }

  export type StoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | StoryCountOutputTypeCountVersionsArgs
    skills?: boolean | StoryCountOutputTypeCountSkillsArgs
  }

  // Custom InputTypes
  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryCountOutputType
     */
    select?: StoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryVersionWhereInput
  }

  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorySkillWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    created_at?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    created_at?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    username: string | null
    created_at: Date
    updated_at: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "created_at" | "updated_at", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      username: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model ExportHistory
   */

  export type AggregateExportHistory = {
    _count: ExportHistoryCountAggregateOutputType | null
    _min: ExportHistoryMinAggregateOutputType | null
    _max: ExportHistoryMaxAggregateOutputType | null
  }

  export type ExportHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    format: string | null
    filename: string | null
    fileUrl: string | null
    createdAt: Date | null
  }

  export type ExportHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    format: string | null
    filename: string | null
    fileUrl: string | null
    createdAt: Date | null
  }

  export type ExportHistoryCountAggregateOutputType = {
    id: number
    userId: number
    format: number
    filename: number
    fileUrl: number
    settings: number
    createdAt: number
    _all: number
  }


  export type ExportHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    format?: true
    filename?: true
    fileUrl?: true
    createdAt?: true
  }

  export type ExportHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    format?: true
    filename?: true
    fileUrl?: true
    createdAt?: true
  }

  export type ExportHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    format?: true
    filename?: true
    fileUrl?: true
    settings?: true
    createdAt?: true
    _all?: true
  }

  export type ExportHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportHistory to aggregate.
     */
    where?: ExportHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportHistories to fetch.
     */
    orderBy?: ExportHistoryOrderByWithRelationInput | ExportHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExportHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExportHistories
    **/
    _count?: true | ExportHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExportHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExportHistoryMaxAggregateInputType
  }

  export type GetExportHistoryAggregateType<T extends ExportHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateExportHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExportHistory[P]>
      : GetScalarType<T[P], AggregateExportHistory[P]>
  }




  export type ExportHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportHistoryWhereInput
    orderBy?: ExportHistoryOrderByWithAggregationInput | ExportHistoryOrderByWithAggregationInput[]
    by: ExportHistoryScalarFieldEnum[] | ExportHistoryScalarFieldEnum
    having?: ExportHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExportHistoryCountAggregateInputType | true
    _min?: ExportHistoryMinAggregateInputType
    _max?: ExportHistoryMaxAggregateInputType
  }

  export type ExportHistoryGroupByOutputType = {
    id: string
    userId: string
    format: string
    filename: string
    fileUrl: string
    settings: JsonValue | null
    createdAt: Date
    _count: ExportHistoryCountAggregateOutputType | null
    _min: ExportHistoryMinAggregateOutputType | null
    _max: ExportHistoryMaxAggregateOutputType | null
  }

  type GetExportHistoryGroupByPayload<T extends ExportHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExportHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExportHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExportHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ExportHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ExportHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    format?: boolean
    filename?: boolean
    fileUrl?: boolean
    settings?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["exportHistory"]>

  export type ExportHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    format?: boolean
    filename?: boolean
    fileUrl?: boolean
    settings?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["exportHistory"]>

  export type ExportHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    format?: boolean
    filename?: boolean
    fileUrl?: boolean
    settings?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["exportHistory"]>

  export type ExportHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    format?: boolean
    filename?: boolean
    fileUrl?: boolean
    settings?: boolean
    createdAt?: boolean
  }

  export type ExportHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "format" | "filename" | "fileUrl" | "settings" | "createdAt", ExtArgs["result"]["exportHistory"]>

  export type $ExportHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExportHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      format: string
      filename: string
      fileUrl: string
      settings: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["exportHistory"]>
    composites: {}
  }

  type ExportHistoryGetPayload<S extends boolean | null | undefined | ExportHistoryDefaultArgs> = $Result.GetResult<Prisma.$ExportHistoryPayload, S>

  type ExportHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExportHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExportHistoryCountAggregateInputType | true
    }

  export interface ExportHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExportHistory'], meta: { name: 'ExportHistory' } }
    /**
     * Find zero or one ExportHistory that matches the filter.
     * @param {ExportHistoryFindUniqueArgs} args - Arguments to find a ExportHistory
     * @example
     * // Get one ExportHistory
     * const exportHistory = await prisma.exportHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExportHistoryFindUniqueArgs>(args: SelectSubset<T, ExportHistoryFindUniqueArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExportHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExportHistoryFindUniqueOrThrowArgs} args - Arguments to find a ExportHistory
     * @example
     * // Get one ExportHistory
     * const exportHistory = await prisma.exportHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExportHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExportHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExportHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportHistoryFindFirstArgs} args - Arguments to find a ExportHistory
     * @example
     * // Get one ExportHistory
     * const exportHistory = await prisma.exportHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExportHistoryFindFirstArgs>(args?: SelectSubset<T, ExportHistoryFindFirstArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExportHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportHistoryFindFirstOrThrowArgs} args - Arguments to find a ExportHistory
     * @example
     * // Get one ExportHistory
     * const exportHistory = await prisma.exportHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExportHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExportHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExportHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExportHistories
     * const exportHistories = await prisma.exportHistory.findMany()
     * 
     * // Get first 10 ExportHistories
     * const exportHistories = await prisma.exportHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exportHistoryWithIdOnly = await prisma.exportHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExportHistoryFindManyArgs>(args?: SelectSubset<T, ExportHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExportHistory.
     * @param {ExportHistoryCreateArgs} args - Arguments to create a ExportHistory.
     * @example
     * // Create one ExportHistory
     * const ExportHistory = await prisma.exportHistory.create({
     *   data: {
     *     // ... data to create a ExportHistory
     *   }
     * })
     * 
     */
    create<T extends ExportHistoryCreateArgs>(args: SelectSubset<T, ExportHistoryCreateArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExportHistories.
     * @param {ExportHistoryCreateManyArgs} args - Arguments to create many ExportHistories.
     * @example
     * // Create many ExportHistories
     * const exportHistory = await prisma.exportHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExportHistoryCreateManyArgs>(args?: SelectSubset<T, ExportHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExportHistories and returns the data saved in the database.
     * @param {ExportHistoryCreateManyAndReturnArgs} args - Arguments to create many ExportHistories.
     * @example
     * // Create many ExportHistories
     * const exportHistory = await prisma.exportHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExportHistories and only return the `id`
     * const exportHistoryWithIdOnly = await prisma.exportHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExportHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ExportHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExportHistory.
     * @param {ExportHistoryDeleteArgs} args - Arguments to delete one ExportHistory.
     * @example
     * // Delete one ExportHistory
     * const ExportHistory = await prisma.exportHistory.delete({
     *   where: {
     *     // ... filter to delete one ExportHistory
     *   }
     * })
     * 
     */
    delete<T extends ExportHistoryDeleteArgs>(args: SelectSubset<T, ExportHistoryDeleteArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExportHistory.
     * @param {ExportHistoryUpdateArgs} args - Arguments to update one ExportHistory.
     * @example
     * // Update one ExportHistory
     * const exportHistory = await prisma.exportHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExportHistoryUpdateArgs>(args: SelectSubset<T, ExportHistoryUpdateArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExportHistories.
     * @param {ExportHistoryDeleteManyArgs} args - Arguments to filter ExportHistories to delete.
     * @example
     * // Delete a few ExportHistories
     * const { count } = await prisma.exportHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExportHistoryDeleteManyArgs>(args?: SelectSubset<T, ExportHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExportHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExportHistories
     * const exportHistory = await prisma.exportHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExportHistoryUpdateManyArgs>(args: SelectSubset<T, ExportHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExportHistories and returns the data updated in the database.
     * @param {ExportHistoryUpdateManyAndReturnArgs} args - Arguments to update many ExportHistories.
     * @example
     * // Update many ExportHistories
     * const exportHistory = await prisma.exportHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExportHistories and only return the `id`
     * const exportHistoryWithIdOnly = await prisma.exportHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExportHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ExportHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExportHistory.
     * @param {ExportHistoryUpsertArgs} args - Arguments to update or create a ExportHistory.
     * @example
     * // Update or create a ExportHistory
     * const exportHistory = await prisma.exportHistory.upsert({
     *   create: {
     *     // ... data to create a ExportHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExportHistory we want to update
     *   }
     * })
     */
    upsert<T extends ExportHistoryUpsertArgs>(args: SelectSubset<T, ExportHistoryUpsertArgs<ExtArgs>>): Prisma__ExportHistoryClient<$Result.GetResult<Prisma.$ExportHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExportHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportHistoryCountArgs} args - Arguments to filter ExportHistories to count.
     * @example
     * // Count the number of ExportHistories
     * const count = await prisma.exportHistory.count({
     *   where: {
     *     // ... the filter for the ExportHistories we want to count
     *   }
     * })
    **/
    count<T extends ExportHistoryCountArgs>(
      args?: Subset<T, ExportHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExportHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExportHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExportHistoryAggregateArgs>(args: Subset<T, ExportHistoryAggregateArgs>): Prisma.PrismaPromise<GetExportHistoryAggregateType<T>>

    /**
     * Group by ExportHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExportHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExportHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ExportHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExportHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExportHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExportHistory model
   */
  readonly fields: ExportHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExportHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExportHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExportHistory model
   */
  interface ExportHistoryFieldRefs {
    readonly id: FieldRef<"ExportHistory", 'String'>
    readonly userId: FieldRef<"ExportHistory", 'String'>
    readonly format: FieldRef<"ExportHistory", 'String'>
    readonly filename: FieldRef<"ExportHistory", 'String'>
    readonly fileUrl: FieldRef<"ExportHistory", 'String'>
    readonly settings: FieldRef<"ExportHistory", 'Json'>
    readonly createdAt: FieldRef<"ExportHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExportHistory findUnique
   */
  export type ExportHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportHistory
     */
    omit?: ExportHistoryOmit<ExtArgs> | null
    /**
     * Filter, which ExportHistory to fetch.
     */
    where: ExportHistoryWhereUniqueInput
  }

  /**
   * ExportHistory findUniqueOrThrow
   */
  export type ExportHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportHistory
     */
    omit?: ExportHistoryOmit<ExtArgs> | null
    /**
     * Filter, which ExportHistory to fetch.
     */
    where: ExportHistoryWhereUniqueInput
  }

  /**
   * ExportHistory findFirst
   */
  export type ExportHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportHistory
     */
    omit?: ExportHistoryOmit<ExtArgs> | null
    /**
     * Filter, which ExportHistory to fetch.
     */
    where?: ExportHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportHistories to fetch.
     */
    orderBy?: ExportHistoryOrderByWithRelationInput | ExportHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportHistories.
     */
    cursor?: ExportHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportHistories.
     */
    distinct?: ExportHistoryScalarFieldEnum | ExportHistoryScalarFieldEnum[]
  }

  /**
   * ExportHistory findFirstOrThrow
   */
  export type ExportHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportHistory
     */
    omit?: ExportHistoryOmit<ExtArgs> | null
    /**
     * Filter, which ExportHistory to fetch.
     */
    where?: ExportHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportHistories to fetch.
     */
    orderBy?: ExportHistoryOrderByWithRelationInput | ExportHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportHistories.
     */
    cursor?: ExportHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportHistories.
     */
    distinct?: ExportHistoryScalarFieldEnum | ExportHistoryScalarFieldEnum[]
  }

  /**
   * ExportHistory findMany
   */
  export type ExportHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportHistory
     */
    omit?: ExportHistoryOmit<ExtArgs> | null
    /**
     * Filter, which ExportHistories to fetch.
     */
    where?: ExportHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportHistories to fetch.
     */
    orderBy?: ExportHistoryOrderByWithRelationInput | ExportHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExportHistories.
     */
    cursor?: ExportHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportHistories.
     */
    skip?: number
    distinct?: ExportHistoryScalarFieldEnum | ExportHistoryScalarFieldEnum[]
  }

  /**
   * ExportHistory create
   */
  export type ExportHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportHistory
     */
    omit?: ExportHistoryOmit<ExtArgs> | null
    /**
     * The data needed to create a ExportHistory.
     */
    data: XOR<ExportHistoryCreateInput, ExportHistoryUncheckedCreateInput>
  }

  /**
   * ExportHistory createMany
   */
  export type ExportHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExportHistories.
     */
    data: ExportHistoryCreateManyInput | ExportHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExportHistory createManyAndReturn
   */
  export type ExportHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExportHistory
     */
    omit?: ExportHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ExportHistories.
     */
    data: ExportHistoryCreateManyInput | ExportHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExportHistory update
   */
  export type ExportHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportHistory
     */
    omit?: ExportHistoryOmit<ExtArgs> | null
    /**
     * The data needed to update a ExportHistory.
     */
    data: XOR<ExportHistoryUpdateInput, ExportHistoryUncheckedUpdateInput>
    /**
     * Choose, which ExportHistory to update.
     */
    where: ExportHistoryWhereUniqueInput
  }

  /**
   * ExportHistory updateMany
   */
  export type ExportHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExportHistories.
     */
    data: XOR<ExportHistoryUpdateManyMutationInput, ExportHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ExportHistories to update
     */
    where?: ExportHistoryWhereInput
    /**
     * Limit how many ExportHistories to update.
     */
    limit?: number
  }

  /**
   * ExportHistory updateManyAndReturn
   */
  export type ExportHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExportHistory
     */
    omit?: ExportHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ExportHistories.
     */
    data: XOR<ExportHistoryUpdateManyMutationInput, ExportHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ExportHistories to update
     */
    where?: ExportHistoryWhereInput
    /**
     * Limit how many ExportHistories to update.
     */
    limit?: number
  }

  /**
   * ExportHistory upsert
   */
  export type ExportHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportHistory
     */
    omit?: ExportHistoryOmit<ExtArgs> | null
    /**
     * The filter to search for the ExportHistory to update in case it exists.
     */
    where: ExportHistoryWhereUniqueInput
    /**
     * In case the ExportHistory found by the `where` argument doesn't exist, create a new ExportHistory with this data.
     */
    create: XOR<ExportHistoryCreateInput, ExportHistoryUncheckedCreateInput>
    /**
     * In case the ExportHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExportHistoryUpdateInput, ExportHistoryUncheckedUpdateInput>
  }

  /**
   * ExportHistory delete
   */
  export type ExportHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportHistory
     */
    omit?: ExportHistoryOmit<ExtArgs> | null
    /**
     * Filter which ExportHistory to delete.
     */
    where: ExportHistoryWhereUniqueInput
  }

  /**
   * ExportHistory deleteMany
   */
  export type ExportHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportHistories to delete
     */
    where?: ExportHistoryWhereInput
    /**
     * Limit how many ExportHistories to delete.
     */
    limit?: number
  }

  /**
   * ExportHistory without action
   */
  export type ExportHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportHistory
     */
    select?: ExportHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportHistory
     */
    omit?: ExportHistoryOmit<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    full_name: string | null
    preferred_name: string | null
    headline: string | null
    summary: string | null
    location: string | null
    website: string | null
    email: string | null
    phone: string | null
    about: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    full_name: string | null
    preferred_name: string | null
    headline: string | null
    summary: string | null
    location: string | null
    website: string | null
    email: string | null
    phone: string | null
    about: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    user_id: number
    full_name: number
    preferred_name: number
    headline: number
    summary: number
    location: number
    website: number
    email: number
    phone: number
    about: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    user_id?: true
    full_name?: true
    preferred_name?: true
    headline?: true
    summary?: true
    location?: true
    website?: true
    email?: true
    phone?: true
    about?: true
    created_at?: true
    updated_at?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    user_id?: true
    full_name?: true
    preferred_name?: true
    headline?: true
    summary?: true
    location?: true
    website?: true
    email?: true
    phone?: true
    about?: true
    created_at?: true
    updated_at?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    user_id?: true
    full_name?: true
    preferred_name?: true
    headline?: true
    summary?: true
    location?: true
    website?: true
    email?: true
    phone?: true
    about?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    user_id: string | null
    full_name: string | null
    preferred_name: string | null
    headline: string | null
    summary: string | null
    location: string | null
    website: string | null
    email: string | null
    phone: string | null
    about: string | null
    created_at: Date
    updated_at: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    full_name?: boolean
    preferred_name?: boolean
    headline?: boolean
    summary?: boolean
    location?: boolean
    website?: boolean
    email?: boolean
    phone?: boolean
    about?: boolean
    created_at?: boolean
    updated_at?: boolean
    experiences?: boolean | Profile$experiencesArgs<ExtArgs>
    education?: boolean | Profile$educationArgs<ExtArgs>
    skills?: boolean | Profile$skillsArgs<ExtArgs>
    certifications?: boolean | Profile$certificationsArgs<ExtArgs>
    projects?: boolean | Profile$projectsArgs<ExtArgs>
    volunteering?: boolean | Profile$volunteeringArgs<ExtArgs>
    languages?: boolean | Profile$languagesArgs<ExtArgs>
    organizations?: boolean | Profile$organizationsArgs<ExtArgs>
    parsed_documents?: boolean | Profile$parsed_documentsArgs<ExtArgs>
    mediaLibrary?: boolean | Profile$mediaLibraryArgs<ExtArgs>
    customizedStories?: boolean | Profile$customizedStoriesArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    full_name?: boolean
    preferred_name?: boolean
    headline?: boolean
    summary?: boolean
    location?: boolean
    website?: boolean
    email?: boolean
    phone?: boolean
    about?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    full_name?: boolean
    preferred_name?: boolean
    headline?: boolean
    summary?: boolean
    location?: boolean
    website?: boolean
    email?: boolean
    phone?: boolean
    about?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    user_id?: boolean
    full_name?: boolean
    preferred_name?: boolean
    headline?: boolean
    summary?: boolean
    location?: boolean
    website?: boolean
    email?: boolean
    phone?: boolean
    about?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "full_name" | "preferred_name" | "headline" | "summary" | "location" | "website" | "email" | "phone" | "about" | "created_at" | "updated_at", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiences?: boolean | Profile$experiencesArgs<ExtArgs>
    education?: boolean | Profile$educationArgs<ExtArgs>
    skills?: boolean | Profile$skillsArgs<ExtArgs>
    certifications?: boolean | Profile$certificationsArgs<ExtArgs>
    projects?: boolean | Profile$projectsArgs<ExtArgs>
    volunteering?: boolean | Profile$volunteeringArgs<ExtArgs>
    languages?: boolean | Profile$languagesArgs<ExtArgs>
    organizations?: boolean | Profile$organizationsArgs<ExtArgs>
    parsed_documents?: boolean | Profile$parsed_documentsArgs<ExtArgs>
    mediaLibrary?: boolean | Profile$mediaLibraryArgs<ExtArgs>
    customizedStories?: boolean | Profile$customizedStoriesArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      experiences: Prisma.$ExperiencePayload<ExtArgs>[]
      education: Prisma.$EducationPayload<ExtArgs>[]
      skills: Prisma.$SkillPayload<ExtArgs>[]
      certifications: Prisma.$CertificationPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      volunteering: Prisma.$VolunteeringPayload<ExtArgs>[]
      languages: Prisma.$LanguagePayload<ExtArgs>[]
      organizations: Prisma.$OrganizationPayload<ExtArgs>[]
      parsed_documents: Prisma.$ParsedDocumentPayload<ExtArgs>[]
      mediaLibrary: Prisma.$MediaLibraryPayload<ExtArgs>[]
      customizedStories: Prisma.$CustomizedStoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      full_name: string | null
      preferred_name: string | null
      headline: string | null
      summary: string | null
      location: string | null
      website: string | null
      email: string | null
      phone: string | null
      about: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    experiences<T extends Profile$experiencesArgs<ExtArgs> = {}>(args?: Subset<T, Profile$experiencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    education<T extends Profile$educationArgs<ExtArgs> = {}>(args?: Subset<T, Profile$educationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skills<T extends Profile$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certifications<T extends Profile$certificationsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$certificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Profile$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    volunteering<T extends Profile$volunteeringArgs<ExtArgs> = {}>(args?: Subset<T, Profile$volunteeringArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteeringPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    languages<T extends Profile$languagesArgs<ExtArgs> = {}>(args?: Subset<T, Profile$languagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organizations<T extends Profile$organizationsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$organizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parsed_documents<T extends Profile$parsed_documentsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$parsed_documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mediaLibrary<T extends Profile$mediaLibraryArgs<ExtArgs> = {}>(args?: Subset<T, Profile$mediaLibraryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaLibraryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customizedStories<T extends Profile$customizedStoriesArgs<ExtArgs> = {}>(args?: Subset<T, Profile$customizedStoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomizedStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly user_id: FieldRef<"Profile", 'String'>
    readonly full_name: FieldRef<"Profile", 'String'>
    readonly preferred_name: FieldRef<"Profile", 'String'>
    readonly headline: FieldRef<"Profile", 'String'>
    readonly summary: FieldRef<"Profile", 'String'>
    readonly location: FieldRef<"Profile", 'String'>
    readonly website: FieldRef<"Profile", 'String'>
    readonly email: FieldRef<"Profile", 'String'>
    readonly phone: FieldRef<"Profile", 'String'>
    readonly about: FieldRef<"Profile", 'String'>
    readonly created_at: FieldRef<"Profile", 'DateTime'>
    readonly updated_at: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data?: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile.experiences
   */
  export type Profile$experiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    where?: ExperienceWhereInput
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    cursor?: ExperienceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExperienceScalarFieldEnum | ExperienceScalarFieldEnum[]
  }

  /**
   * Profile.education
   */
  export type Profile$educationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    where?: EducationWhereInput
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    cursor?: EducationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Profile.skills
   */
  export type Profile$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    cursor?: SkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Profile.certifications
   */
  export type Profile$certificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    cursor?: CertificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Profile.projects
   */
  export type Profile$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Profile.volunteering
   */
  export type Profile$volunteeringArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteering
     */
    select?: VolunteeringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteering
     */
    omit?: VolunteeringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteeringInclude<ExtArgs> | null
    where?: VolunteeringWhereInput
    orderBy?: VolunteeringOrderByWithRelationInput | VolunteeringOrderByWithRelationInput[]
    cursor?: VolunteeringWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolunteeringScalarFieldEnum | VolunteeringScalarFieldEnum[]
  }

  /**
   * Profile.languages
   */
  export type Profile$languagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    cursor?: LanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Profile.organizations
   */
  export type Profile$organizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    cursor?: OrganizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Profile.parsed_documents
   */
  export type Profile$parsed_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedDocument
     */
    select?: ParsedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedDocument
     */
    omit?: ParsedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedDocumentInclude<ExtArgs> | null
    where?: ParsedDocumentWhereInput
    orderBy?: ParsedDocumentOrderByWithRelationInput | ParsedDocumentOrderByWithRelationInput[]
    cursor?: ParsedDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParsedDocumentScalarFieldEnum | ParsedDocumentScalarFieldEnum[]
  }

  /**
   * Profile.mediaLibrary
   */
  export type Profile$mediaLibraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaLibrary
     */
    select?: MediaLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaLibrary
     */
    omit?: MediaLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaLibraryInclude<ExtArgs> | null
    where?: MediaLibraryWhereInput
    orderBy?: MediaLibraryOrderByWithRelationInput | MediaLibraryOrderByWithRelationInput[]
    cursor?: MediaLibraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaLibraryScalarFieldEnum | MediaLibraryScalarFieldEnum[]
  }

  /**
   * Profile.customizedStories
   */
  export type Profile$customizedStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomizedStory
     */
    select?: CustomizedStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomizedStory
     */
    omit?: CustomizedStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomizedStoryInclude<ExtArgs> | null
    where?: CustomizedStoryWhereInput
    orderBy?: CustomizedStoryOrderByWithRelationInput | CustomizedStoryOrderByWithRelationInput[]
    cursor?: CustomizedStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomizedStoryScalarFieldEnum | CustomizedStoryScalarFieldEnum[]
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model ParsedDocument
   */

  export type AggregateParsedDocument = {
    _count: ParsedDocumentCountAggregateOutputType | null
    _avg: ParsedDocumentAvgAggregateOutputType | null
    _sum: ParsedDocumentSumAggregateOutputType | null
    _min: ParsedDocumentMinAggregateOutputType | null
    _max: ParsedDocumentMaxAggregateOutputType | null
  }

  export type ParsedDocumentAvgAggregateOutputType = {
    size_bytes: number | null
  }

  export type ParsedDocumentSumAggregateOutputType = {
    size_bytes: number | null
  }

  export type ParsedDocumentMinAggregateOutputType = {
    id: string | null
    profile_id: string | null
    user_id: string | null
    file_name: string | null
    storage_path: string | null
    content_type: string | null
    size_bytes: number | null
    text_extracted: string | null
    parser_version: string | null
    status: string | null
    error_text: string | null
    parsed_at: Date | null
    created_at: Date | null
  }

  export type ParsedDocumentMaxAggregateOutputType = {
    id: string | null
    profile_id: string | null
    user_id: string | null
    file_name: string | null
    storage_path: string | null
    content_type: string | null
    size_bytes: number | null
    text_extracted: string | null
    parser_version: string | null
    status: string | null
    error_text: string | null
    parsed_at: Date | null
    created_at: Date | null
  }

  export type ParsedDocumentCountAggregateOutputType = {
    id: number
    profile_id: number
    user_id: number
    file_name: number
    storage_path: number
    content_type: number
    size_bytes: number
    text_extracted: number
    parsed_json: number
    parser_version: number
    status: number
    error_text: number
    parsed_at: number
    created_at: number
    _all: number
  }


  export type ParsedDocumentAvgAggregateInputType = {
    size_bytes?: true
  }

  export type ParsedDocumentSumAggregateInputType = {
    size_bytes?: true
  }

  export type ParsedDocumentMinAggregateInputType = {
    id?: true
    profile_id?: true
    user_id?: true
    file_name?: true
    storage_path?: true
    content_type?: true
    size_bytes?: true
    text_extracted?: true
    parser_version?: true
    status?: true
    error_text?: true
    parsed_at?: true
    created_at?: true
  }

  export type ParsedDocumentMaxAggregateInputType = {
    id?: true
    profile_id?: true
    user_id?: true
    file_name?: true
    storage_path?: true
    content_type?: true
    size_bytes?: true
    text_extracted?: true
    parser_version?: true
    status?: true
    error_text?: true
    parsed_at?: true
    created_at?: true
  }

  export type ParsedDocumentCountAggregateInputType = {
    id?: true
    profile_id?: true
    user_id?: true
    file_name?: true
    storage_path?: true
    content_type?: true
    size_bytes?: true
    text_extracted?: true
    parsed_json?: true
    parser_version?: true
    status?: true
    error_text?: true
    parsed_at?: true
    created_at?: true
    _all?: true
  }

  export type ParsedDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedDocument to aggregate.
     */
    where?: ParsedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedDocuments to fetch.
     */
    orderBy?: ParsedDocumentOrderByWithRelationInput | ParsedDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParsedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParsedDocuments
    **/
    _count?: true | ParsedDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParsedDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParsedDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParsedDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParsedDocumentMaxAggregateInputType
  }

  export type GetParsedDocumentAggregateType<T extends ParsedDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateParsedDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParsedDocument[P]>
      : GetScalarType<T[P], AggregateParsedDocument[P]>
  }




  export type ParsedDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedDocumentWhereInput
    orderBy?: ParsedDocumentOrderByWithAggregationInput | ParsedDocumentOrderByWithAggregationInput[]
    by: ParsedDocumentScalarFieldEnum[] | ParsedDocumentScalarFieldEnum
    having?: ParsedDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParsedDocumentCountAggregateInputType | true
    _avg?: ParsedDocumentAvgAggregateInputType
    _sum?: ParsedDocumentSumAggregateInputType
    _min?: ParsedDocumentMinAggregateInputType
    _max?: ParsedDocumentMaxAggregateInputType
  }

  export type ParsedDocumentGroupByOutputType = {
    id: string
    profile_id: string | null
    user_id: string | null
    file_name: string | null
    storage_path: string | null
    content_type: string | null
    size_bytes: number | null
    text_extracted: string | null
    parsed_json: JsonValue | null
    parser_version: string | null
    status: string | null
    error_text: string | null
    parsed_at: Date | null
    created_at: Date
    _count: ParsedDocumentCountAggregateOutputType | null
    _avg: ParsedDocumentAvgAggregateOutputType | null
    _sum: ParsedDocumentSumAggregateOutputType | null
    _min: ParsedDocumentMinAggregateOutputType | null
    _max: ParsedDocumentMaxAggregateOutputType | null
  }

  type GetParsedDocumentGroupByPayload<T extends ParsedDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParsedDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParsedDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParsedDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], ParsedDocumentGroupByOutputType[P]>
        }
      >
    >


  export type ParsedDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    user_id?: boolean
    file_name?: boolean
    storage_path?: boolean
    content_type?: boolean
    size_bytes?: boolean
    text_extracted?: boolean
    parsed_json?: boolean
    parser_version?: boolean
    status?: boolean
    error_text?: boolean
    parsed_at?: boolean
    created_at?: boolean
    parsing_jobs?: boolean | ParsedDocument$parsing_jobsArgs<ExtArgs>
    profile?: boolean | ParsedDocument$profileArgs<ExtArgs>
    _count?: boolean | ParsedDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedDocument"]>

  export type ParsedDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    user_id?: boolean
    file_name?: boolean
    storage_path?: boolean
    content_type?: boolean
    size_bytes?: boolean
    text_extracted?: boolean
    parsed_json?: boolean
    parser_version?: boolean
    status?: boolean
    error_text?: boolean
    parsed_at?: boolean
    created_at?: boolean
    profile?: boolean | ParsedDocument$profileArgs<ExtArgs>
  }, ExtArgs["result"]["parsedDocument"]>

  export type ParsedDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    user_id?: boolean
    file_name?: boolean
    storage_path?: boolean
    content_type?: boolean
    size_bytes?: boolean
    text_extracted?: boolean
    parsed_json?: boolean
    parser_version?: boolean
    status?: boolean
    error_text?: boolean
    parsed_at?: boolean
    created_at?: boolean
    profile?: boolean | ParsedDocument$profileArgs<ExtArgs>
  }, ExtArgs["result"]["parsedDocument"]>

  export type ParsedDocumentSelectScalar = {
    id?: boolean
    profile_id?: boolean
    user_id?: boolean
    file_name?: boolean
    storage_path?: boolean
    content_type?: boolean
    size_bytes?: boolean
    text_extracted?: boolean
    parsed_json?: boolean
    parser_version?: boolean
    status?: boolean
    error_text?: boolean
    parsed_at?: boolean
    created_at?: boolean
  }

  export type ParsedDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profile_id" | "user_id" | "file_name" | "storage_path" | "content_type" | "size_bytes" | "text_extracted" | "parsed_json" | "parser_version" | "status" | "error_text" | "parsed_at" | "created_at", ExtArgs["result"]["parsedDocument"]>
  export type ParsedDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parsing_jobs?: boolean | ParsedDocument$parsing_jobsArgs<ExtArgs>
    profile?: boolean | ParsedDocument$profileArgs<ExtArgs>
    _count?: boolean | ParsedDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParsedDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ParsedDocument$profileArgs<ExtArgs>
  }
  export type ParsedDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ParsedDocument$profileArgs<ExtArgs>
  }

  export type $ParsedDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParsedDocument"
    objects: {
      parsing_jobs: Prisma.$ParsingJobPayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profile_id: string | null
      user_id: string | null
      file_name: string | null
      storage_path: string | null
      content_type: string | null
      size_bytes: number | null
      text_extracted: string | null
      parsed_json: Prisma.JsonValue | null
      parser_version: string | null
      status: string | null
      error_text: string | null
      parsed_at: Date | null
      created_at: Date
    }, ExtArgs["result"]["parsedDocument"]>
    composites: {}
  }

  type ParsedDocumentGetPayload<S extends boolean | null | undefined | ParsedDocumentDefaultArgs> = $Result.GetResult<Prisma.$ParsedDocumentPayload, S>

  type ParsedDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParsedDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParsedDocumentCountAggregateInputType | true
    }

  export interface ParsedDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParsedDocument'], meta: { name: 'ParsedDocument' } }
    /**
     * Find zero or one ParsedDocument that matches the filter.
     * @param {ParsedDocumentFindUniqueArgs} args - Arguments to find a ParsedDocument
     * @example
     * // Get one ParsedDocument
     * const parsedDocument = await prisma.parsedDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParsedDocumentFindUniqueArgs>(args: SelectSubset<T, ParsedDocumentFindUniqueArgs<ExtArgs>>): Prisma__ParsedDocumentClient<$Result.GetResult<Prisma.$ParsedDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParsedDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParsedDocumentFindUniqueOrThrowArgs} args - Arguments to find a ParsedDocument
     * @example
     * // Get one ParsedDocument
     * const parsedDocument = await prisma.parsedDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParsedDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, ParsedDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParsedDocumentClient<$Result.GetResult<Prisma.$ParsedDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedDocumentFindFirstArgs} args - Arguments to find a ParsedDocument
     * @example
     * // Get one ParsedDocument
     * const parsedDocument = await prisma.parsedDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParsedDocumentFindFirstArgs>(args?: SelectSubset<T, ParsedDocumentFindFirstArgs<ExtArgs>>): Prisma__ParsedDocumentClient<$Result.GetResult<Prisma.$ParsedDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedDocumentFindFirstOrThrowArgs} args - Arguments to find a ParsedDocument
     * @example
     * // Get one ParsedDocument
     * const parsedDocument = await prisma.parsedDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParsedDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, ParsedDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParsedDocumentClient<$Result.GetResult<Prisma.$ParsedDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParsedDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParsedDocuments
     * const parsedDocuments = await prisma.parsedDocument.findMany()
     * 
     * // Get first 10 ParsedDocuments
     * const parsedDocuments = await prisma.parsedDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parsedDocumentWithIdOnly = await prisma.parsedDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParsedDocumentFindManyArgs>(args?: SelectSubset<T, ParsedDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParsedDocument.
     * @param {ParsedDocumentCreateArgs} args - Arguments to create a ParsedDocument.
     * @example
     * // Create one ParsedDocument
     * const ParsedDocument = await prisma.parsedDocument.create({
     *   data: {
     *     // ... data to create a ParsedDocument
     *   }
     * })
     * 
     */
    create<T extends ParsedDocumentCreateArgs>(args: SelectSubset<T, ParsedDocumentCreateArgs<ExtArgs>>): Prisma__ParsedDocumentClient<$Result.GetResult<Prisma.$ParsedDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParsedDocuments.
     * @param {ParsedDocumentCreateManyArgs} args - Arguments to create many ParsedDocuments.
     * @example
     * // Create many ParsedDocuments
     * const parsedDocument = await prisma.parsedDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParsedDocumentCreateManyArgs>(args?: SelectSubset<T, ParsedDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParsedDocuments and returns the data saved in the database.
     * @param {ParsedDocumentCreateManyAndReturnArgs} args - Arguments to create many ParsedDocuments.
     * @example
     * // Create many ParsedDocuments
     * const parsedDocument = await prisma.parsedDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParsedDocuments and only return the `id`
     * const parsedDocumentWithIdOnly = await prisma.parsedDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParsedDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, ParsedDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParsedDocument.
     * @param {ParsedDocumentDeleteArgs} args - Arguments to delete one ParsedDocument.
     * @example
     * // Delete one ParsedDocument
     * const ParsedDocument = await prisma.parsedDocument.delete({
     *   where: {
     *     // ... filter to delete one ParsedDocument
     *   }
     * })
     * 
     */
    delete<T extends ParsedDocumentDeleteArgs>(args: SelectSubset<T, ParsedDocumentDeleteArgs<ExtArgs>>): Prisma__ParsedDocumentClient<$Result.GetResult<Prisma.$ParsedDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParsedDocument.
     * @param {ParsedDocumentUpdateArgs} args - Arguments to update one ParsedDocument.
     * @example
     * // Update one ParsedDocument
     * const parsedDocument = await prisma.parsedDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParsedDocumentUpdateArgs>(args: SelectSubset<T, ParsedDocumentUpdateArgs<ExtArgs>>): Prisma__ParsedDocumentClient<$Result.GetResult<Prisma.$ParsedDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParsedDocuments.
     * @param {ParsedDocumentDeleteManyArgs} args - Arguments to filter ParsedDocuments to delete.
     * @example
     * // Delete a few ParsedDocuments
     * const { count } = await prisma.parsedDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParsedDocumentDeleteManyArgs>(args?: SelectSubset<T, ParsedDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParsedDocuments
     * const parsedDocument = await prisma.parsedDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParsedDocumentUpdateManyArgs>(args: SelectSubset<T, ParsedDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedDocuments and returns the data updated in the database.
     * @param {ParsedDocumentUpdateManyAndReturnArgs} args - Arguments to update many ParsedDocuments.
     * @example
     * // Update many ParsedDocuments
     * const parsedDocument = await prisma.parsedDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParsedDocuments and only return the `id`
     * const parsedDocumentWithIdOnly = await prisma.parsedDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParsedDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, ParsedDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParsedDocument.
     * @param {ParsedDocumentUpsertArgs} args - Arguments to update or create a ParsedDocument.
     * @example
     * // Update or create a ParsedDocument
     * const parsedDocument = await prisma.parsedDocument.upsert({
     *   create: {
     *     // ... data to create a ParsedDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParsedDocument we want to update
     *   }
     * })
     */
    upsert<T extends ParsedDocumentUpsertArgs>(args: SelectSubset<T, ParsedDocumentUpsertArgs<ExtArgs>>): Prisma__ParsedDocumentClient<$Result.GetResult<Prisma.$ParsedDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParsedDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedDocumentCountArgs} args - Arguments to filter ParsedDocuments to count.
     * @example
     * // Count the number of ParsedDocuments
     * const count = await prisma.parsedDocument.count({
     *   where: {
     *     // ... the filter for the ParsedDocuments we want to count
     *   }
     * })
    **/
    count<T extends ParsedDocumentCountArgs>(
      args?: Subset<T, ParsedDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParsedDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParsedDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParsedDocumentAggregateArgs>(args: Subset<T, ParsedDocumentAggregateArgs>): Prisma.PrismaPromise<GetParsedDocumentAggregateType<T>>

    /**
     * Group by ParsedDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParsedDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParsedDocumentGroupByArgs['orderBy'] }
        : { orderBy?: ParsedDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParsedDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParsedDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParsedDocument model
   */
  readonly fields: ParsedDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParsedDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParsedDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parsing_jobs<T extends ParsedDocument$parsing_jobsArgs<ExtArgs> = {}>(args?: Subset<T, ParsedDocument$parsing_jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsingJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profile<T extends ParsedDocument$profileArgs<ExtArgs> = {}>(args?: Subset<T, ParsedDocument$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParsedDocument model
   */
  interface ParsedDocumentFieldRefs {
    readonly id: FieldRef<"ParsedDocument", 'String'>
    readonly profile_id: FieldRef<"ParsedDocument", 'String'>
    readonly user_id: FieldRef<"ParsedDocument", 'String'>
    readonly file_name: FieldRef<"ParsedDocument", 'String'>
    readonly storage_path: FieldRef<"ParsedDocument", 'String'>
    readonly content_type: FieldRef<"ParsedDocument", 'String'>
    readonly size_bytes: FieldRef<"ParsedDocument", 'Int'>
    readonly text_extracted: FieldRef<"ParsedDocument", 'String'>
    readonly parsed_json: FieldRef<"ParsedDocument", 'Json'>
    readonly parser_version: FieldRef<"ParsedDocument", 'String'>
    readonly status: FieldRef<"ParsedDocument", 'String'>
    readonly error_text: FieldRef<"ParsedDocument", 'String'>
    readonly parsed_at: FieldRef<"ParsedDocument", 'DateTime'>
    readonly created_at: FieldRef<"ParsedDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParsedDocument findUnique
   */
  export type ParsedDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedDocument
     */
    select?: ParsedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedDocument
     */
    omit?: ParsedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ParsedDocument to fetch.
     */
    where: ParsedDocumentWhereUniqueInput
  }

  /**
   * ParsedDocument findUniqueOrThrow
   */
  export type ParsedDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedDocument
     */
    select?: ParsedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedDocument
     */
    omit?: ParsedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ParsedDocument to fetch.
     */
    where: ParsedDocumentWhereUniqueInput
  }

  /**
   * ParsedDocument findFirst
   */
  export type ParsedDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedDocument
     */
    select?: ParsedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedDocument
     */
    omit?: ParsedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ParsedDocument to fetch.
     */
    where?: ParsedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedDocuments to fetch.
     */
    orderBy?: ParsedDocumentOrderByWithRelationInput | ParsedDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedDocuments.
     */
    cursor?: ParsedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedDocuments.
     */
    distinct?: ParsedDocumentScalarFieldEnum | ParsedDocumentScalarFieldEnum[]
  }

  /**
   * ParsedDocument findFirstOrThrow
   */
  export type ParsedDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedDocument
     */
    select?: ParsedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedDocument
     */
    omit?: ParsedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ParsedDocument to fetch.
     */
    where?: ParsedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedDocuments to fetch.
     */
    orderBy?: ParsedDocumentOrderByWithRelationInput | ParsedDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedDocuments.
     */
    cursor?: ParsedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedDocuments.
     */
    distinct?: ParsedDocumentScalarFieldEnum | ParsedDocumentScalarFieldEnum[]
  }

  /**
   * ParsedDocument findMany
   */
  export type ParsedDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedDocument
     */
    select?: ParsedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedDocument
     */
    omit?: ParsedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ParsedDocuments to fetch.
     */
    where?: ParsedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedDocuments to fetch.
     */
    orderBy?: ParsedDocumentOrderByWithRelationInput | ParsedDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParsedDocuments.
     */
    cursor?: ParsedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedDocuments.
     */
    skip?: number
    distinct?: ParsedDocumentScalarFieldEnum | ParsedDocumentScalarFieldEnum[]
  }

  /**
   * ParsedDocument create
   */
  export type ParsedDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedDocument
     */
    select?: ParsedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedDocument
     */
    omit?: ParsedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a ParsedDocument.
     */
    data?: XOR<ParsedDocumentCreateInput, ParsedDocumentUncheckedCreateInput>
  }

  /**
   * ParsedDocument createMany
   */
  export type ParsedDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParsedDocuments.
     */
    data: ParsedDocumentCreateManyInput | ParsedDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParsedDocument createManyAndReturn
   */
  export type ParsedDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedDocument
     */
    select?: ParsedDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedDocument
     */
    omit?: ParsedDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many ParsedDocuments.
     */
    data: ParsedDocumentCreateManyInput | ParsedDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedDocument update
   */
  export type ParsedDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedDocument
     */
    select?: ParsedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedDocument
     */
    omit?: ParsedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a ParsedDocument.
     */
    data: XOR<ParsedDocumentUpdateInput, ParsedDocumentUncheckedUpdateInput>
    /**
     * Choose, which ParsedDocument to update.
     */
    where: ParsedDocumentWhereUniqueInput
  }

  /**
   * ParsedDocument updateMany
   */
  export type ParsedDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParsedDocuments.
     */
    data: XOR<ParsedDocumentUpdateManyMutationInput, ParsedDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ParsedDocuments to update
     */
    where?: ParsedDocumentWhereInput
    /**
     * Limit how many ParsedDocuments to update.
     */
    limit?: number
  }

  /**
   * ParsedDocument updateManyAndReturn
   */
  export type ParsedDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedDocument
     */
    select?: ParsedDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedDocument
     */
    omit?: ParsedDocumentOmit<ExtArgs> | null
    /**
     * The data used to update ParsedDocuments.
     */
    data: XOR<ParsedDocumentUpdateManyMutationInput, ParsedDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ParsedDocuments to update
     */
    where?: ParsedDocumentWhereInput
    /**
     * Limit how many ParsedDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedDocument upsert
   */
  export type ParsedDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedDocument
     */
    select?: ParsedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedDocument
     */
    omit?: ParsedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the ParsedDocument to update in case it exists.
     */
    where: ParsedDocumentWhereUniqueInput
    /**
     * In case the ParsedDocument found by the `where` argument doesn't exist, create a new ParsedDocument with this data.
     */
    create: XOR<ParsedDocumentCreateInput, ParsedDocumentUncheckedCreateInput>
    /**
     * In case the ParsedDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParsedDocumentUpdateInput, ParsedDocumentUncheckedUpdateInput>
  }

  /**
   * ParsedDocument delete
   */
  export type ParsedDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedDocument
     */
    select?: ParsedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedDocument
     */
    omit?: ParsedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedDocumentInclude<ExtArgs> | null
    /**
     * Filter which ParsedDocument to delete.
     */
    where: ParsedDocumentWhereUniqueInput
  }

  /**
   * ParsedDocument deleteMany
   */
  export type ParsedDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedDocuments to delete
     */
    where?: ParsedDocumentWhereInput
    /**
     * Limit how many ParsedDocuments to delete.
     */
    limit?: number
  }

  /**
   * ParsedDocument.parsing_jobs
   */
  export type ParsedDocument$parsing_jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsingJob
     */
    select?: ParsingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsingJob
     */
    omit?: ParsingJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsingJobInclude<ExtArgs> | null
    where?: ParsingJobWhereInput
    orderBy?: ParsingJobOrderByWithRelationInput | ParsingJobOrderByWithRelationInput[]
    cursor?: ParsingJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParsingJobScalarFieldEnum | ParsingJobScalarFieldEnum[]
  }

  /**
   * ParsedDocument.profile
   */
  export type ParsedDocument$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * ParsedDocument without action
   */
  export type ParsedDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedDocument
     */
    select?: ParsedDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedDocument
     */
    omit?: ParsedDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Experience
   */

  export type AggregateExperience = {
    _count: ExperienceCountAggregateOutputType | null
    _avg: ExperienceAvgAggregateOutputType | null
    _sum: ExperienceSumAggregateOutputType | null
    _min: ExperienceMinAggregateOutputType | null
    _max: ExperienceMaxAggregateOutputType | null
  }

  export type ExperienceAvgAggregateOutputType = {
    order_index: number | null
  }

  export type ExperienceSumAggregateOutputType = {
    order_index: number | null
  }

  export type ExperienceMinAggregateOutputType = {
    id: string | null
    profile_id: string | null
    title: string | null
    company: string | null
    location: string | null
    start_date: Date | null
    end_date: Date | null
    is_current: boolean | null
    description: string | null
    order_index: number | null
    created_at: Date | null
  }

  export type ExperienceMaxAggregateOutputType = {
    id: string | null
    profile_id: string | null
    title: string | null
    company: string | null
    location: string | null
    start_date: Date | null
    end_date: Date | null
    is_current: boolean | null
    description: string | null
    order_index: number | null
    created_at: Date | null
  }

  export type ExperienceCountAggregateOutputType = {
    id: number
    profile_id: number
    title: number
    company: number
    location: number
    start_date: number
    end_date: number
    is_current: number
    description: number
    raw_json: number
    order_index: number
    created_at: number
    _all: number
  }


  export type ExperienceAvgAggregateInputType = {
    order_index?: true
  }

  export type ExperienceSumAggregateInputType = {
    order_index?: true
  }

  export type ExperienceMinAggregateInputType = {
    id?: true
    profile_id?: true
    title?: true
    company?: true
    location?: true
    start_date?: true
    end_date?: true
    is_current?: true
    description?: true
    order_index?: true
    created_at?: true
  }

  export type ExperienceMaxAggregateInputType = {
    id?: true
    profile_id?: true
    title?: true
    company?: true
    location?: true
    start_date?: true
    end_date?: true
    is_current?: true
    description?: true
    order_index?: true
    created_at?: true
  }

  export type ExperienceCountAggregateInputType = {
    id?: true
    profile_id?: true
    title?: true
    company?: true
    location?: true
    start_date?: true
    end_date?: true
    is_current?: true
    description?: true
    raw_json?: true
    order_index?: true
    created_at?: true
    _all?: true
  }

  export type ExperienceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Experience to aggregate.
     */
    where?: ExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiences to fetch.
     */
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Experiences
    **/
    _count?: true | ExperienceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExperienceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExperienceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExperienceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExperienceMaxAggregateInputType
  }

  export type GetExperienceAggregateType<T extends ExperienceAggregateArgs> = {
        [P in keyof T & keyof AggregateExperience]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExperience[P]>
      : GetScalarType<T[P], AggregateExperience[P]>
  }




  export type ExperienceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperienceWhereInput
    orderBy?: ExperienceOrderByWithAggregationInput | ExperienceOrderByWithAggregationInput[]
    by: ExperienceScalarFieldEnum[] | ExperienceScalarFieldEnum
    having?: ExperienceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExperienceCountAggregateInputType | true
    _avg?: ExperienceAvgAggregateInputType
    _sum?: ExperienceSumAggregateInputType
    _min?: ExperienceMinAggregateInputType
    _max?: ExperienceMaxAggregateInputType
  }

  export type ExperienceGroupByOutputType = {
    id: string
    profile_id: string
    title: string | null
    company: string | null
    location: string | null
    start_date: Date | null
    end_date: Date | null
    is_current: boolean
    description: string | null
    raw_json: JsonValue | null
    order_index: number | null
    created_at: Date
    _count: ExperienceCountAggregateOutputType | null
    _avg: ExperienceAvgAggregateOutputType | null
    _sum: ExperienceSumAggregateOutputType | null
    _min: ExperienceMinAggregateOutputType | null
    _max: ExperienceMaxAggregateOutputType | null
  }

  type GetExperienceGroupByPayload<T extends ExperienceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExperienceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExperienceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExperienceGroupByOutputType[P]>
            : GetScalarType<T[P], ExperienceGroupByOutputType[P]>
        }
      >
    >


  export type ExperienceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    title?: boolean
    company?: boolean
    location?: boolean
    start_date?: boolean
    end_date?: boolean
    is_current?: boolean
    description?: boolean
    raw_json?: boolean
    order_index?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    stories?: boolean | Experience$storiesArgs<ExtArgs>
    _count?: boolean | ExperienceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["experience"]>

  export type ExperienceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    title?: boolean
    company?: boolean
    location?: boolean
    start_date?: boolean
    end_date?: boolean
    is_current?: boolean
    description?: boolean
    raw_json?: boolean
    order_index?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["experience"]>

  export type ExperienceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    title?: boolean
    company?: boolean
    location?: boolean
    start_date?: boolean
    end_date?: boolean
    is_current?: boolean
    description?: boolean
    raw_json?: boolean
    order_index?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["experience"]>

  export type ExperienceSelectScalar = {
    id?: boolean
    profile_id?: boolean
    title?: boolean
    company?: boolean
    location?: boolean
    start_date?: boolean
    end_date?: boolean
    is_current?: boolean
    description?: boolean
    raw_json?: boolean
    order_index?: boolean
    created_at?: boolean
  }

  export type ExperienceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profile_id" | "title" | "company" | "location" | "start_date" | "end_date" | "is_current" | "description" | "raw_json" | "order_index" | "created_at", ExtArgs["result"]["experience"]>
  export type ExperienceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    stories?: boolean | Experience$storiesArgs<ExtArgs>
    _count?: boolean | ExperienceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExperienceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ExperienceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ExperiencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Experience"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      stories: Prisma.$StoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profile_id: string
      title: string | null
      company: string | null
      location: string | null
      start_date: Date | null
      end_date: Date | null
      is_current: boolean
      description: string | null
      raw_json: Prisma.JsonValue | null
      order_index: number | null
      created_at: Date
    }, ExtArgs["result"]["experience"]>
    composites: {}
  }

  type ExperienceGetPayload<S extends boolean | null | undefined | ExperienceDefaultArgs> = $Result.GetResult<Prisma.$ExperiencePayload, S>

  type ExperienceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExperienceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExperienceCountAggregateInputType | true
    }

  export interface ExperienceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Experience'], meta: { name: 'Experience' } }
    /**
     * Find zero or one Experience that matches the filter.
     * @param {ExperienceFindUniqueArgs} args - Arguments to find a Experience
     * @example
     * // Get one Experience
     * const experience = await prisma.experience.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExperienceFindUniqueArgs>(args: SelectSubset<T, ExperienceFindUniqueArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Experience that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExperienceFindUniqueOrThrowArgs} args - Arguments to find a Experience
     * @example
     * // Get one Experience
     * const experience = await prisma.experience.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExperienceFindUniqueOrThrowArgs>(args: SelectSubset<T, ExperienceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Experience that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceFindFirstArgs} args - Arguments to find a Experience
     * @example
     * // Get one Experience
     * const experience = await prisma.experience.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExperienceFindFirstArgs>(args?: SelectSubset<T, ExperienceFindFirstArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Experience that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceFindFirstOrThrowArgs} args - Arguments to find a Experience
     * @example
     * // Get one Experience
     * const experience = await prisma.experience.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExperienceFindFirstOrThrowArgs>(args?: SelectSubset<T, ExperienceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Experiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Experiences
     * const experiences = await prisma.experience.findMany()
     * 
     * // Get first 10 Experiences
     * const experiences = await prisma.experience.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const experienceWithIdOnly = await prisma.experience.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExperienceFindManyArgs>(args?: SelectSubset<T, ExperienceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Experience.
     * @param {ExperienceCreateArgs} args - Arguments to create a Experience.
     * @example
     * // Create one Experience
     * const Experience = await prisma.experience.create({
     *   data: {
     *     // ... data to create a Experience
     *   }
     * })
     * 
     */
    create<T extends ExperienceCreateArgs>(args: SelectSubset<T, ExperienceCreateArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Experiences.
     * @param {ExperienceCreateManyArgs} args - Arguments to create many Experiences.
     * @example
     * // Create many Experiences
     * const experience = await prisma.experience.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExperienceCreateManyArgs>(args?: SelectSubset<T, ExperienceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Experiences and returns the data saved in the database.
     * @param {ExperienceCreateManyAndReturnArgs} args - Arguments to create many Experiences.
     * @example
     * // Create many Experiences
     * const experience = await prisma.experience.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Experiences and only return the `id`
     * const experienceWithIdOnly = await prisma.experience.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExperienceCreateManyAndReturnArgs>(args?: SelectSubset<T, ExperienceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Experience.
     * @param {ExperienceDeleteArgs} args - Arguments to delete one Experience.
     * @example
     * // Delete one Experience
     * const Experience = await prisma.experience.delete({
     *   where: {
     *     // ... filter to delete one Experience
     *   }
     * })
     * 
     */
    delete<T extends ExperienceDeleteArgs>(args: SelectSubset<T, ExperienceDeleteArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Experience.
     * @param {ExperienceUpdateArgs} args - Arguments to update one Experience.
     * @example
     * // Update one Experience
     * const experience = await prisma.experience.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExperienceUpdateArgs>(args: SelectSubset<T, ExperienceUpdateArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Experiences.
     * @param {ExperienceDeleteManyArgs} args - Arguments to filter Experiences to delete.
     * @example
     * // Delete a few Experiences
     * const { count } = await prisma.experience.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExperienceDeleteManyArgs>(args?: SelectSubset<T, ExperienceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Experiences
     * const experience = await prisma.experience.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExperienceUpdateManyArgs>(args: SelectSubset<T, ExperienceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Experiences and returns the data updated in the database.
     * @param {ExperienceUpdateManyAndReturnArgs} args - Arguments to update many Experiences.
     * @example
     * // Update many Experiences
     * const experience = await prisma.experience.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Experiences and only return the `id`
     * const experienceWithIdOnly = await prisma.experience.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExperienceUpdateManyAndReturnArgs>(args: SelectSubset<T, ExperienceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Experience.
     * @param {ExperienceUpsertArgs} args - Arguments to update or create a Experience.
     * @example
     * // Update or create a Experience
     * const experience = await prisma.experience.upsert({
     *   create: {
     *     // ... data to create a Experience
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Experience we want to update
     *   }
     * })
     */
    upsert<T extends ExperienceUpsertArgs>(args: SelectSubset<T, ExperienceUpsertArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceCountArgs} args - Arguments to filter Experiences to count.
     * @example
     * // Count the number of Experiences
     * const count = await prisma.experience.count({
     *   where: {
     *     // ... the filter for the Experiences we want to count
     *   }
     * })
    **/
    count<T extends ExperienceCountArgs>(
      args?: Subset<T, ExperienceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExperienceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Experience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExperienceAggregateArgs>(args: Subset<T, ExperienceAggregateArgs>): Prisma.PrismaPromise<GetExperienceAggregateType<T>>

    /**
     * Group by Experience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExperienceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExperienceGroupByArgs['orderBy'] }
        : { orderBy?: ExperienceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExperienceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExperienceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Experience model
   */
  readonly fields: ExperienceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Experience.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExperienceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stories<T extends Experience$storiesArgs<ExtArgs> = {}>(args?: Subset<T, Experience$storiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Experience model
   */
  interface ExperienceFieldRefs {
    readonly id: FieldRef<"Experience", 'String'>
    readonly profile_id: FieldRef<"Experience", 'String'>
    readonly title: FieldRef<"Experience", 'String'>
    readonly company: FieldRef<"Experience", 'String'>
    readonly location: FieldRef<"Experience", 'String'>
    readonly start_date: FieldRef<"Experience", 'DateTime'>
    readonly end_date: FieldRef<"Experience", 'DateTime'>
    readonly is_current: FieldRef<"Experience", 'Boolean'>
    readonly description: FieldRef<"Experience", 'String'>
    readonly raw_json: FieldRef<"Experience", 'Json'>
    readonly order_index: FieldRef<"Experience", 'Int'>
    readonly created_at: FieldRef<"Experience", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Experience findUnique
   */
  export type ExperienceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experience to fetch.
     */
    where: ExperienceWhereUniqueInput
  }

  /**
   * Experience findUniqueOrThrow
   */
  export type ExperienceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experience to fetch.
     */
    where: ExperienceWhereUniqueInput
  }

  /**
   * Experience findFirst
   */
  export type ExperienceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experience to fetch.
     */
    where?: ExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiences to fetch.
     */
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Experiences.
     */
    cursor?: ExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Experiences.
     */
    distinct?: ExperienceScalarFieldEnum | ExperienceScalarFieldEnum[]
  }

  /**
   * Experience findFirstOrThrow
   */
  export type ExperienceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experience to fetch.
     */
    where?: ExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiences to fetch.
     */
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Experiences.
     */
    cursor?: ExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Experiences.
     */
    distinct?: ExperienceScalarFieldEnum | ExperienceScalarFieldEnum[]
  }

  /**
   * Experience findMany
   */
  export type ExperienceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experiences to fetch.
     */
    where?: ExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiences to fetch.
     */
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Experiences.
     */
    cursor?: ExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiences.
     */
    skip?: number
    distinct?: ExperienceScalarFieldEnum | ExperienceScalarFieldEnum[]
  }

  /**
   * Experience create
   */
  export type ExperienceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * The data needed to create a Experience.
     */
    data: XOR<ExperienceCreateInput, ExperienceUncheckedCreateInput>
  }

  /**
   * Experience createMany
   */
  export type ExperienceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Experiences.
     */
    data: ExperienceCreateManyInput | ExperienceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Experience createManyAndReturn
   */
  export type ExperienceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * The data used to create many Experiences.
     */
    data: ExperienceCreateManyInput | ExperienceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Experience update
   */
  export type ExperienceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * The data needed to update a Experience.
     */
    data: XOR<ExperienceUpdateInput, ExperienceUncheckedUpdateInput>
    /**
     * Choose, which Experience to update.
     */
    where: ExperienceWhereUniqueInput
  }

  /**
   * Experience updateMany
   */
  export type ExperienceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Experiences.
     */
    data: XOR<ExperienceUpdateManyMutationInput, ExperienceUncheckedUpdateManyInput>
    /**
     * Filter which Experiences to update
     */
    where?: ExperienceWhereInput
    /**
     * Limit how many Experiences to update.
     */
    limit?: number
  }

  /**
   * Experience updateManyAndReturn
   */
  export type ExperienceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * The data used to update Experiences.
     */
    data: XOR<ExperienceUpdateManyMutationInput, ExperienceUncheckedUpdateManyInput>
    /**
     * Filter which Experiences to update
     */
    where?: ExperienceWhereInput
    /**
     * Limit how many Experiences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Experience upsert
   */
  export type ExperienceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * The filter to search for the Experience to update in case it exists.
     */
    where: ExperienceWhereUniqueInput
    /**
     * In case the Experience found by the `where` argument doesn't exist, create a new Experience with this data.
     */
    create: XOR<ExperienceCreateInput, ExperienceUncheckedCreateInput>
    /**
     * In case the Experience was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExperienceUpdateInput, ExperienceUncheckedUpdateInput>
  }

  /**
   * Experience delete
   */
  export type ExperienceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter which Experience to delete.
     */
    where: ExperienceWhereUniqueInput
  }

  /**
   * Experience deleteMany
   */
  export type ExperienceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Experiences to delete
     */
    where?: ExperienceWhereInput
    /**
     * Limit how many Experiences to delete.
     */
    limit?: number
  }

  /**
   * Experience.stories
   */
  export type Experience$storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    where?: StoryWhereInput
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    cursor?: StoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Experience without action
   */
  export type ExperienceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
  }


  /**
   * Model Education
   */

  export type AggregateEducation = {
    _count: EducationCountAggregateOutputType | null
    _avg: EducationAvgAggregateOutputType | null
    _sum: EducationSumAggregateOutputType | null
    _min: EducationMinAggregateOutputType | null
    _max: EducationMaxAggregateOutputType | null
  }

  export type EducationAvgAggregateOutputType = {
    start_year: number | null
    end_year: number | null
  }

  export type EducationSumAggregateOutputType = {
    start_year: number | null
    end_year: number | null
  }

  export type EducationMinAggregateOutputType = {
    id: string | null
    profile_id: string | null
    school: string | null
    degree: string | null
    field_of_study: string | null
    start_year: number | null
    end_year: number | null
    description: string | null
    created_at: Date | null
  }

  export type EducationMaxAggregateOutputType = {
    id: string | null
    profile_id: string | null
    school: string | null
    degree: string | null
    field_of_study: string | null
    start_year: number | null
    end_year: number | null
    description: string | null
    created_at: Date | null
  }

  export type EducationCountAggregateOutputType = {
    id: number
    profile_id: number
    school: number
    degree: number
    field_of_study: number
    start_year: number
    end_year: number
    description: number
    raw_json: number
    created_at: number
    _all: number
  }


  export type EducationAvgAggregateInputType = {
    start_year?: true
    end_year?: true
  }

  export type EducationSumAggregateInputType = {
    start_year?: true
    end_year?: true
  }

  export type EducationMinAggregateInputType = {
    id?: true
    profile_id?: true
    school?: true
    degree?: true
    field_of_study?: true
    start_year?: true
    end_year?: true
    description?: true
    created_at?: true
  }

  export type EducationMaxAggregateInputType = {
    id?: true
    profile_id?: true
    school?: true
    degree?: true
    field_of_study?: true
    start_year?: true
    end_year?: true
    description?: true
    created_at?: true
  }

  export type EducationCountAggregateInputType = {
    id?: true
    profile_id?: true
    school?: true
    degree?: true
    field_of_study?: true
    start_year?: true
    end_year?: true
    description?: true
    raw_json?: true
    created_at?: true
    _all?: true
  }

  export type EducationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Education to aggregate.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Educations
    **/
    _count?: true | EducationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EducationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EducationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationMaxAggregateInputType
  }

  export type GetEducationAggregateType<T extends EducationAggregateArgs> = {
        [P in keyof T & keyof AggregateEducation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducation[P]>
      : GetScalarType<T[P], AggregateEducation[P]>
  }




  export type EducationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationWhereInput
    orderBy?: EducationOrderByWithAggregationInput | EducationOrderByWithAggregationInput[]
    by: EducationScalarFieldEnum[] | EducationScalarFieldEnum
    having?: EducationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationCountAggregateInputType | true
    _avg?: EducationAvgAggregateInputType
    _sum?: EducationSumAggregateInputType
    _min?: EducationMinAggregateInputType
    _max?: EducationMaxAggregateInputType
  }

  export type EducationGroupByOutputType = {
    id: string
    profile_id: string
    school: string | null
    degree: string | null
    field_of_study: string | null
    start_year: number | null
    end_year: number | null
    description: string | null
    raw_json: JsonValue | null
    created_at: Date
    _count: EducationCountAggregateOutputType | null
    _avg: EducationAvgAggregateOutputType | null
    _sum: EducationSumAggregateOutputType | null
    _min: EducationMinAggregateOutputType | null
    _max: EducationMaxAggregateOutputType | null
  }

  type GetEducationGroupByPayload<T extends EducationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationGroupByOutputType[P]>
            : GetScalarType<T[P], EducationGroupByOutputType[P]>
        }
      >
    >


  export type EducationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    school?: boolean
    degree?: boolean
    field_of_study?: boolean
    start_year?: boolean
    end_year?: boolean
    description?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>

  export type EducationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    school?: boolean
    degree?: boolean
    field_of_study?: boolean
    start_year?: boolean
    end_year?: boolean
    description?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>

  export type EducationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    school?: boolean
    degree?: boolean
    field_of_study?: boolean
    start_year?: boolean
    end_year?: boolean
    description?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>

  export type EducationSelectScalar = {
    id?: boolean
    profile_id?: boolean
    school?: boolean
    degree?: boolean
    field_of_study?: boolean
    start_year?: boolean
    end_year?: boolean
    description?: boolean
    raw_json?: boolean
    created_at?: boolean
  }

  export type EducationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profile_id" | "school" | "degree" | "field_of_study" | "start_year" | "end_year" | "description" | "raw_json" | "created_at", ExtArgs["result"]["education"]>
  export type EducationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type EducationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type EducationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $EducationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Education"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profile_id: string
      school: string | null
      degree: string | null
      field_of_study: string | null
      start_year: number | null
      end_year: number | null
      description: string | null
      raw_json: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["education"]>
    composites: {}
  }

  type EducationGetPayload<S extends boolean | null | undefined | EducationDefaultArgs> = $Result.GetResult<Prisma.$EducationPayload, S>

  type EducationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EducationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EducationCountAggregateInputType | true
    }

  export interface EducationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Education'], meta: { name: 'Education' } }
    /**
     * Find zero or one Education that matches the filter.
     * @param {EducationFindUniqueArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationFindUniqueArgs>(args: SelectSubset<T, EducationFindUniqueArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Education that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EducationFindUniqueOrThrowArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Education that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindFirstArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationFindFirstArgs>(args?: SelectSubset<T, EducationFindFirstArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Education that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindFirstOrThrowArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Educations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Educations
     * const educations = await prisma.education.findMany()
     * 
     * // Get first 10 Educations
     * const educations = await prisma.education.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const educationWithIdOnly = await prisma.education.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EducationFindManyArgs>(args?: SelectSubset<T, EducationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Education.
     * @param {EducationCreateArgs} args - Arguments to create a Education.
     * @example
     * // Create one Education
     * const Education = await prisma.education.create({
     *   data: {
     *     // ... data to create a Education
     *   }
     * })
     * 
     */
    create<T extends EducationCreateArgs>(args: SelectSubset<T, EducationCreateArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Educations.
     * @param {EducationCreateManyArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const education = await prisma.education.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationCreateManyArgs>(args?: SelectSubset<T, EducationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Educations and returns the data saved in the database.
     * @param {EducationCreateManyAndReturnArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const education = await prisma.education.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Educations and only return the `id`
     * const educationWithIdOnly = await prisma.education.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EducationCreateManyAndReturnArgs>(args?: SelectSubset<T, EducationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Education.
     * @param {EducationDeleteArgs} args - Arguments to delete one Education.
     * @example
     * // Delete one Education
     * const Education = await prisma.education.delete({
     *   where: {
     *     // ... filter to delete one Education
     *   }
     * })
     * 
     */
    delete<T extends EducationDeleteArgs>(args: SelectSubset<T, EducationDeleteArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Education.
     * @param {EducationUpdateArgs} args - Arguments to update one Education.
     * @example
     * // Update one Education
     * const education = await prisma.education.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationUpdateArgs>(args: SelectSubset<T, EducationUpdateArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Educations.
     * @param {EducationDeleteManyArgs} args - Arguments to filter Educations to delete.
     * @example
     * // Delete a few Educations
     * const { count } = await prisma.education.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationDeleteManyArgs>(args?: SelectSubset<T, EducationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Educations
     * const education = await prisma.education.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationUpdateManyArgs>(args: SelectSubset<T, EducationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations and returns the data updated in the database.
     * @param {EducationUpdateManyAndReturnArgs} args - Arguments to update many Educations.
     * @example
     * // Update many Educations
     * const education = await prisma.education.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Educations and only return the `id`
     * const educationWithIdOnly = await prisma.education.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EducationUpdateManyAndReturnArgs>(args: SelectSubset<T, EducationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Education.
     * @param {EducationUpsertArgs} args - Arguments to update or create a Education.
     * @example
     * // Update or create a Education
     * const education = await prisma.education.upsert({
     *   create: {
     *     // ... data to create a Education
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Education we want to update
     *   }
     * })
     */
    upsert<T extends EducationUpsertArgs>(args: SelectSubset<T, EducationUpsertArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationCountArgs} args - Arguments to filter Educations to count.
     * @example
     * // Count the number of Educations
     * const count = await prisma.education.count({
     *   where: {
     *     // ... the filter for the Educations we want to count
     *   }
     * })
    **/
    count<T extends EducationCountArgs>(
      args?: Subset<T, EducationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationAggregateArgs>(args: Subset<T, EducationAggregateArgs>): Prisma.PrismaPromise<GetEducationAggregateType<T>>

    /**
     * Group by Education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationGroupByArgs['orderBy'] }
        : { orderBy?: EducationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Education model
   */
  readonly fields: EducationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Education.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Education model
   */
  interface EducationFieldRefs {
    readonly id: FieldRef<"Education", 'String'>
    readonly profile_id: FieldRef<"Education", 'String'>
    readonly school: FieldRef<"Education", 'String'>
    readonly degree: FieldRef<"Education", 'String'>
    readonly field_of_study: FieldRef<"Education", 'String'>
    readonly start_year: FieldRef<"Education", 'Int'>
    readonly end_year: FieldRef<"Education", 'Int'>
    readonly description: FieldRef<"Education", 'String'>
    readonly raw_json: FieldRef<"Education", 'Json'>
    readonly created_at: FieldRef<"Education", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Education findUnique
   */
  export type EducationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education findUniqueOrThrow
   */
  export type EducationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education findFirst
   */
  export type EducationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Educations.
     */
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education findFirstOrThrow
   */
  export type EducationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Educations.
     */
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education findMany
   */
  export type EducationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Educations to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education create
   */
  export type EducationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The data needed to create a Education.
     */
    data: XOR<EducationCreateInput, EducationUncheckedCreateInput>
  }

  /**
   * Education createMany
   */
  export type EducationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Educations.
     */
    data: EducationCreateManyInput | EducationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Education createManyAndReturn
   */
  export type EducationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * The data used to create many Educations.
     */
    data: EducationCreateManyInput | EducationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Education update
   */
  export type EducationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The data needed to update a Education.
     */
    data: XOR<EducationUpdateInput, EducationUncheckedUpdateInput>
    /**
     * Choose, which Education to update.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education updateMany
   */
  export type EducationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Educations.
     */
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyInput>
    /**
     * Filter which Educations to update
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to update.
     */
    limit?: number
  }

  /**
   * Education updateManyAndReturn
   */
  export type EducationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * The data used to update Educations.
     */
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyInput>
    /**
     * Filter which Educations to update
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Education upsert
   */
  export type EducationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The filter to search for the Education to update in case it exists.
     */
    where: EducationWhereUniqueInput
    /**
     * In case the Education found by the `where` argument doesn't exist, create a new Education with this data.
     */
    create: XOR<EducationCreateInput, EducationUncheckedCreateInput>
    /**
     * In case the Education was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationUpdateInput, EducationUncheckedUpdateInput>
  }

  /**
   * Education delete
   */
  export type EducationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter which Education to delete.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education deleteMany
   */
  export type EducationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Educations to delete
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to delete.
     */
    limit?: number
  }

  /**
   * Education without action
   */
  export type EducationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillAvgAggregateOutputType = {
    confidence: number | null
  }

  export type SkillSumAggregateOutputType = {
    confidence: number | null
  }

  export type SkillMinAggregateOutputType = {
    id: string | null
    profile_id: string | null
    skill: string | null
    confidence: number | null
    created_at: Date | null
  }

  export type SkillMaxAggregateOutputType = {
    id: string | null
    profile_id: string | null
    skill: string | null
    confidence: number | null
    created_at: Date | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    profile_id: number
    skill: number
    confidence: number
    raw_json: number
    created_at: number
    _all: number
  }


  export type SkillAvgAggregateInputType = {
    confidence?: true
  }

  export type SkillSumAggregateInputType = {
    confidence?: true
  }

  export type SkillMinAggregateInputType = {
    id?: true
    profile_id?: true
    skill?: true
    confidence?: true
    created_at?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    profile_id?: true
    skill?: true
    confidence?: true
    created_at?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    profile_id?: true
    skill?: true
    confidence?: true
    raw_json?: true
    created_at?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _avg?: SkillAvgAggregateInputType
    _sum?: SkillSumAggregateInputType
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: string
    profile_id: string
    skill: string | null
    confidence: number | null
    raw_json: JsonValue | null
    created_at: Date
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    skill?: boolean
    confidence?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    storySkills?: boolean | Skill$storySkillsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    skill?: boolean
    confidence?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    skill?: boolean
    confidence?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    profile_id?: boolean
    skill?: boolean
    confidence?: boolean
    raw_json?: boolean
    created_at?: boolean
  }

  export type SkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profile_id" | "skill" | "confidence" | "raw_json" | "created_at", ExtArgs["result"]["skill"]>
  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    storySkills?: boolean | Skill$storySkillsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type SkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      storySkills: Prisma.$StorySkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profile_id: string
      skill: string | null
      confidence: number | null
      raw_json: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills and returns the data updated in the database.
     * @param {SkillUpdateManyAndReturnArgs} args - Arguments to update many Skills.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkillUpdateManyAndReturnArgs>(args: SelectSubset<T, SkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    storySkills<T extends Skill$storySkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$storySkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorySkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'String'>
    readonly profile_id: FieldRef<"Skill", 'String'>
    readonly skill: FieldRef<"Skill", 'String'>
    readonly confidence: FieldRef<"Skill", 'Float'>
    readonly raw_json: FieldRef<"Skill", 'Json'>
    readonly created_at: FieldRef<"Skill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill createManyAndReturn
   */
  export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill updateManyAndReturn
   */
  export type SkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to delete.
     */
    limit?: number
  }

  /**
   * Skill.storySkills
   */
  export type Skill$storySkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorySkill
     */
    select?: StorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorySkill
     */
    omit?: StorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorySkillInclude<ExtArgs> | null
    where?: StorySkillWhereInput
    orderBy?: StorySkillOrderByWithRelationInput | StorySkillOrderByWithRelationInput[]
    cursor?: StorySkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorySkillScalarFieldEnum | StorySkillScalarFieldEnum[]
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model Certification
   */

  export type AggregateCertification = {
    _count: CertificationCountAggregateOutputType | null
    _min: CertificationMinAggregateOutputType | null
    _max: CertificationMaxAggregateOutputType | null
  }

  export type CertificationMinAggregateOutputType = {
    id: string | null
    profile_id: string | null
    name: string | null
    authority: string | null
    issued_date: Date | null
    expiry_date: Date | null
    created_at: Date | null
  }

  export type CertificationMaxAggregateOutputType = {
    id: string | null
    profile_id: string | null
    name: string | null
    authority: string | null
    issued_date: Date | null
    expiry_date: Date | null
    created_at: Date | null
  }

  export type CertificationCountAggregateOutputType = {
    id: number
    profile_id: number
    name: number
    authority: number
    issued_date: number
    expiry_date: number
    raw_json: number
    created_at: number
    _all: number
  }


  export type CertificationMinAggregateInputType = {
    id?: true
    profile_id?: true
    name?: true
    authority?: true
    issued_date?: true
    expiry_date?: true
    created_at?: true
  }

  export type CertificationMaxAggregateInputType = {
    id?: true
    profile_id?: true
    name?: true
    authority?: true
    issued_date?: true
    expiry_date?: true
    created_at?: true
  }

  export type CertificationCountAggregateInputType = {
    id?: true
    profile_id?: true
    name?: true
    authority?: true
    issued_date?: true
    expiry_date?: true
    raw_json?: true
    created_at?: true
    _all?: true
  }

  export type CertificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certification to aggregate.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certifications
    **/
    _count?: true | CertificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificationMaxAggregateInputType
  }

  export type GetCertificationAggregateType<T extends CertificationAggregateArgs> = {
        [P in keyof T & keyof AggregateCertification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertification[P]>
      : GetScalarType<T[P], AggregateCertification[P]>
  }




  export type CertificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithAggregationInput | CertificationOrderByWithAggregationInput[]
    by: CertificationScalarFieldEnum[] | CertificationScalarFieldEnum
    having?: CertificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificationCountAggregateInputType | true
    _min?: CertificationMinAggregateInputType
    _max?: CertificationMaxAggregateInputType
  }

  export type CertificationGroupByOutputType = {
    id: string
    profile_id: string
    name: string | null
    authority: string | null
    issued_date: Date | null
    expiry_date: Date | null
    raw_json: JsonValue | null
    created_at: Date
    _count: CertificationCountAggregateOutputType | null
    _min: CertificationMinAggregateOutputType | null
    _max: CertificationMaxAggregateOutputType | null
  }

  type GetCertificationGroupByPayload<T extends CertificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificationGroupByOutputType[P]>
            : GetScalarType<T[P], CertificationGroupByOutputType[P]>
        }
      >
    >


  export type CertificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certification"]>

  export type CertificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certification"]>

  export type CertificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certification"]>

  export type CertificationSelectScalar = {
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
  }

  export type CertificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profile_id" | "name" | "authority" | "issued_date" | "expiry_date" | "raw_json" | "created_at", ExtArgs["result"]["certification"]>
  export type CertificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type CertificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type CertificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $CertificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certification"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profile_id: string
      name: string | null
      authority: string | null
      issued_date: Date | null
      expiry_date: Date | null
      raw_json: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["certification"]>
    composites: {}
  }

  type CertificationGetPayload<S extends boolean | null | undefined | CertificationDefaultArgs> = $Result.GetResult<Prisma.$CertificationPayload, S>

  type CertificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CertificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificationCountAggregateInputType | true
    }

  export interface CertificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certification'], meta: { name: 'Certification' } }
    /**
     * Find zero or one Certification that matches the filter.
     * @param {CertificationFindUniqueArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificationFindUniqueArgs>(args: SelectSubset<T, CertificationFindUniqueArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Certification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificationFindUniqueOrThrowArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificationFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindFirstArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificationFindFirstArgs>(args?: SelectSubset<T, CertificationFindFirstArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindFirstOrThrowArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificationFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Certifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certifications
     * const certifications = await prisma.certification.findMany()
     * 
     * // Get first 10 Certifications
     * const certifications = await prisma.certification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificationWithIdOnly = await prisma.certification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificationFindManyArgs>(args?: SelectSubset<T, CertificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Certification.
     * @param {CertificationCreateArgs} args - Arguments to create a Certification.
     * @example
     * // Create one Certification
     * const Certification = await prisma.certification.create({
     *   data: {
     *     // ... data to create a Certification
     *   }
     * })
     * 
     */
    create<T extends CertificationCreateArgs>(args: SelectSubset<T, CertificationCreateArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Certifications.
     * @param {CertificationCreateManyArgs} args - Arguments to create many Certifications.
     * @example
     * // Create many Certifications
     * const certification = await prisma.certification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificationCreateManyArgs>(args?: SelectSubset<T, CertificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certifications and returns the data saved in the database.
     * @param {CertificationCreateManyAndReturnArgs} args - Arguments to create many Certifications.
     * @example
     * // Create many Certifications
     * const certification = await prisma.certification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certifications and only return the `id`
     * const certificationWithIdOnly = await prisma.certification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificationCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Certification.
     * @param {CertificationDeleteArgs} args - Arguments to delete one Certification.
     * @example
     * // Delete one Certification
     * const Certification = await prisma.certification.delete({
     *   where: {
     *     // ... filter to delete one Certification
     *   }
     * })
     * 
     */
    delete<T extends CertificationDeleteArgs>(args: SelectSubset<T, CertificationDeleteArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Certification.
     * @param {CertificationUpdateArgs} args - Arguments to update one Certification.
     * @example
     * // Update one Certification
     * const certification = await prisma.certification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificationUpdateArgs>(args: SelectSubset<T, CertificationUpdateArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Certifications.
     * @param {CertificationDeleteManyArgs} args - Arguments to filter Certifications to delete.
     * @example
     * // Delete a few Certifications
     * const { count } = await prisma.certification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificationDeleteManyArgs>(args?: SelectSubset<T, CertificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certifications
     * const certification = await prisma.certification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificationUpdateManyArgs>(args: SelectSubset<T, CertificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certifications and returns the data updated in the database.
     * @param {CertificationUpdateManyAndReturnArgs} args - Arguments to update many Certifications.
     * @example
     * // Update many Certifications
     * const certification = await prisma.certification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Certifications and only return the `id`
     * const certificationWithIdOnly = await prisma.certification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CertificationUpdateManyAndReturnArgs>(args: SelectSubset<T, CertificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Certification.
     * @param {CertificationUpsertArgs} args - Arguments to update or create a Certification.
     * @example
     * // Update or create a Certification
     * const certification = await prisma.certification.upsert({
     *   create: {
     *     // ... data to create a Certification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certification we want to update
     *   }
     * })
     */
    upsert<T extends CertificationUpsertArgs>(args: SelectSubset<T, CertificationUpsertArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationCountArgs} args - Arguments to filter Certifications to count.
     * @example
     * // Count the number of Certifications
     * const count = await prisma.certification.count({
     *   where: {
     *     // ... the filter for the Certifications we want to count
     *   }
     * })
    **/
    count<T extends CertificationCountArgs>(
      args?: Subset<T, CertificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificationAggregateArgs>(args: Subset<T, CertificationAggregateArgs>): Prisma.PrismaPromise<GetCertificationAggregateType<T>>

    /**
     * Group by Certification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificationGroupByArgs['orderBy'] }
        : { orderBy?: CertificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certification model
   */
  readonly fields: CertificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certification model
   */
  interface CertificationFieldRefs {
    readonly id: FieldRef<"Certification", 'String'>
    readonly profile_id: FieldRef<"Certification", 'String'>
    readonly name: FieldRef<"Certification", 'String'>
    readonly authority: FieldRef<"Certification", 'String'>
    readonly issued_date: FieldRef<"Certification", 'DateTime'>
    readonly expiry_date: FieldRef<"Certification", 'DateTime'>
    readonly raw_json: FieldRef<"Certification", 'Json'>
    readonly created_at: FieldRef<"Certification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certification findUnique
   */
  export type CertificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification findUniqueOrThrow
   */
  export type CertificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification findFirst
   */
  export type CertificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification findFirstOrThrow
   */
  export type CertificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification findMany
   */
  export type CertificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certifications to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification create
   */
  export type CertificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Certification.
     */
    data: XOR<CertificationCreateInput, CertificationUncheckedCreateInput>
  }

  /**
   * Certification createMany
   */
  export type CertificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certifications.
     */
    data: CertificationCreateManyInput | CertificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certification createManyAndReturn
   */
  export type CertificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * The data used to create many Certifications.
     */
    data: CertificationCreateManyInput | CertificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certification update
   */
  export type CertificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Certification.
     */
    data: XOR<CertificationUpdateInput, CertificationUncheckedUpdateInput>
    /**
     * Choose, which Certification to update.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification updateMany
   */
  export type CertificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certifications.
     */
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyInput>
    /**
     * Filter which Certifications to update
     */
    where?: CertificationWhereInput
    /**
     * Limit how many Certifications to update.
     */
    limit?: number
  }

  /**
   * Certification updateManyAndReturn
   */
  export type CertificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * The data used to update Certifications.
     */
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyInput>
    /**
     * Filter which Certifications to update
     */
    where?: CertificationWhereInput
    /**
     * Limit how many Certifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certification upsert
   */
  export type CertificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Certification to update in case it exists.
     */
    where: CertificationWhereUniqueInput
    /**
     * In case the Certification found by the `where` argument doesn't exist, create a new Certification with this data.
     */
    create: XOR<CertificationCreateInput, CertificationUncheckedCreateInput>
    /**
     * In case the Certification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificationUpdateInput, CertificationUncheckedUpdateInput>
  }

  /**
   * Certification delete
   */
  export type CertificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter which Certification to delete.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification deleteMany
   */
  export type CertificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certifications to delete
     */
    where?: CertificationWhereInput
    /**
     * Limit how many Certifications to delete.
     */
    limit?: number
  }

  /**
   * Certification without action
   */
  export type CertificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certification
     */
    omit?: CertificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
  }


  /**
   * Model ParsingJob
   */

  export type AggregateParsingJob = {
    _count: ParsingJobCountAggregateOutputType | null
    _avg: ParsingJobAvgAggregateOutputType | null
    _sum: ParsingJobSumAggregateOutputType | null
    _min: ParsingJobMinAggregateOutputType | null
    _max: ParsingJobMaxAggregateOutputType | null
  }

  export type ParsingJobAvgAggregateOutputType = {
    attempts: number | null
  }

  export type ParsingJobSumAggregateOutputType = {
    attempts: number | null
  }

  export type ParsingJobMinAggregateOutputType = {
    id: string | null
    parsed_document_id: string | null
    status: string | null
    attempts: number | null
    worker: string | null
    started_at: Date | null
    finished_at: Date | null
    created_at: Date | null
  }

  export type ParsingJobMaxAggregateOutputType = {
    id: string | null
    parsed_document_id: string | null
    status: string | null
    attempts: number | null
    worker: string | null
    started_at: Date | null
    finished_at: Date | null
    created_at: Date | null
  }

  export type ParsingJobCountAggregateOutputType = {
    id: number
    parsed_document_id: number
    status: number
    attempts: number
    worker: number
    started_at: number
    finished_at: number
    created_at: number
    _all: number
  }


  export type ParsingJobAvgAggregateInputType = {
    attempts?: true
  }

  export type ParsingJobSumAggregateInputType = {
    attempts?: true
  }

  export type ParsingJobMinAggregateInputType = {
    id?: true
    parsed_document_id?: true
    status?: true
    attempts?: true
    worker?: true
    started_at?: true
    finished_at?: true
    created_at?: true
  }

  export type ParsingJobMaxAggregateInputType = {
    id?: true
    parsed_document_id?: true
    status?: true
    attempts?: true
    worker?: true
    started_at?: true
    finished_at?: true
    created_at?: true
  }

  export type ParsingJobCountAggregateInputType = {
    id?: true
    parsed_document_id?: true
    status?: true
    attempts?: true
    worker?: true
    started_at?: true
    finished_at?: true
    created_at?: true
    _all?: true
  }

  export type ParsingJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsingJob to aggregate.
     */
    where?: ParsingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsingJobs to fetch.
     */
    orderBy?: ParsingJobOrderByWithRelationInput | ParsingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParsingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParsingJobs
    **/
    _count?: true | ParsingJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParsingJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParsingJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParsingJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParsingJobMaxAggregateInputType
  }

  export type GetParsingJobAggregateType<T extends ParsingJobAggregateArgs> = {
        [P in keyof T & keyof AggregateParsingJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParsingJob[P]>
      : GetScalarType<T[P], AggregateParsingJob[P]>
  }




  export type ParsingJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsingJobWhereInput
    orderBy?: ParsingJobOrderByWithAggregationInput | ParsingJobOrderByWithAggregationInput[]
    by: ParsingJobScalarFieldEnum[] | ParsingJobScalarFieldEnum
    having?: ParsingJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParsingJobCountAggregateInputType | true
    _avg?: ParsingJobAvgAggregateInputType
    _sum?: ParsingJobSumAggregateInputType
    _min?: ParsingJobMinAggregateInputType
    _max?: ParsingJobMaxAggregateInputType
  }

  export type ParsingJobGroupByOutputType = {
    id: string
    parsed_document_id: string
    status: string | null
    attempts: number | null
    worker: string | null
    started_at: Date | null
    finished_at: Date | null
    created_at: Date
    _count: ParsingJobCountAggregateOutputType | null
    _avg: ParsingJobAvgAggregateOutputType | null
    _sum: ParsingJobSumAggregateOutputType | null
    _min: ParsingJobMinAggregateOutputType | null
    _max: ParsingJobMaxAggregateOutputType | null
  }

  type GetParsingJobGroupByPayload<T extends ParsingJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParsingJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParsingJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParsingJobGroupByOutputType[P]>
            : GetScalarType<T[P], ParsingJobGroupByOutputType[P]>
        }
      >
    >


  export type ParsingJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parsed_document_id?: boolean
    status?: boolean
    attempts?: boolean
    worker?: boolean
    started_at?: boolean
    finished_at?: boolean
    created_at?: boolean
    parsed_document?: boolean | ParsedDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsingJob"]>

  export type ParsingJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parsed_document_id?: boolean
    status?: boolean
    attempts?: boolean
    worker?: boolean
    started_at?: boolean
    finished_at?: boolean
    created_at?: boolean
    parsed_document?: boolean | ParsedDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsingJob"]>

  export type ParsingJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parsed_document_id?: boolean
    status?: boolean
    attempts?: boolean
    worker?: boolean
    started_at?: boolean
    finished_at?: boolean
    created_at?: boolean
    parsed_document?: boolean | ParsedDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsingJob"]>

  export type ParsingJobSelectScalar = {
    id?: boolean
    parsed_document_id?: boolean
    status?: boolean
    attempts?: boolean
    worker?: boolean
    started_at?: boolean
    finished_at?: boolean
    created_at?: boolean
  }

  export type ParsingJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "parsed_document_id" | "status" | "attempts" | "worker" | "started_at" | "finished_at" | "created_at", ExtArgs["result"]["parsingJob"]>
  export type ParsingJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parsed_document?: boolean | ParsedDocumentDefaultArgs<ExtArgs>
  }
  export type ParsingJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parsed_document?: boolean | ParsedDocumentDefaultArgs<ExtArgs>
  }
  export type ParsingJobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parsed_document?: boolean | ParsedDocumentDefaultArgs<ExtArgs>
  }

  export type $ParsingJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParsingJob"
    objects: {
      parsed_document: Prisma.$ParsedDocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      parsed_document_id: string
      status: string | null
      attempts: number | null
      worker: string | null
      started_at: Date | null
      finished_at: Date | null
      created_at: Date
    }, ExtArgs["result"]["parsingJob"]>
    composites: {}
  }

  type ParsingJobGetPayload<S extends boolean | null | undefined | ParsingJobDefaultArgs> = $Result.GetResult<Prisma.$ParsingJobPayload, S>

  type ParsingJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParsingJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParsingJobCountAggregateInputType | true
    }

  export interface ParsingJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParsingJob'], meta: { name: 'ParsingJob' } }
    /**
     * Find zero or one ParsingJob that matches the filter.
     * @param {ParsingJobFindUniqueArgs} args - Arguments to find a ParsingJob
     * @example
     * // Get one ParsingJob
     * const parsingJob = await prisma.parsingJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParsingJobFindUniqueArgs>(args: SelectSubset<T, ParsingJobFindUniqueArgs<ExtArgs>>): Prisma__ParsingJobClient<$Result.GetResult<Prisma.$ParsingJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParsingJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParsingJobFindUniqueOrThrowArgs} args - Arguments to find a ParsingJob
     * @example
     * // Get one ParsingJob
     * const parsingJob = await prisma.parsingJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParsingJobFindUniqueOrThrowArgs>(args: SelectSubset<T, ParsingJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParsingJobClient<$Result.GetResult<Prisma.$ParsingJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsingJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsingJobFindFirstArgs} args - Arguments to find a ParsingJob
     * @example
     * // Get one ParsingJob
     * const parsingJob = await prisma.parsingJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParsingJobFindFirstArgs>(args?: SelectSubset<T, ParsingJobFindFirstArgs<ExtArgs>>): Prisma__ParsingJobClient<$Result.GetResult<Prisma.$ParsingJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsingJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsingJobFindFirstOrThrowArgs} args - Arguments to find a ParsingJob
     * @example
     * // Get one ParsingJob
     * const parsingJob = await prisma.parsingJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParsingJobFindFirstOrThrowArgs>(args?: SelectSubset<T, ParsingJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParsingJobClient<$Result.GetResult<Prisma.$ParsingJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParsingJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsingJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParsingJobs
     * const parsingJobs = await prisma.parsingJob.findMany()
     * 
     * // Get first 10 ParsingJobs
     * const parsingJobs = await prisma.parsingJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parsingJobWithIdOnly = await prisma.parsingJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParsingJobFindManyArgs>(args?: SelectSubset<T, ParsingJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsingJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParsingJob.
     * @param {ParsingJobCreateArgs} args - Arguments to create a ParsingJob.
     * @example
     * // Create one ParsingJob
     * const ParsingJob = await prisma.parsingJob.create({
     *   data: {
     *     // ... data to create a ParsingJob
     *   }
     * })
     * 
     */
    create<T extends ParsingJobCreateArgs>(args: SelectSubset<T, ParsingJobCreateArgs<ExtArgs>>): Prisma__ParsingJobClient<$Result.GetResult<Prisma.$ParsingJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParsingJobs.
     * @param {ParsingJobCreateManyArgs} args - Arguments to create many ParsingJobs.
     * @example
     * // Create many ParsingJobs
     * const parsingJob = await prisma.parsingJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParsingJobCreateManyArgs>(args?: SelectSubset<T, ParsingJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParsingJobs and returns the data saved in the database.
     * @param {ParsingJobCreateManyAndReturnArgs} args - Arguments to create many ParsingJobs.
     * @example
     * // Create many ParsingJobs
     * const parsingJob = await prisma.parsingJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParsingJobs and only return the `id`
     * const parsingJobWithIdOnly = await prisma.parsingJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParsingJobCreateManyAndReturnArgs>(args?: SelectSubset<T, ParsingJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsingJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParsingJob.
     * @param {ParsingJobDeleteArgs} args - Arguments to delete one ParsingJob.
     * @example
     * // Delete one ParsingJob
     * const ParsingJob = await prisma.parsingJob.delete({
     *   where: {
     *     // ... filter to delete one ParsingJob
     *   }
     * })
     * 
     */
    delete<T extends ParsingJobDeleteArgs>(args: SelectSubset<T, ParsingJobDeleteArgs<ExtArgs>>): Prisma__ParsingJobClient<$Result.GetResult<Prisma.$ParsingJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParsingJob.
     * @param {ParsingJobUpdateArgs} args - Arguments to update one ParsingJob.
     * @example
     * // Update one ParsingJob
     * const parsingJob = await prisma.parsingJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParsingJobUpdateArgs>(args: SelectSubset<T, ParsingJobUpdateArgs<ExtArgs>>): Prisma__ParsingJobClient<$Result.GetResult<Prisma.$ParsingJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParsingJobs.
     * @param {ParsingJobDeleteManyArgs} args - Arguments to filter ParsingJobs to delete.
     * @example
     * // Delete a few ParsingJobs
     * const { count } = await prisma.parsingJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParsingJobDeleteManyArgs>(args?: SelectSubset<T, ParsingJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsingJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsingJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParsingJobs
     * const parsingJob = await prisma.parsingJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParsingJobUpdateManyArgs>(args: SelectSubset<T, ParsingJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsingJobs and returns the data updated in the database.
     * @param {ParsingJobUpdateManyAndReturnArgs} args - Arguments to update many ParsingJobs.
     * @example
     * // Update many ParsingJobs
     * const parsingJob = await prisma.parsingJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParsingJobs and only return the `id`
     * const parsingJobWithIdOnly = await prisma.parsingJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParsingJobUpdateManyAndReturnArgs>(args: SelectSubset<T, ParsingJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsingJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParsingJob.
     * @param {ParsingJobUpsertArgs} args - Arguments to update or create a ParsingJob.
     * @example
     * // Update or create a ParsingJob
     * const parsingJob = await prisma.parsingJob.upsert({
     *   create: {
     *     // ... data to create a ParsingJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParsingJob we want to update
     *   }
     * })
     */
    upsert<T extends ParsingJobUpsertArgs>(args: SelectSubset<T, ParsingJobUpsertArgs<ExtArgs>>): Prisma__ParsingJobClient<$Result.GetResult<Prisma.$ParsingJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParsingJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsingJobCountArgs} args - Arguments to filter ParsingJobs to count.
     * @example
     * // Count the number of ParsingJobs
     * const count = await prisma.parsingJob.count({
     *   where: {
     *     // ... the filter for the ParsingJobs we want to count
     *   }
     * })
    **/
    count<T extends ParsingJobCountArgs>(
      args?: Subset<T, ParsingJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParsingJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParsingJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsingJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParsingJobAggregateArgs>(args: Subset<T, ParsingJobAggregateArgs>): Prisma.PrismaPromise<GetParsingJobAggregateType<T>>

    /**
     * Group by ParsingJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsingJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParsingJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParsingJobGroupByArgs['orderBy'] }
        : { orderBy?: ParsingJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParsingJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParsingJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParsingJob model
   */
  readonly fields: ParsingJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParsingJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParsingJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parsed_document<T extends ParsedDocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParsedDocumentDefaultArgs<ExtArgs>>): Prisma__ParsedDocumentClient<$Result.GetResult<Prisma.$ParsedDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParsingJob model
   */
  interface ParsingJobFieldRefs {
    readonly id: FieldRef<"ParsingJob", 'String'>
    readonly parsed_document_id: FieldRef<"ParsingJob", 'String'>
    readonly status: FieldRef<"ParsingJob", 'String'>
    readonly attempts: FieldRef<"ParsingJob", 'Int'>
    readonly worker: FieldRef<"ParsingJob", 'String'>
    readonly started_at: FieldRef<"ParsingJob", 'DateTime'>
    readonly finished_at: FieldRef<"ParsingJob", 'DateTime'>
    readonly created_at: FieldRef<"ParsingJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParsingJob findUnique
   */
  export type ParsingJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsingJob
     */
    select?: ParsingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsingJob
     */
    omit?: ParsingJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsingJobInclude<ExtArgs> | null
    /**
     * Filter, which ParsingJob to fetch.
     */
    where: ParsingJobWhereUniqueInput
  }

  /**
   * ParsingJob findUniqueOrThrow
   */
  export type ParsingJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsingJob
     */
    select?: ParsingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsingJob
     */
    omit?: ParsingJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsingJobInclude<ExtArgs> | null
    /**
     * Filter, which ParsingJob to fetch.
     */
    where: ParsingJobWhereUniqueInput
  }

  /**
   * ParsingJob findFirst
   */
  export type ParsingJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsingJob
     */
    select?: ParsingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsingJob
     */
    omit?: ParsingJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsingJobInclude<ExtArgs> | null
    /**
     * Filter, which ParsingJob to fetch.
     */
    where?: ParsingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsingJobs to fetch.
     */
    orderBy?: ParsingJobOrderByWithRelationInput | ParsingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsingJobs.
     */
    cursor?: ParsingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsingJobs.
     */
    distinct?: ParsingJobScalarFieldEnum | ParsingJobScalarFieldEnum[]
  }

  /**
   * ParsingJob findFirstOrThrow
   */
  export type ParsingJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsingJob
     */
    select?: ParsingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsingJob
     */
    omit?: ParsingJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsingJobInclude<ExtArgs> | null
    /**
     * Filter, which ParsingJob to fetch.
     */
    where?: ParsingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsingJobs to fetch.
     */
    orderBy?: ParsingJobOrderByWithRelationInput | ParsingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsingJobs.
     */
    cursor?: ParsingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsingJobs.
     */
    distinct?: ParsingJobScalarFieldEnum | ParsingJobScalarFieldEnum[]
  }

  /**
   * ParsingJob findMany
   */
  export type ParsingJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsingJob
     */
    select?: ParsingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsingJob
     */
    omit?: ParsingJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsingJobInclude<ExtArgs> | null
    /**
     * Filter, which ParsingJobs to fetch.
     */
    where?: ParsingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsingJobs to fetch.
     */
    orderBy?: ParsingJobOrderByWithRelationInput | ParsingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParsingJobs.
     */
    cursor?: ParsingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsingJobs.
     */
    skip?: number
    distinct?: ParsingJobScalarFieldEnum | ParsingJobScalarFieldEnum[]
  }

  /**
   * ParsingJob create
   */
  export type ParsingJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsingJob
     */
    select?: ParsingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsingJob
     */
    omit?: ParsingJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsingJobInclude<ExtArgs> | null
    /**
     * The data needed to create a ParsingJob.
     */
    data: XOR<ParsingJobCreateInput, ParsingJobUncheckedCreateInput>
  }

  /**
   * ParsingJob createMany
   */
  export type ParsingJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParsingJobs.
     */
    data: ParsingJobCreateManyInput | ParsingJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParsingJob createManyAndReturn
   */
  export type ParsingJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsingJob
     */
    select?: ParsingJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsingJob
     */
    omit?: ParsingJobOmit<ExtArgs> | null
    /**
     * The data used to create many ParsingJobs.
     */
    data: ParsingJobCreateManyInput | ParsingJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsingJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsingJob update
   */
  export type ParsingJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsingJob
     */
    select?: ParsingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsingJob
     */
    omit?: ParsingJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsingJobInclude<ExtArgs> | null
    /**
     * The data needed to update a ParsingJob.
     */
    data: XOR<ParsingJobUpdateInput, ParsingJobUncheckedUpdateInput>
    /**
     * Choose, which ParsingJob to update.
     */
    where: ParsingJobWhereUniqueInput
  }

  /**
   * ParsingJob updateMany
   */
  export type ParsingJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParsingJobs.
     */
    data: XOR<ParsingJobUpdateManyMutationInput, ParsingJobUncheckedUpdateManyInput>
    /**
     * Filter which ParsingJobs to update
     */
    where?: ParsingJobWhereInput
    /**
     * Limit how many ParsingJobs to update.
     */
    limit?: number
  }

  /**
   * ParsingJob updateManyAndReturn
   */
  export type ParsingJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsingJob
     */
    select?: ParsingJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsingJob
     */
    omit?: ParsingJobOmit<ExtArgs> | null
    /**
     * The data used to update ParsingJobs.
     */
    data: XOR<ParsingJobUpdateManyMutationInput, ParsingJobUncheckedUpdateManyInput>
    /**
     * Filter which ParsingJobs to update
     */
    where?: ParsingJobWhereInput
    /**
     * Limit how many ParsingJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsingJobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsingJob upsert
   */
  export type ParsingJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsingJob
     */
    select?: ParsingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsingJob
     */
    omit?: ParsingJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsingJobInclude<ExtArgs> | null
    /**
     * The filter to search for the ParsingJob to update in case it exists.
     */
    where: ParsingJobWhereUniqueInput
    /**
     * In case the ParsingJob found by the `where` argument doesn't exist, create a new ParsingJob with this data.
     */
    create: XOR<ParsingJobCreateInput, ParsingJobUncheckedCreateInput>
    /**
     * In case the ParsingJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParsingJobUpdateInput, ParsingJobUncheckedUpdateInput>
  }

  /**
   * ParsingJob delete
   */
  export type ParsingJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsingJob
     */
    select?: ParsingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsingJob
     */
    omit?: ParsingJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsingJobInclude<ExtArgs> | null
    /**
     * Filter which ParsingJob to delete.
     */
    where: ParsingJobWhereUniqueInput
  }

  /**
   * ParsingJob deleteMany
   */
  export type ParsingJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsingJobs to delete
     */
    where?: ParsingJobWhereInput
    /**
     * Limit how many ParsingJobs to delete.
     */
    limit?: number
  }

  /**
   * ParsingJob without action
   */
  export type ParsingJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsingJob
     */
    select?: ParsingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsingJob
     */
    omit?: ParsingJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsingJobInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    profile_id: string | null
    name: string | null
    authority: string | null
    issued_date: Date | null
    expiry_date: Date | null
    created_at: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    profile_id: string | null
    name: string | null
    authority: string | null
    issued_date: Date | null
    expiry_date: Date | null
    created_at: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    profile_id: number
    name: number
    authority: number
    issued_date: number
    expiry_date: number
    raw_json: number
    created_at: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    profile_id?: true
    name?: true
    authority?: true
    issued_date?: true
    expiry_date?: true
    created_at?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    profile_id?: true
    name?: true
    authority?: true
    issued_date?: true
    expiry_date?: true
    created_at?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    profile_id?: true
    name?: true
    authority?: true
    issued_date?: true
    expiry_date?: true
    raw_json?: true
    created_at?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    profile_id: string
    name: string | null
    authority: string | null
    issued_date: Date | null
    expiry_date: Date | null
    raw_json: JsonValue | null
    created_at: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profile_id" | "name" | "authority" | "issued_date" | "expiry_date" | "raw_json" | "created_at", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profile_id: string
      name: string | null
      authority: string | null
      issued_date: Date | null
      expiry_date: Date | null
      raw_json: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly profile_id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly authority: FieldRef<"Project", 'String'>
    readonly issued_date: FieldRef<"Project", 'DateTime'>
    readonly expiry_date: FieldRef<"Project", 'DateTime'>
    readonly raw_json: FieldRef<"Project", 'Json'>
    readonly created_at: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Volunteering
   */

  export type AggregateVolunteering = {
    _count: VolunteeringCountAggregateOutputType | null
    _min: VolunteeringMinAggregateOutputType | null
    _max: VolunteeringMaxAggregateOutputType | null
  }

  export type VolunteeringMinAggregateOutputType = {
    id: string | null
    profile_id: string | null
    name: string | null
    authority: string | null
    issued_date: Date | null
    expiry_date: Date | null
    created_at: Date | null
  }

  export type VolunteeringMaxAggregateOutputType = {
    id: string | null
    profile_id: string | null
    name: string | null
    authority: string | null
    issued_date: Date | null
    expiry_date: Date | null
    created_at: Date | null
  }

  export type VolunteeringCountAggregateOutputType = {
    id: number
    profile_id: number
    name: number
    authority: number
    issued_date: number
    expiry_date: number
    raw_json: number
    created_at: number
    _all: number
  }


  export type VolunteeringMinAggregateInputType = {
    id?: true
    profile_id?: true
    name?: true
    authority?: true
    issued_date?: true
    expiry_date?: true
    created_at?: true
  }

  export type VolunteeringMaxAggregateInputType = {
    id?: true
    profile_id?: true
    name?: true
    authority?: true
    issued_date?: true
    expiry_date?: true
    created_at?: true
  }

  export type VolunteeringCountAggregateInputType = {
    id?: true
    profile_id?: true
    name?: true
    authority?: true
    issued_date?: true
    expiry_date?: true
    raw_json?: true
    created_at?: true
    _all?: true
  }

  export type VolunteeringAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Volunteering to aggregate.
     */
    where?: VolunteeringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volunteerings to fetch.
     */
    orderBy?: VolunteeringOrderByWithRelationInput | VolunteeringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VolunteeringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volunteerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volunteerings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Volunteerings
    **/
    _count?: true | VolunteeringCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VolunteeringMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VolunteeringMaxAggregateInputType
  }

  export type GetVolunteeringAggregateType<T extends VolunteeringAggregateArgs> = {
        [P in keyof T & keyof AggregateVolunteering]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVolunteering[P]>
      : GetScalarType<T[P], AggregateVolunteering[P]>
  }




  export type VolunteeringGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolunteeringWhereInput
    orderBy?: VolunteeringOrderByWithAggregationInput | VolunteeringOrderByWithAggregationInput[]
    by: VolunteeringScalarFieldEnum[] | VolunteeringScalarFieldEnum
    having?: VolunteeringScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VolunteeringCountAggregateInputType | true
    _min?: VolunteeringMinAggregateInputType
    _max?: VolunteeringMaxAggregateInputType
  }

  export type VolunteeringGroupByOutputType = {
    id: string
    profile_id: string
    name: string | null
    authority: string | null
    issued_date: Date | null
    expiry_date: Date | null
    raw_json: JsonValue | null
    created_at: Date
    _count: VolunteeringCountAggregateOutputType | null
    _min: VolunteeringMinAggregateOutputType | null
    _max: VolunteeringMaxAggregateOutputType | null
  }

  type GetVolunteeringGroupByPayload<T extends VolunteeringGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VolunteeringGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VolunteeringGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VolunteeringGroupByOutputType[P]>
            : GetScalarType<T[P], VolunteeringGroupByOutputType[P]>
        }
      >
    >


  export type VolunteeringSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volunteering"]>

  export type VolunteeringSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volunteering"]>

  export type VolunteeringSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volunteering"]>

  export type VolunteeringSelectScalar = {
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
  }

  export type VolunteeringOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profile_id" | "name" | "authority" | "issued_date" | "expiry_date" | "raw_json" | "created_at", ExtArgs["result"]["volunteering"]>
  export type VolunteeringInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type VolunteeringIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type VolunteeringIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $VolunteeringPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Volunteering"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profile_id: string
      name: string | null
      authority: string | null
      issued_date: Date | null
      expiry_date: Date | null
      raw_json: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["volunteering"]>
    composites: {}
  }

  type VolunteeringGetPayload<S extends boolean | null | undefined | VolunteeringDefaultArgs> = $Result.GetResult<Prisma.$VolunteeringPayload, S>

  type VolunteeringCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VolunteeringFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VolunteeringCountAggregateInputType | true
    }

  export interface VolunteeringDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Volunteering'], meta: { name: 'Volunteering' } }
    /**
     * Find zero or one Volunteering that matches the filter.
     * @param {VolunteeringFindUniqueArgs} args - Arguments to find a Volunteering
     * @example
     * // Get one Volunteering
     * const volunteering = await prisma.volunteering.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VolunteeringFindUniqueArgs>(args: SelectSubset<T, VolunteeringFindUniqueArgs<ExtArgs>>): Prisma__VolunteeringClient<$Result.GetResult<Prisma.$VolunteeringPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Volunteering that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VolunteeringFindUniqueOrThrowArgs} args - Arguments to find a Volunteering
     * @example
     * // Get one Volunteering
     * const volunteering = await prisma.volunteering.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VolunteeringFindUniqueOrThrowArgs>(args: SelectSubset<T, VolunteeringFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VolunteeringClient<$Result.GetResult<Prisma.$VolunteeringPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Volunteering that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteeringFindFirstArgs} args - Arguments to find a Volunteering
     * @example
     * // Get one Volunteering
     * const volunteering = await prisma.volunteering.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VolunteeringFindFirstArgs>(args?: SelectSubset<T, VolunteeringFindFirstArgs<ExtArgs>>): Prisma__VolunteeringClient<$Result.GetResult<Prisma.$VolunteeringPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Volunteering that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteeringFindFirstOrThrowArgs} args - Arguments to find a Volunteering
     * @example
     * // Get one Volunteering
     * const volunteering = await prisma.volunteering.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VolunteeringFindFirstOrThrowArgs>(args?: SelectSubset<T, VolunteeringFindFirstOrThrowArgs<ExtArgs>>): Prisma__VolunteeringClient<$Result.GetResult<Prisma.$VolunteeringPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Volunteerings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteeringFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Volunteerings
     * const volunteerings = await prisma.volunteering.findMany()
     * 
     * // Get first 10 Volunteerings
     * const volunteerings = await prisma.volunteering.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const volunteeringWithIdOnly = await prisma.volunteering.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VolunteeringFindManyArgs>(args?: SelectSubset<T, VolunteeringFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteeringPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Volunteering.
     * @param {VolunteeringCreateArgs} args - Arguments to create a Volunteering.
     * @example
     * // Create one Volunteering
     * const Volunteering = await prisma.volunteering.create({
     *   data: {
     *     // ... data to create a Volunteering
     *   }
     * })
     * 
     */
    create<T extends VolunteeringCreateArgs>(args: SelectSubset<T, VolunteeringCreateArgs<ExtArgs>>): Prisma__VolunteeringClient<$Result.GetResult<Prisma.$VolunteeringPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Volunteerings.
     * @param {VolunteeringCreateManyArgs} args - Arguments to create many Volunteerings.
     * @example
     * // Create many Volunteerings
     * const volunteering = await prisma.volunteering.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VolunteeringCreateManyArgs>(args?: SelectSubset<T, VolunteeringCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Volunteerings and returns the data saved in the database.
     * @param {VolunteeringCreateManyAndReturnArgs} args - Arguments to create many Volunteerings.
     * @example
     * // Create many Volunteerings
     * const volunteering = await prisma.volunteering.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Volunteerings and only return the `id`
     * const volunteeringWithIdOnly = await prisma.volunteering.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VolunteeringCreateManyAndReturnArgs>(args?: SelectSubset<T, VolunteeringCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteeringPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Volunteering.
     * @param {VolunteeringDeleteArgs} args - Arguments to delete one Volunteering.
     * @example
     * // Delete one Volunteering
     * const Volunteering = await prisma.volunteering.delete({
     *   where: {
     *     // ... filter to delete one Volunteering
     *   }
     * })
     * 
     */
    delete<T extends VolunteeringDeleteArgs>(args: SelectSubset<T, VolunteeringDeleteArgs<ExtArgs>>): Prisma__VolunteeringClient<$Result.GetResult<Prisma.$VolunteeringPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Volunteering.
     * @param {VolunteeringUpdateArgs} args - Arguments to update one Volunteering.
     * @example
     * // Update one Volunteering
     * const volunteering = await prisma.volunteering.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VolunteeringUpdateArgs>(args: SelectSubset<T, VolunteeringUpdateArgs<ExtArgs>>): Prisma__VolunteeringClient<$Result.GetResult<Prisma.$VolunteeringPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Volunteerings.
     * @param {VolunteeringDeleteManyArgs} args - Arguments to filter Volunteerings to delete.
     * @example
     * // Delete a few Volunteerings
     * const { count } = await prisma.volunteering.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VolunteeringDeleteManyArgs>(args?: SelectSubset<T, VolunteeringDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Volunteerings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteeringUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Volunteerings
     * const volunteering = await prisma.volunteering.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VolunteeringUpdateManyArgs>(args: SelectSubset<T, VolunteeringUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Volunteerings and returns the data updated in the database.
     * @param {VolunteeringUpdateManyAndReturnArgs} args - Arguments to update many Volunteerings.
     * @example
     * // Update many Volunteerings
     * const volunteering = await prisma.volunteering.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Volunteerings and only return the `id`
     * const volunteeringWithIdOnly = await prisma.volunteering.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VolunteeringUpdateManyAndReturnArgs>(args: SelectSubset<T, VolunteeringUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteeringPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Volunteering.
     * @param {VolunteeringUpsertArgs} args - Arguments to update or create a Volunteering.
     * @example
     * // Update or create a Volunteering
     * const volunteering = await prisma.volunteering.upsert({
     *   create: {
     *     // ... data to create a Volunteering
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Volunteering we want to update
     *   }
     * })
     */
    upsert<T extends VolunteeringUpsertArgs>(args: SelectSubset<T, VolunteeringUpsertArgs<ExtArgs>>): Prisma__VolunteeringClient<$Result.GetResult<Prisma.$VolunteeringPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Volunteerings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteeringCountArgs} args - Arguments to filter Volunteerings to count.
     * @example
     * // Count the number of Volunteerings
     * const count = await prisma.volunteering.count({
     *   where: {
     *     // ... the filter for the Volunteerings we want to count
     *   }
     * })
    **/
    count<T extends VolunteeringCountArgs>(
      args?: Subset<T, VolunteeringCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VolunteeringCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Volunteering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteeringAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VolunteeringAggregateArgs>(args: Subset<T, VolunteeringAggregateArgs>): Prisma.PrismaPromise<GetVolunteeringAggregateType<T>>

    /**
     * Group by Volunteering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteeringGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VolunteeringGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VolunteeringGroupByArgs['orderBy'] }
        : { orderBy?: VolunteeringGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VolunteeringGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVolunteeringGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Volunteering model
   */
  readonly fields: VolunteeringFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Volunteering.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VolunteeringClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Volunteering model
   */
  interface VolunteeringFieldRefs {
    readonly id: FieldRef<"Volunteering", 'String'>
    readonly profile_id: FieldRef<"Volunteering", 'String'>
    readonly name: FieldRef<"Volunteering", 'String'>
    readonly authority: FieldRef<"Volunteering", 'String'>
    readonly issued_date: FieldRef<"Volunteering", 'DateTime'>
    readonly expiry_date: FieldRef<"Volunteering", 'DateTime'>
    readonly raw_json: FieldRef<"Volunteering", 'Json'>
    readonly created_at: FieldRef<"Volunteering", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Volunteering findUnique
   */
  export type VolunteeringFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteering
     */
    select?: VolunteeringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteering
     */
    omit?: VolunteeringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteeringInclude<ExtArgs> | null
    /**
     * Filter, which Volunteering to fetch.
     */
    where: VolunteeringWhereUniqueInput
  }

  /**
   * Volunteering findUniqueOrThrow
   */
  export type VolunteeringFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteering
     */
    select?: VolunteeringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteering
     */
    omit?: VolunteeringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteeringInclude<ExtArgs> | null
    /**
     * Filter, which Volunteering to fetch.
     */
    where: VolunteeringWhereUniqueInput
  }

  /**
   * Volunteering findFirst
   */
  export type VolunteeringFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteering
     */
    select?: VolunteeringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteering
     */
    omit?: VolunteeringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteeringInclude<ExtArgs> | null
    /**
     * Filter, which Volunteering to fetch.
     */
    where?: VolunteeringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volunteerings to fetch.
     */
    orderBy?: VolunteeringOrderByWithRelationInput | VolunteeringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Volunteerings.
     */
    cursor?: VolunteeringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volunteerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volunteerings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Volunteerings.
     */
    distinct?: VolunteeringScalarFieldEnum | VolunteeringScalarFieldEnum[]
  }

  /**
   * Volunteering findFirstOrThrow
   */
  export type VolunteeringFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteering
     */
    select?: VolunteeringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteering
     */
    omit?: VolunteeringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteeringInclude<ExtArgs> | null
    /**
     * Filter, which Volunteering to fetch.
     */
    where?: VolunteeringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volunteerings to fetch.
     */
    orderBy?: VolunteeringOrderByWithRelationInput | VolunteeringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Volunteerings.
     */
    cursor?: VolunteeringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volunteerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volunteerings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Volunteerings.
     */
    distinct?: VolunteeringScalarFieldEnum | VolunteeringScalarFieldEnum[]
  }

  /**
   * Volunteering findMany
   */
  export type VolunteeringFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteering
     */
    select?: VolunteeringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteering
     */
    omit?: VolunteeringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteeringInclude<ExtArgs> | null
    /**
     * Filter, which Volunteerings to fetch.
     */
    where?: VolunteeringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volunteerings to fetch.
     */
    orderBy?: VolunteeringOrderByWithRelationInput | VolunteeringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Volunteerings.
     */
    cursor?: VolunteeringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volunteerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volunteerings.
     */
    skip?: number
    distinct?: VolunteeringScalarFieldEnum | VolunteeringScalarFieldEnum[]
  }

  /**
   * Volunteering create
   */
  export type VolunteeringCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteering
     */
    select?: VolunteeringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteering
     */
    omit?: VolunteeringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteeringInclude<ExtArgs> | null
    /**
     * The data needed to create a Volunteering.
     */
    data: XOR<VolunteeringCreateInput, VolunteeringUncheckedCreateInput>
  }

  /**
   * Volunteering createMany
   */
  export type VolunteeringCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Volunteerings.
     */
    data: VolunteeringCreateManyInput | VolunteeringCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Volunteering createManyAndReturn
   */
  export type VolunteeringCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteering
     */
    select?: VolunteeringSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteering
     */
    omit?: VolunteeringOmit<ExtArgs> | null
    /**
     * The data used to create many Volunteerings.
     */
    data: VolunteeringCreateManyInput | VolunteeringCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteeringIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Volunteering update
   */
  export type VolunteeringUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteering
     */
    select?: VolunteeringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteering
     */
    omit?: VolunteeringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteeringInclude<ExtArgs> | null
    /**
     * The data needed to update a Volunteering.
     */
    data: XOR<VolunteeringUpdateInput, VolunteeringUncheckedUpdateInput>
    /**
     * Choose, which Volunteering to update.
     */
    where: VolunteeringWhereUniqueInput
  }

  /**
   * Volunteering updateMany
   */
  export type VolunteeringUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Volunteerings.
     */
    data: XOR<VolunteeringUpdateManyMutationInput, VolunteeringUncheckedUpdateManyInput>
    /**
     * Filter which Volunteerings to update
     */
    where?: VolunteeringWhereInput
    /**
     * Limit how many Volunteerings to update.
     */
    limit?: number
  }

  /**
   * Volunteering updateManyAndReturn
   */
  export type VolunteeringUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteering
     */
    select?: VolunteeringSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteering
     */
    omit?: VolunteeringOmit<ExtArgs> | null
    /**
     * The data used to update Volunteerings.
     */
    data: XOR<VolunteeringUpdateManyMutationInput, VolunteeringUncheckedUpdateManyInput>
    /**
     * Filter which Volunteerings to update
     */
    where?: VolunteeringWhereInput
    /**
     * Limit how many Volunteerings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteeringIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Volunteering upsert
   */
  export type VolunteeringUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteering
     */
    select?: VolunteeringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteering
     */
    omit?: VolunteeringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteeringInclude<ExtArgs> | null
    /**
     * The filter to search for the Volunteering to update in case it exists.
     */
    where: VolunteeringWhereUniqueInput
    /**
     * In case the Volunteering found by the `where` argument doesn't exist, create a new Volunteering with this data.
     */
    create: XOR<VolunteeringCreateInput, VolunteeringUncheckedCreateInput>
    /**
     * In case the Volunteering was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VolunteeringUpdateInput, VolunteeringUncheckedUpdateInput>
  }

  /**
   * Volunteering delete
   */
  export type VolunteeringDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteering
     */
    select?: VolunteeringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteering
     */
    omit?: VolunteeringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteeringInclude<ExtArgs> | null
    /**
     * Filter which Volunteering to delete.
     */
    where: VolunteeringWhereUniqueInput
  }

  /**
   * Volunteering deleteMany
   */
  export type VolunteeringDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Volunteerings to delete
     */
    where?: VolunteeringWhereInput
    /**
     * Limit how many Volunteerings to delete.
     */
    limit?: number
  }

  /**
   * Volunteering without action
   */
  export type VolunteeringDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volunteering
     */
    select?: VolunteeringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volunteering
     */
    omit?: VolunteeringOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolunteeringInclude<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageMinAggregateOutputType = {
    id: string | null
    profile_id: string | null
    language: string | null
    proficiency: string | null
    created_at: Date | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: string | null
    profile_id: string | null
    language: string | null
    proficiency: string | null
    created_at: Date | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    profile_id: number
    language: number
    proficiency: number
    raw_json: number
    created_at: number
    _all: number
  }


  export type LanguageMinAggregateInputType = {
    id?: true
    profile_id?: true
    language?: true
    proficiency?: true
    created_at?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    profile_id?: true
    language?: true
    proficiency?: true
    created_at?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    profile_id?: true
    language?: true
    proficiency?: true
    raw_json?: true
    created_at?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    id: string
    profile_id: string
    language: string | null
    proficiency: string | null
    raw_json: JsonValue | null
    created_at: Date
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    language?: boolean
    proficiency?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    language?: boolean
    proficiency?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    language?: boolean
    proficiency?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    id?: boolean
    profile_id?: boolean
    language?: boolean
    proficiency?: boolean
    raw_json?: boolean
    created_at?: boolean
  }

  export type LanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profile_id" | "language" | "proficiency" | "raw_json" | "created_at", ExtArgs["result"]["language"]>
  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type LanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type LanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profile_id: string
      language: string | null
      proficiency: string | null
      raw_json: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages and returns the data updated in the database.
     * @param {LanguageUpdateManyAndReturnArgs} args - Arguments to update many Languages.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, LanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */
  interface LanguageFieldRefs {
    readonly id: FieldRef<"Language", 'String'>
    readonly profile_id: FieldRef<"Language", 'String'>
    readonly language: FieldRef<"Language", 'String'>
    readonly proficiency: FieldRef<"Language", 'String'>
    readonly raw_json: FieldRef<"Language", 'Json'>
    readonly created_at: FieldRef<"Language", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language updateManyAndReturn
   */
  export type LanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to delete.
     */
    limit?: number
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    profile_id: string | null
    name: string | null
    authority: string | null
    issued_date: Date | null
    expiry_date: Date | null
    created_at: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    profile_id: string | null
    name: string | null
    authority: string | null
    issued_date: Date | null
    expiry_date: Date | null
    created_at: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    profile_id: number
    name: number
    authority: number
    issued_date: number
    expiry_date: number
    raw_json: number
    created_at: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    profile_id?: true
    name?: true
    authority?: true
    issued_date?: true
    expiry_date?: true
    created_at?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    profile_id?: true
    name?: true
    authority?: true
    issued_date?: true
    expiry_date?: true
    created_at?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    profile_id?: true
    name?: true
    authority?: true
    issued_date?: true
    expiry_date?: true
    raw_json?: true
    created_at?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    profile_id: string
    name: string | null
    authority: string | null
    issued_date: Date | null
    expiry_date: Date | null
    raw_json: JsonValue | null
    created_at: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    profile_id?: boolean
    name?: boolean
    authority?: boolean
    issued_date?: boolean
    expiry_date?: boolean
    raw_json?: boolean
    created_at?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profile_id" | "name" | "authority" | "issued_date" | "expiry_date" | "raw_json" | "created_at", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profile_id: string
      name: string | null
      authority: string | null
      issued_date: Date | null
      expiry_date: Date | null
      raw_json: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly profile_id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly authority: FieldRef<"Organization", 'String'>
    readonly issued_date: FieldRef<"Organization", 'DateTime'>
    readonly expiry_date: FieldRef<"Organization", 'DateTime'>
    readonly raw_json: FieldRef<"Organization", 'Json'>
    readonly created_at: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model MediaLibrary
   */

  export type AggregateMediaLibrary = {
    _count: MediaLibraryCountAggregateOutputType | null
    _avg: MediaLibraryAvgAggregateOutputType | null
    _sum: MediaLibrarySumAggregateOutputType | null
    _min: MediaLibraryMinAggregateOutputType | null
    _max: MediaLibraryMaxAggregateOutputType | null
  }

  export type MediaLibraryAvgAggregateOutputType = {
    file_size: number | null
  }

  export type MediaLibrarySumAggregateOutputType = {
    file_size: bigint | null
  }

  export type MediaLibraryMinAggregateOutputType = {
    id: string | null
    profile_id: string | null
    file_name: string | null
    file_type: string | null
    mime_type: string | null
    file_size: bigint | null
    storage_path: string | null
    storage_bucket: string | null
    title: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MediaLibraryMaxAggregateOutputType = {
    id: string | null
    profile_id: string | null
    file_name: string | null
    file_type: string | null
    mime_type: string | null
    file_size: bigint | null
    storage_path: string | null
    storage_bucket: string | null
    title: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MediaLibraryCountAggregateOutputType = {
    id: number
    profile_id: number
    file_name: number
    file_type: number
    mime_type: number
    file_size: number
    storage_path: number
    storage_bucket: number
    title: number
    description: number
    tags: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MediaLibraryAvgAggregateInputType = {
    file_size?: true
  }

  export type MediaLibrarySumAggregateInputType = {
    file_size?: true
  }

  export type MediaLibraryMinAggregateInputType = {
    id?: true
    profile_id?: true
    file_name?: true
    file_type?: true
    mime_type?: true
    file_size?: true
    storage_path?: true
    storage_bucket?: true
    title?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type MediaLibraryMaxAggregateInputType = {
    id?: true
    profile_id?: true
    file_name?: true
    file_type?: true
    mime_type?: true
    file_size?: true
    storage_path?: true
    storage_bucket?: true
    title?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type MediaLibraryCountAggregateInputType = {
    id?: true
    profile_id?: true
    file_name?: true
    file_type?: true
    mime_type?: true
    file_size?: true
    storage_path?: true
    storage_bucket?: true
    title?: true
    description?: true
    tags?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MediaLibraryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaLibrary to aggregate.
     */
    where?: MediaLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaLibraries to fetch.
     */
    orderBy?: MediaLibraryOrderByWithRelationInput | MediaLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaLibraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaLibraries
    **/
    _count?: true | MediaLibraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaLibraryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaLibrarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaLibraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaLibraryMaxAggregateInputType
  }

  export type GetMediaLibraryAggregateType<T extends MediaLibraryAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaLibrary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaLibrary[P]>
      : GetScalarType<T[P], AggregateMediaLibrary[P]>
  }




  export type MediaLibraryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaLibraryWhereInput
    orderBy?: MediaLibraryOrderByWithAggregationInput | MediaLibraryOrderByWithAggregationInput[]
    by: MediaLibraryScalarFieldEnum[] | MediaLibraryScalarFieldEnum
    having?: MediaLibraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaLibraryCountAggregateInputType | true
    _avg?: MediaLibraryAvgAggregateInputType
    _sum?: MediaLibrarySumAggregateInputType
    _min?: MediaLibraryMinAggregateInputType
    _max?: MediaLibraryMaxAggregateInputType
  }

  export type MediaLibraryGroupByOutputType = {
    id: string
    profile_id: string
    file_name: string
    file_type: string
    mime_type: string
    file_size: bigint
    storage_path: string
    storage_bucket: string
    title: string | null
    description: string | null
    tags: string[]
    metadata: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: MediaLibraryCountAggregateOutputType | null
    _avg: MediaLibraryAvgAggregateOutputType | null
    _sum: MediaLibrarySumAggregateOutputType | null
    _min: MediaLibraryMinAggregateOutputType | null
    _max: MediaLibraryMaxAggregateOutputType | null
  }

  type GetMediaLibraryGroupByPayload<T extends MediaLibraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaLibraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaLibraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaLibraryGroupByOutputType[P]>
            : GetScalarType<T[P], MediaLibraryGroupByOutputType[P]>
        }
      >
    >


  export type MediaLibrarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    file_name?: boolean
    file_type?: boolean
    mime_type?: boolean
    file_size?: boolean
    storage_path?: boolean
    storage_bucket?: boolean
    title?: boolean
    description?: boolean
    tags?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaLibrary"]>

  export type MediaLibrarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    file_name?: boolean
    file_type?: boolean
    mime_type?: boolean
    file_size?: boolean
    storage_path?: boolean
    storage_bucket?: boolean
    title?: boolean
    description?: boolean
    tags?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaLibrary"]>

  export type MediaLibrarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_id?: boolean
    file_name?: boolean
    file_type?: boolean
    mime_type?: boolean
    file_size?: boolean
    storage_path?: boolean
    storage_bucket?: boolean
    title?: boolean
    description?: boolean
    tags?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaLibrary"]>

  export type MediaLibrarySelectScalar = {
    id?: boolean
    profile_id?: boolean
    file_name?: boolean
    file_type?: boolean
    mime_type?: boolean
    file_size?: boolean
    storage_path?: boolean
    storage_bucket?: boolean
    title?: boolean
    description?: boolean
    tags?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type MediaLibraryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profile_id" | "file_name" | "file_type" | "mime_type" | "file_size" | "storage_path" | "storage_bucket" | "title" | "description" | "tags" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["mediaLibrary"]>
  export type MediaLibraryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type MediaLibraryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type MediaLibraryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $MediaLibraryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaLibrary"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profile_id: string
      file_name: string
      file_type: string
      mime_type: string
      file_size: bigint
      storage_path: string
      storage_bucket: string
      title: string | null
      description: string | null
      tags: string[]
      metadata: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["mediaLibrary"]>
    composites: {}
  }

  type MediaLibraryGetPayload<S extends boolean | null | undefined | MediaLibraryDefaultArgs> = $Result.GetResult<Prisma.$MediaLibraryPayload, S>

  type MediaLibraryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaLibraryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaLibraryCountAggregateInputType | true
    }

  export interface MediaLibraryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaLibrary'], meta: { name: 'MediaLibrary' } }
    /**
     * Find zero or one MediaLibrary that matches the filter.
     * @param {MediaLibraryFindUniqueArgs} args - Arguments to find a MediaLibrary
     * @example
     * // Get one MediaLibrary
     * const mediaLibrary = await prisma.mediaLibrary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaLibraryFindUniqueArgs>(args: SelectSubset<T, MediaLibraryFindUniqueArgs<ExtArgs>>): Prisma__MediaLibraryClient<$Result.GetResult<Prisma.$MediaLibraryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MediaLibrary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaLibraryFindUniqueOrThrowArgs} args - Arguments to find a MediaLibrary
     * @example
     * // Get one MediaLibrary
     * const mediaLibrary = await prisma.mediaLibrary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaLibraryFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaLibraryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaLibraryClient<$Result.GetResult<Prisma.$MediaLibraryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaLibrary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaLibraryFindFirstArgs} args - Arguments to find a MediaLibrary
     * @example
     * // Get one MediaLibrary
     * const mediaLibrary = await prisma.mediaLibrary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaLibraryFindFirstArgs>(args?: SelectSubset<T, MediaLibraryFindFirstArgs<ExtArgs>>): Prisma__MediaLibraryClient<$Result.GetResult<Prisma.$MediaLibraryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaLibrary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaLibraryFindFirstOrThrowArgs} args - Arguments to find a MediaLibrary
     * @example
     * // Get one MediaLibrary
     * const mediaLibrary = await prisma.mediaLibrary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaLibraryFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaLibraryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaLibraryClient<$Result.GetResult<Prisma.$MediaLibraryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MediaLibraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaLibraryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaLibraries
     * const mediaLibraries = await prisma.mediaLibrary.findMany()
     * 
     * // Get first 10 MediaLibraries
     * const mediaLibraries = await prisma.mediaLibrary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaLibraryWithIdOnly = await prisma.mediaLibrary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaLibraryFindManyArgs>(args?: SelectSubset<T, MediaLibraryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaLibraryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MediaLibrary.
     * @param {MediaLibraryCreateArgs} args - Arguments to create a MediaLibrary.
     * @example
     * // Create one MediaLibrary
     * const MediaLibrary = await prisma.mediaLibrary.create({
     *   data: {
     *     // ... data to create a MediaLibrary
     *   }
     * })
     * 
     */
    create<T extends MediaLibraryCreateArgs>(args: SelectSubset<T, MediaLibraryCreateArgs<ExtArgs>>): Prisma__MediaLibraryClient<$Result.GetResult<Prisma.$MediaLibraryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MediaLibraries.
     * @param {MediaLibraryCreateManyArgs} args - Arguments to create many MediaLibraries.
     * @example
     * // Create many MediaLibraries
     * const mediaLibrary = await prisma.mediaLibrary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaLibraryCreateManyArgs>(args?: SelectSubset<T, MediaLibraryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaLibraries and returns the data saved in the database.
     * @param {MediaLibraryCreateManyAndReturnArgs} args - Arguments to create many MediaLibraries.
     * @example
     * // Create many MediaLibraries
     * const mediaLibrary = await prisma.mediaLibrary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaLibraries and only return the `id`
     * const mediaLibraryWithIdOnly = await prisma.mediaLibrary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaLibraryCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaLibraryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaLibraryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MediaLibrary.
     * @param {MediaLibraryDeleteArgs} args - Arguments to delete one MediaLibrary.
     * @example
     * // Delete one MediaLibrary
     * const MediaLibrary = await prisma.mediaLibrary.delete({
     *   where: {
     *     // ... filter to delete one MediaLibrary
     *   }
     * })
     * 
     */
    delete<T extends MediaLibraryDeleteArgs>(args: SelectSubset<T, MediaLibraryDeleteArgs<ExtArgs>>): Prisma__MediaLibraryClient<$Result.GetResult<Prisma.$MediaLibraryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MediaLibrary.
     * @param {MediaLibraryUpdateArgs} args - Arguments to update one MediaLibrary.
     * @example
     * // Update one MediaLibrary
     * const mediaLibrary = await prisma.mediaLibrary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaLibraryUpdateArgs>(args: SelectSubset<T, MediaLibraryUpdateArgs<ExtArgs>>): Prisma__MediaLibraryClient<$Result.GetResult<Prisma.$MediaLibraryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MediaLibraries.
     * @param {MediaLibraryDeleteManyArgs} args - Arguments to filter MediaLibraries to delete.
     * @example
     * // Delete a few MediaLibraries
     * const { count } = await prisma.mediaLibrary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaLibraryDeleteManyArgs>(args?: SelectSubset<T, MediaLibraryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaLibraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaLibraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaLibraries
     * const mediaLibrary = await prisma.mediaLibrary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaLibraryUpdateManyArgs>(args: SelectSubset<T, MediaLibraryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaLibraries and returns the data updated in the database.
     * @param {MediaLibraryUpdateManyAndReturnArgs} args - Arguments to update many MediaLibraries.
     * @example
     * // Update many MediaLibraries
     * const mediaLibrary = await prisma.mediaLibrary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MediaLibraries and only return the `id`
     * const mediaLibraryWithIdOnly = await prisma.mediaLibrary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaLibraryUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaLibraryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaLibraryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MediaLibrary.
     * @param {MediaLibraryUpsertArgs} args - Arguments to update or create a MediaLibrary.
     * @example
     * // Update or create a MediaLibrary
     * const mediaLibrary = await prisma.mediaLibrary.upsert({
     *   create: {
     *     // ... data to create a MediaLibrary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaLibrary we want to update
     *   }
     * })
     */
    upsert<T extends MediaLibraryUpsertArgs>(args: SelectSubset<T, MediaLibraryUpsertArgs<ExtArgs>>): Prisma__MediaLibraryClient<$Result.GetResult<Prisma.$MediaLibraryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MediaLibraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaLibraryCountArgs} args - Arguments to filter MediaLibraries to count.
     * @example
     * // Count the number of MediaLibraries
     * const count = await prisma.mediaLibrary.count({
     *   where: {
     *     // ... the filter for the MediaLibraries we want to count
     *   }
     * })
    **/
    count<T extends MediaLibraryCountArgs>(
      args?: Subset<T, MediaLibraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaLibraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaLibrary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaLibraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaLibraryAggregateArgs>(args: Subset<T, MediaLibraryAggregateArgs>): Prisma.PrismaPromise<GetMediaLibraryAggregateType<T>>

    /**
     * Group by MediaLibrary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaLibraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaLibraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaLibraryGroupByArgs['orderBy'] }
        : { orderBy?: MediaLibraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaLibraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaLibraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaLibrary model
   */
  readonly fields: MediaLibraryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaLibrary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaLibraryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaLibrary model
   */
  interface MediaLibraryFieldRefs {
    readonly id: FieldRef<"MediaLibrary", 'String'>
    readonly profile_id: FieldRef<"MediaLibrary", 'String'>
    readonly file_name: FieldRef<"MediaLibrary", 'String'>
    readonly file_type: FieldRef<"MediaLibrary", 'String'>
    readonly mime_type: FieldRef<"MediaLibrary", 'String'>
    readonly file_size: FieldRef<"MediaLibrary", 'BigInt'>
    readonly storage_path: FieldRef<"MediaLibrary", 'String'>
    readonly storage_bucket: FieldRef<"MediaLibrary", 'String'>
    readonly title: FieldRef<"MediaLibrary", 'String'>
    readonly description: FieldRef<"MediaLibrary", 'String'>
    readonly tags: FieldRef<"MediaLibrary", 'String[]'>
    readonly metadata: FieldRef<"MediaLibrary", 'Json'>
    readonly created_at: FieldRef<"MediaLibrary", 'DateTime'>
    readonly updated_at: FieldRef<"MediaLibrary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaLibrary findUnique
   */
  export type MediaLibraryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaLibrary
     */
    select?: MediaLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaLibrary
     */
    omit?: MediaLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaLibraryInclude<ExtArgs> | null
    /**
     * Filter, which MediaLibrary to fetch.
     */
    where: MediaLibraryWhereUniqueInput
  }

  /**
   * MediaLibrary findUniqueOrThrow
   */
  export type MediaLibraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaLibrary
     */
    select?: MediaLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaLibrary
     */
    omit?: MediaLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaLibraryInclude<ExtArgs> | null
    /**
     * Filter, which MediaLibrary to fetch.
     */
    where: MediaLibraryWhereUniqueInput
  }

  /**
   * MediaLibrary findFirst
   */
  export type MediaLibraryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaLibrary
     */
    select?: MediaLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaLibrary
     */
    omit?: MediaLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaLibraryInclude<ExtArgs> | null
    /**
     * Filter, which MediaLibrary to fetch.
     */
    where?: MediaLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaLibraries to fetch.
     */
    orderBy?: MediaLibraryOrderByWithRelationInput | MediaLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaLibraries.
     */
    cursor?: MediaLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaLibraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaLibraries.
     */
    distinct?: MediaLibraryScalarFieldEnum | MediaLibraryScalarFieldEnum[]
  }

  /**
   * MediaLibrary findFirstOrThrow
   */
  export type MediaLibraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaLibrary
     */
    select?: MediaLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaLibrary
     */
    omit?: MediaLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaLibraryInclude<ExtArgs> | null
    /**
     * Filter, which MediaLibrary to fetch.
     */
    where?: MediaLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaLibraries to fetch.
     */
    orderBy?: MediaLibraryOrderByWithRelationInput | MediaLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaLibraries.
     */
    cursor?: MediaLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaLibraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaLibraries.
     */
    distinct?: MediaLibraryScalarFieldEnum | MediaLibraryScalarFieldEnum[]
  }

  /**
   * MediaLibrary findMany
   */
  export type MediaLibraryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaLibrary
     */
    select?: MediaLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaLibrary
     */
    omit?: MediaLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaLibraryInclude<ExtArgs> | null
    /**
     * Filter, which MediaLibraries to fetch.
     */
    where?: MediaLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaLibraries to fetch.
     */
    orderBy?: MediaLibraryOrderByWithRelationInput | MediaLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaLibraries.
     */
    cursor?: MediaLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaLibraries.
     */
    skip?: number
    distinct?: MediaLibraryScalarFieldEnum | MediaLibraryScalarFieldEnum[]
  }

  /**
   * MediaLibrary create
   */
  export type MediaLibraryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaLibrary
     */
    select?: MediaLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaLibrary
     */
    omit?: MediaLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaLibraryInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaLibrary.
     */
    data: XOR<MediaLibraryCreateInput, MediaLibraryUncheckedCreateInput>
  }

  /**
   * MediaLibrary createMany
   */
  export type MediaLibraryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaLibraries.
     */
    data: MediaLibraryCreateManyInput | MediaLibraryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaLibrary createManyAndReturn
   */
  export type MediaLibraryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaLibrary
     */
    select?: MediaLibrarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaLibrary
     */
    omit?: MediaLibraryOmit<ExtArgs> | null
    /**
     * The data used to create many MediaLibraries.
     */
    data: MediaLibraryCreateManyInput | MediaLibraryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaLibraryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaLibrary update
   */
  export type MediaLibraryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaLibrary
     */
    select?: MediaLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaLibrary
     */
    omit?: MediaLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaLibraryInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaLibrary.
     */
    data: XOR<MediaLibraryUpdateInput, MediaLibraryUncheckedUpdateInput>
    /**
     * Choose, which MediaLibrary to update.
     */
    where: MediaLibraryWhereUniqueInput
  }

  /**
   * MediaLibrary updateMany
   */
  export type MediaLibraryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaLibraries.
     */
    data: XOR<MediaLibraryUpdateManyMutationInput, MediaLibraryUncheckedUpdateManyInput>
    /**
     * Filter which MediaLibraries to update
     */
    where?: MediaLibraryWhereInput
    /**
     * Limit how many MediaLibraries to update.
     */
    limit?: number
  }

  /**
   * MediaLibrary updateManyAndReturn
   */
  export type MediaLibraryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaLibrary
     */
    select?: MediaLibrarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaLibrary
     */
    omit?: MediaLibraryOmit<ExtArgs> | null
    /**
     * The data used to update MediaLibraries.
     */
    data: XOR<MediaLibraryUpdateManyMutationInput, MediaLibraryUncheckedUpdateManyInput>
    /**
     * Filter which MediaLibraries to update
     */
    where?: MediaLibraryWhereInput
    /**
     * Limit how many MediaLibraries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaLibraryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaLibrary upsert
   */
  export type MediaLibraryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaLibrary
     */
    select?: MediaLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaLibrary
     */
    omit?: MediaLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaLibraryInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaLibrary to update in case it exists.
     */
    where: MediaLibraryWhereUniqueInput
    /**
     * In case the MediaLibrary found by the `where` argument doesn't exist, create a new MediaLibrary with this data.
     */
    create: XOR<MediaLibraryCreateInput, MediaLibraryUncheckedCreateInput>
    /**
     * In case the MediaLibrary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaLibraryUpdateInput, MediaLibraryUncheckedUpdateInput>
  }

  /**
   * MediaLibrary delete
   */
  export type MediaLibraryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaLibrary
     */
    select?: MediaLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaLibrary
     */
    omit?: MediaLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaLibraryInclude<ExtArgs> | null
    /**
     * Filter which MediaLibrary to delete.
     */
    where: MediaLibraryWhereUniqueInput
  }

  /**
   * MediaLibrary deleteMany
   */
  export type MediaLibraryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaLibraries to delete
     */
    where?: MediaLibraryWhereInput
    /**
     * Limit how many MediaLibraries to delete.
     */
    limit?: number
  }

  /**
   * MediaLibrary without action
   */
  export type MediaLibraryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaLibrary
     */
    select?: MediaLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaLibrary
     */
    omit?: MediaLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaLibraryInclude<ExtArgs> | null
  }


  /**
   * Model PersonalityAssessment
   */

  export type AggregatePersonalityAssessment = {
    _count: PersonalityAssessmentCountAggregateOutputType | null
    _avg: PersonalityAssessmentAvgAggregateOutputType | null
    _sum: PersonalityAssessmentSumAggregateOutputType | null
    _min: PersonalityAssessmentMinAggregateOutputType | null
    _max: PersonalityAssessmentMaxAggregateOutputType | null
  }

  export type PersonalityAssessmentAvgAggregateOutputType = {
    time_taken_seconds: number | null
    openness_score: number | null
    conscientiousness_score: number | null
    extraversion_score: number | null
    agreeableness_score: number | null
    emotional_stability_score: number | null
    overall_score: number | null
  }

  export type PersonalityAssessmentSumAggregateOutputType = {
    time_taken_seconds: number | null
    openness_score: number | null
    conscientiousness_score: number | null
    extraversion_score: number | null
    agreeableness_score: number | null
    emotional_stability_score: number | null
    overall_score: number | null
  }

  export type PersonalityAssessmentMinAggregateOutputType = {
    id: string | null
    users_id: string | null
    assessment_date: Date | null
    completed: boolean | null
    time_taken_seconds: number | null
    openness_score: number | null
    conscientiousness_score: number | null
    extraversion_score: number | null
    agreeableness_score: number | null
    emotional_stability_score: number | null
    overall_score: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PersonalityAssessmentMaxAggregateOutputType = {
    id: string | null
    users_id: string | null
    assessment_date: Date | null
    completed: boolean | null
    time_taken_seconds: number | null
    openness_score: number | null
    conscientiousness_score: number | null
    extraversion_score: number | null
    agreeableness_score: number | null
    emotional_stability_score: number | null
    overall_score: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PersonalityAssessmentCountAggregateOutputType = {
    id: number
    users_id: number
    assessment_date: number
    completed: number
    time_taken_seconds: number
    openness_score: number
    conscientiousness_score: number
    extraversion_score: number
    agreeableness_score: number
    emotional_stability_score: number
    overall_score: number
    responses: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PersonalityAssessmentAvgAggregateInputType = {
    time_taken_seconds?: true
    openness_score?: true
    conscientiousness_score?: true
    extraversion_score?: true
    agreeableness_score?: true
    emotional_stability_score?: true
    overall_score?: true
  }

  export type PersonalityAssessmentSumAggregateInputType = {
    time_taken_seconds?: true
    openness_score?: true
    conscientiousness_score?: true
    extraversion_score?: true
    agreeableness_score?: true
    emotional_stability_score?: true
    overall_score?: true
  }

  export type PersonalityAssessmentMinAggregateInputType = {
    id?: true
    users_id?: true
    assessment_date?: true
    completed?: true
    time_taken_seconds?: true
    openness_score?: true
    conscientiousness_score?: true
    extraversion_score?: true
    agreeableness_score?: true
    emotional_stability_score?: true
    overall_score?: true
    created_at?: true
    updated_at?: true
  }

  export type PersonalityAssessmentMaxAggregateInputType = {
    id?: true
    users_id?: true
    assessment_date?: true
    completed?: true
    time_taken_seconds?: true
    openness_score?: true
    conscientiousness_score?: true
    extraversion_score?: true
    agreeableness_score?: true
    emotional_stability_score?: true
    overall_score?: true
    created_at?: true
    updated_at?: true
  }

  export type PersonalityAssessmentCountAggregateInputType = {
    id?: true
    users_id?: true
    assessment_date?: true
    completed?: true
    time_taken_seconds?: true
    openness_score?: true
    conscientiousness_score?: true
    extraversion_score?: true
    agreeableness_score?: true
    emotional_stability_score?: true
    overall_score?: true
    responses?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PersonalityAssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalityAssessment to aggregate.
     */
    where?: PersonalityAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalityAssessments to fetch.
     */
    orderBy?: PersonalityAssessmentOrderByWithRelationInput | PersonalityAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalityAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalityAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalityAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonalityAssessments
    **/
    _count?: true | PersonalityAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonalityAssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonalityAssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalityAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalityAssessmentMaxAggregateInputType
  }

  export type GetPersonalityAssessmentAggregateType<T extends PersonalityAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalityAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalityAssessment[P]>
      : GetScalarType<T[P], AggregatePersonalityAssessment[P]>
  }




  export type PersonalityAssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalityAssessmentWhereInput
    orderBy?: PersonalityAssessmentOrderByWithAggregationInput | PersonalityAssessmentOrderByWithAggregationInput[]
    by: PersonalityAssessmentScalarFieldEnum[] | PersonalityAssessmentScalarFieldEnum
    having?: PersonalityAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalityAssessmentCountAggregateInputType | true
    _avg?: PersonalityAssessmentAvgAggregateInputType
    _sum?: PersonalityAssessmentSumAggregateInputType
    _min?: PersonalityAssessmentMinAggregateInputType
    _max?: PersonalityAssessmentMaxAggregateInputType
  }

  export type PersonalityAssessmentGroupByOutputType = {
    id: string
    users_id: string
    assessment_date: Date
    completed: boolean
    time_taken_seconds: number | null
    openness_score: number | null
    conscientiousness_score: number | null
    extraversion_score: number | null
    agreeableness_score: number | null
    emotional_stability_score: number | null
    overall_score: number | null
    responses: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: PersonalityAssessmentCountAggregateOutputType | null
    _avg: PersonalityAssessmentAvgAggregateOutputType | null
    _sum: PersonalityAssessmentSumAggregateOutputType | null
    _min: PersonalityAssessmentMinAggregateOutputType | null
    _max: PersonalityAssessmentMaxAggregateOutputType | null
  }

  type GetPersonalityAssessmentGroupByPayload<T extends PersonalityAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalityAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalityAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalityAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalityAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type PersonalityAssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    users_id?: boolean
    assessment_date?: boolean
    completed?: boolean
    time_taken_seconds?: boolean
    openness_score?: boolean
    conscientiousness_score?: boolean
    extraversion_score?: boolean
    agreeableness_score?: boolean
    emotional_stability_score?: boolean
    overall_score?: boolean
    responses?: boolean
    created_at?: boolean
    updated_at?: boolean
    responses_rel?: boolean | PersonalityAssessment$responses_relArgs<ExtArgs>
    _count?: boolean | PersonalityAssessmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalityAssessment"]>

  export type PersonalityAssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    users_id?: boolean
    assessment_date?: boolean
    completed?: boolean
    time_taken_seconds?: boolean
    openness_score?: boolean
    conscientiousness_score?: boolean
    extraversion_score?: boolean
    agreeableness_score?: boolean
    emotional_stability_score?: boolean
    overall_score?: boolean
    responses?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["personalityAssessment"]>

  export type PersonalityAssessmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    users_id?: boolean
    assessment_date?: boolean
    completed?: boolean
    time_taken_seconds?: boolean
    openness_score?: boolean
    conscientiousness_score?: boolean
    extraversion_score?: boolean
    agreeableness_score?: boolean
    emotional_stability_score?: boolean
    overall_score?: boolean
    responses?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["personalityAssessment"]>

  export type PersonalityAssessmentSelectScalar = {
    id?: boolean
    users_id?: boolean
    assessment_date?: boolean
    completed?: boolean
    time_taken_seconds?: boolean
    openness_score?: boolean
    conscientiousness_score?: boolean
    extraversion_score?: boolean
    agreeableness_score?: boolean
    emotional_stability_score?: boolean
    overall_score?: boolean
    responses?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PersonalityAssessmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "users_id" | "assessment_date" | "completed" | "time_taken_seconds" | "openness_score" | "conscientiousness_score" | "extraversion_score" | "agreeableness_score" | "emotional_stability_score" | "overall_score" | "responses" | "created_at" | "updated_at", ExtArgs["result"]["personalityAssessment"]>
  export type PersonalityAssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses_rel?: boolean | PersonalityAssessment$responses_relArgs<ExtArgs>
    _count?: boolean | PersonalityAssessmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonalityAssessmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PersonalityAssessmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PersonalityAssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonalityAssessment"
    objects: {
      responses_rel: Prisma.$PersonalityResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      users_id: string
      assessment_date: Date
      completed: boolean
      time_taken_seconds: number | null
      openness_score: number | null
      conscientiousness_score: number | null
      extraversion_score: number | null
      agreeableness_score: number | null
      emotional_stability_score: number | null
      overall_score: number | null
      responses: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["personalityAssessment"]>
    composites: {}
  }

  type PersonalityAssessmentGetPayload<S extends boolean | null | undefined | PersonalityAssessmentDefaultArgs> = $Result.GetResult<Prisma.$PersonalityAssessmentPayload, S>

  type PersonalityAssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonalityAssessmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonalityAssessmentCountAggregateInputType | true
    }

  export interface PersonalityAssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonalityAssessment'], meta: { name: 'PersonalityAssessment' } }
    /**
     * Find zero or one PersonalityAssessment that matches the filter.
     * @param {PersonalityAssessmentFindUniqueArgs} args - Arguments to find a PersonalityAssessment
     * @example
     * // Get one PersonalityAssessment
     * const personalityAssessment = await prisma.personalityAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonalityAssessmentFindUniqueArgs>(args: SelectSubset<T, PersonalityAssessmentFindUniqueArgs<ExtArgs>>): Prisma__PersonalityAssessmentClient<$Result.GetResult<Prisma.$PersonalityAssessmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonalityAssessment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonalityAssessmentFindUniqueOrThrowArgs} args - Arguments to find a PersonalityAssessment
     * @example
     * // Get one PersonalityAssessment
     * const personalityAssessment = await prisma.personalityAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonalityAssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonalityAssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonalityAssessmentClient<$Result.GetResult<Prisma.$PersonalityAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalityAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityAssessmentFindFirstArgs} args - Arguments to find a PersonalityAssessment
     * @example
     * // Get one PersonalityAssessment
     * const personalityAssessment = await prisma.personalityAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonalityAssessmentFindFirstArgs>(args?: SelectSubset<T, PersonalityAssessmentFindFirstArgs<ExtArgs>>): Prisma__PersonalityAssessmentClient<$Result.GetResult<Prisma.$PersonalityAssessmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalityAssessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityAssessmentFindFirstOrThrowArgs} args - Arguments to find a PersonalityAssessment
     * @example
     * // Get one PersonalityAssessment
     * const personalityAssessment = await prisma.personalityAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonalityAssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonalityAssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonalityAssessmentClient<$Result.GetResult<Prisma.$PersonalityAssessmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonalityAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityAssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonalityAssessments
     * const personalityAssessments = await prisma.personalityAssessment.findMany()
     * 
     * // Get first 10 PersonalityAssessments
     * const personalityAssessments = await prisma.personalityAssessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalityAssessmentWithIdOnly = await prisma.personalityAssessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonalityAssessmentFindManyArgs>(args?: SelectSubset<T, PersonalityAssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalityAssessmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonalityAssessment.
     * @param {PersonalityAssessmentCreateArgs} args - Arguments to create a PersonalityAssessment.
     * @example
     * // Create one PersonalityAssessment
     * const PersonalityAssessment = await prisma.personalityAssessment.create({
     *   data: {
     *     // ... data to create a PersonalityAssessment
     *   }
     * })
     * 
     */
    create<T extends PersonalityAssessmentCreateArgs>(args: SelectSubset<T, PersonalityAssessmentCreateArgs<ExtArgs>>): Prisma__PersonalityAssessmentClient<$Result.GetResult<Prisma.$PersonalityAssessmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonalityAssessments.
     * @param {PersonalityAssessmentCreateManyArgs} args - Arguments to create many PersonalityAssessments.
     * @example
     * // Create many PersonalityAssessments
     * const personalityAssessment = await prisma.personalityAssessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonalityAssessmentCreateManyArgs>(args?: SelectSubset<T, PersonalityAssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonalityAssessments and returns the data saved in the database.
     * @param {PersonalityAssessmentCreateManyAndReturnArgs} args - Arguments to create many PersonalityAssessments.
     * @example
     * // Create many PersonalityAssessments
     * const personalityAssessment = await prisma.personalityAssessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonalityAssessments and only return the `id`
     * const personalityAssessmentWithIdOnly = await prisma.personalityAssessment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonalityAssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonalityAssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalityAssessmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersonalityAssessment.
     * @param {PersonalityAssessmentDeleteArgs} args - Arguments to delete one PersonalityAssessment.
     * @example
     * // Delete one PersonalityAssessment
     * const PersonalityAssessment = await prisma.personalityAssessment.delete({
     *   where: {
     *     // ... filter to delete one PersonalityAssessment
     *   }
     * })
     * 
     */
    delete<T extends PersonalityAssessmentDeleteArgs>(args: SelectSubset<T, PersonalityAssessmentDeleteArgs<ExtArgs>>): Prisma__PersonalityAssessmentClient<$Result.GetResult<Prisma.$PersonalityAssessmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonalityAssessment.
     * @param {PersonalityAssessmentUpdateArgs} args - Arguments to update one PersonalityAssessment.
     * @example
     * // Update one PersonalityAssessment
     * const personalityAssessment = await prisma.personalityAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonalityAssessmentUpdateArgs>(args: SelectSubset<T, PersonalityAssessmentUpdateArgs<ExtArgs>>): Prisma__PersonalityAssessmentClient<$Result.GetResult<Prisma.$PersonalityAssessmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonalityAssessments.
     * @param {PersonalityAssessmentDeleteManyArgs} args - Arguments to filter PersonalityAssessments to delete.
     * @example
     * // Delete a few PersonalityAssessments
     * const { count } = await prisma.personalityAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonalityAssessmentDeleteManyArgs>(args?: SelectSubset<T, PersonalityAssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalityAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonalityAssessments
     * const personalityAssessment = await prisma.personalityAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonalityAssessmentUpdateManyArgs>(args: SelectSubset<T, PersonalityAssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalityAssessments and returns the data updated in the database.
     * @param {PersonalityAssessmentUpdateManyAndReturnArgs} args - Arguments to update many PersonalityAssessments.
     * @example
     * // Update many PersonalityAssessments
     * const personalityAssessment = await prisma.personalityAssessment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersonalityAssessments and only return the `id`
     * const personalityAssessmentWithIdOnly = await prisma.personalityAssessment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonalityAssessmentUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonalityAssessmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalityAssessmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersonalityAssessment.
     * @param {PersonalityAssessmentUpsertArgs} args - Arguments to update or create a PersonalityAssessment.
     * @example
     * // Update or create a PersonalityAssessment
     * const personalityAssessment = await prisma.personalityAssessment.upsert({
     *   create: {
     *     // ... data to create a PersonalityAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonalityAssessment we want to update
     *   }
     * })
     */
    upsert<T extends PersonalityAssessmentUpsertArgs>(args: SelectSubset<T, PersonalityAssessmentUpsertArgs<ExtArgs>>): Prisma__PersonalityAssessmentClient<$Result.GetResult<Prisma.$PersonalityAssessmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonalityAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityAssessmentCountArgs} args - Arguments to filter PersonalityAssessments to count.
     * @example
     * // Count the number of PersonalityAssessments
     * const count = await prisma.personalityAssessment.count({
     *   where: {
     *     // ... the filter for the PersonalityAssessments we want to count
     *   }
     * })
    **/
    count<T extends PersonalityAssessmentCountArgs>(
      args?: Subset<T, PersonalityAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalityAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonalityAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalityAssessmentAggregateArgs>(args: Subset<T, PersonalityAssessmentAggregateArgs>): Prisma.PrismaPromise<GetPersonalityAssessmentAggregateType<T>>

    /**
     * Group by PersonalityAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalityAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalityAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: PersonalityAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalityAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalityAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonalityAssessment model
   */
  readonly fields: PersonalityAssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonalityAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonalityAssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responses_rel<T extends PersonalityAssessment$responses_relArgs<ExtArgs> = {}>(args?: Subset<T, PersonalityAssessment$responses_relArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalityResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonalityAssessment model
   */
  interface PersonalityAssessmentFieldRefs {
    readonly id: FieldRef<"PersonalityAssessment", 'String'>
    readonly users_id: FieldRef<"PersonalityAssessment", 'String'>
    readonly assessment_date: FieldRef<"PersonalityAssessment", 'DateTime'>
    readonly completed: FieldRef<"PersonalityAssessment", 'Boolean'>
    readonly time_taken_seconds: FieldRef<"PersonalityAssessment", 'Int'>
    readonly openness_score: FieldRef<"PersonalityAssessment", 'Int'>
    readonly conscientiousness_score: FieldRef<"PersonalityAssessment", 'Int'>
    readonly extraversion_score: FieldRef<"PersonalityAssessment", 'Int'>
    readonly agreeableness_score: FieldRef<"PersonalityAssessment", 'Int'>
    readonly emotional_stability_score: FieldRef<"PersonalityAssessment", 'Int'>
    readonly overall_score: FieldRef<"PersonalityAssessment", 'Float'>
    readonly responses: FieldRef<"PersonalityAssessment", 'Json'>
    readonly created_at: FieldRef<"PersonalityAssessment", 'DateTime'>
    readonly updated_at: FieldRef<"PersonalityAssessment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PersonalityAssessment findUnique
   */
  export type PersonalityAssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityAssessment
     */
    select?: PersonalityAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityAssessment
     */
    omit?: PersonalityAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which PersonalityAssessment to fetch.
     */
    where: PersonalityAssessmentWhereUniqueInput
  }

  /**
   * PersonalityAssessment findUniqueOrThrow
   */
  export type PersonalityAssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityAssessment
     */
    select?: PersonalityAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityAssessment
     */
    omit?: PersonalityAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which PersonalityAssessment to fetch.
     */
    where: PersonalityAssessmentWhereUniqueInput
  }

  /**
   * PersonalityAssessment findFirst
   */
  export type PersonalityAssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityAssessment
     */
    select?: PersonalityAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityAssessment
     */
    omit?: PersonalityAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which PersonalityAssessment to fetch.
     */
    where?: PersonalityAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalityAssessments to fetch.
     */
    orderBy?: PersonalityAssessmentOrderByWithRelationInput | PersonalityAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalityAssessments.
     */
    cursor?: PersonalityAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalityAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalityAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalityAssessments.
     */
    distinct?: PersonalityAssessmentScalarFieldEnum | PersonalityAssessmentScalarFieldEnum[]
  }

  /**
   * PersonalityAssessment findFirstOrThrow
   */
  export type PersonalityAssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityAssessment
     */
    select?: PersonalityAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityAssessment
     */
    omit?: PersonalityAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which PersonalityAssessment to fetch.
     */
    where?: PersonalityAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalityAssessments to fetch.
     */
    orderBy?: PersonalityAssessmentOrderByWithRelationInput | PersonalityAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalityAssessments.
     */
    cursor?: PersonalityAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalityAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalityAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalityAssessments.
     */
    distinct?: PersonalityAssessmentScalarFieldEnum | PersonalityAssessmentScalarFieldEnum[]
  }

  /**
   * PersonalityAssessment findMany
   */
  export type PersonalityAssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityAssessment
     */
    select?: PersonalityAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityAssessment
     */
    omit?: PersonalityAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which PersonalityAssessments to fetch.
     */
    where?: PersonalityAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalityAssessments to fetch.
     */
    orderBy?: PersonalityAssessmentOrderByWithRelationInput | PersonalityAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonalityAssessments.
     */
    cursor?: PersonalityAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalityAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalityAssessments.
     */
    skip?: number
    distinct?: PersonalityAssessmentScalarFieldEnum | PersonalityAssessmentScalarFieldEnum[]
  }

  /**
   * PersonalityAssessment create
   */
  export type PersonalityAssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityAssessment
     */
    select?: PersonalityAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityAssessment
     */
    omit?: PersonalityAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonalityAssessment.
     */
    data: XOR<PersonalityAssessmentCreateInput, PersonalityAssessmentUncheckedCreateInput>
  }

  /**
   * PersonalityAssessment createMany
   */
  export type PersonalityAssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonalityAssessments.
     */
    data: PersonalityAssessmentCreateManyInput | PersonalityAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonalityAssessment createManyAndReturn
   */
  export type PersonalityAssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityAssessment
     */
    select?: PersonalityAssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityAssessment
     */
    omit?: PersonalityAssessmentOmit<ExtArgs> | null
    /**
     * The data used to create many PersonalityAssessments.
     */
    data: PersonalityAssessmentCreateManyInput | PersonalityAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonalityAssessment update
   */
  export type PersonalityAssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityAssessment
     */
    select?: PersonalityAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityAssessment
     */
    omit?: PersonalityAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonalityAssessment.
     */
    data: XOR<PersonalityAssessmentUpdateInput, PersonalityAssessmentUncheckedUpdateInput>
    /**
     * Choose, which PersonalityAssessment to update.
     */
    where: PersonalityAssessmentWhereUniqueInput
  }

  /**
   * PersonalityAssessment updateMany
   */
  export type PersonalityAssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonalityAssessments.
     */
    data: XOR<PersonalityAssessmentUpdateManyMutationInput, PersonalityAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which PersonalityAssessments to update
     */
    where?: PersonalityAssessmentWhereInput
    /**
     * Limit how many PersonalityAssessments to update.
     */
    limit?: number
  }

  /**
   * PersonalityAssessment updateManyAndReturn
   */
  export type PersonalityAssessmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityAssessment
     */
    select?: PersonalityAssessmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityAssessment
     */
    omit?: PersonalityAssessmentOmit<ExtArgs> | null
    /**
     * The data used to update PersonalityAssessments.
     */
    data: XOR<PersonalityAssessmentUpdateManyMutationInput, PersonalityAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which PersonalityAssessments to update
     */
    where?: PersonalityAssessmentWhereInput
    /**
     * Limit how many PersonalityAssessments to update.
     */
    limit?: number
  }

  /**
   * PersonalityAssessment upsert
   */
  export type PersonalityAssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityAssessment
     */
    select?: PersonalityAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityAssessment
     */
    omit?: PersonalityAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityAssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonalityAssessment to update in case it exists.
     */
    where: PersonalityAssessmentWhereUniqueInput
    /**
     * In case the PersonalityAssessment found by the `where` argument doesn't exist, create a new PersonalityAssessment with this data.
     */
    create: XOR<PersonalityAssessmentCreateInput, PersonalityAssessmentUncheckedCreateInput>
    /**
     * In case the PersonalityAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalityAssessmentUpdateInput, PersonalityAssessmentUncheckedUpdateInput>
  }

  /**
   * PersonalityAssessment delete
   */
  export type PersonalityAssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityAssessment
     */
    select?: PersonalityAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityAssessment
     */
    omit?: PersonalityAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityAssessmentInclude<ExtArgs> | null
    /**
     * Filter which PersonalityAssessment to delete.
     */
    where: PersonalityAssessmentWhereUniqueInput
  }

  /**
   * PersonalityAssessment deleteMany
   */
  export type PersonalityAssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalityAssessments to delete
     */
    where?: PersonalityAssessmentWhereInput
    /**
     * Limit how many PersonalityAssessments to delete.
     */
    limit?: number
  }

  /**
   * PersonalityAssessment.responses_rel
   */
  export type PersonalityAssessment$responses_relArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityResponse
     */
    select?: PersonalityResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityResponse
     */
    omit?: PersonalityResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityResponseInclude<ExtArgs> | null
    where?: PersonalityResponseWhereInput
    orderBy?: PersonalityResponseOrderByWithRelationInput | PersonalityResponseOrderByWithRelationInput[]
    cursor?: PersonalityResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalityResponseScalarFieldEnum | PersonalityResponseScalarFieldEnum[]
  }

  /**
   * PersonalityAssessment without action
   */
  export type PersonalityAssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityAssessment
     */
    select?: PersonalityAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityAssessment
     */
    omit?: PersonalityAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityAssessmentInclude<ExtArgs> | null
  }


  /**
   * Model PersonalityResponse
   */

  export type AggregatePersonalityResponse = {
    _count: PersonalityResponseCountAggregateOutputType | null
    _avg: PersonalityResponseAvgAggregateOutputType | null
    _sum: PersonalityResponseSumAggregateOutputType | null
    _min: PersonalityResponseMinAggregateOutputType | null
    _max: PersonalityResponseMaxAggregateOutputType | null
  }

  export type PersonalityResponseAvgAggregateOutputType = {
    response_value: number | null
  }

  export type PersonalityResponseSumAggregateOutputType = {
    response_value: number | null
  }

  export type PersonalityResponseMinAggregateOutputType = {
    id: string | null
    assessment_id: string | null
    question_id: string | null
    question_text: string | null
    dimension: string | null
    response_value: number | null
    created_at: Date | null
  }

  export type PersonalityResponseMaxAggregateOutputType = {
    id: string | null
    assessment_id: string | null
    question_id: string | null
    question_text: string | null
    dimension: string | null
    response_value: number | null
    created_at: Date | null
  }

  export type PersonalityResponseCountAggregateOutputType = {
    id: number
    assessment_id: number
    question_id: number
    question_text: number
    dimension: number
    response_value: number
    created_at: number
    _all: number
  }


  export type PersonalityResponseAvgAggregateInputType = {
    response_value?: true
  }

  export type PersonalityResponseSumAggregateInputType = {
    response_value?: true
  }

  export type PersonalityResponseMinAggregateInputType = {
    id?: true
    assessment_id?: true
    question_id?: true
    question_text?: true
    dimension?: true
    response_value?: true
    created_at?: true
  }

  export type PersonalityResponseMaxAggregateInputType = {
    id?: true
    assessment_id?: true
    question_id?: true
    question_text?: true
    dimension?: true
    response_value?: true
    created_at?: true
  }

  export type PersonalityResponseCountAggregateInputType = {
    id?: true
    assessment_id?: true
    question_id?: true
    question_text?: true
    dimension?: true
    response_value?: true
    created_at?: true
    _all?: true
  }

  export type PersonalityResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalityResponse to aggregate.
     */
    where?: PersonalityResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalityResponses to fetch.
     */
    orderBy?: PersonalityResponseOrderByWithRelationInput | PersonalityResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalityResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalityResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalityResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonalityResponses
    **/
    _count?: true | PersonalityResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonalityResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonalityResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalityResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalityResponseMaxAggregateInputType
  }

  export type GetPersonalityResponseAggregateType<T extends PersonalityResponseAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalityResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalityResponse[P]>
      : GetScalarType<T[P], AggregatePersonalityResponse[P]>
  }




  export type PersonalityResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalityResponseWhereInput
    orderBy?: PersonalityResponseOrderByWithAggregationInput | PersonalityResponseOrderByWithAggregationInput[]
    by: PersonalityResponseScalarFieldEnum[] | PersonalityResponseScalarFieldEnum
    having?: PersonalityResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalityResponseCountAggregateInputType | true
    _avg?: PersonalityResponseAvgAggregateInputType
    _sum?: PersonalityResponseSumAggregateInputType
    _min?: PersonalityResponseMinAggregateInputType
    _max?: PersonalityResponseMaxAggregateInputType
  }

  export type PersonalityResponseGroupByOutputType = {
    id: string
    assessment_id: string
    question_id: string
    question_text: string
    dimension: string
    response_value: number
    created_at: Date
    _count: PersonalityResponseCountAggregateOutputType | null
    _avg: PersonalityResponseAvgAggregateOutputType | null
    _sum: PersonalityResponseSumAggregateOutputType | null
    _min: PersonalityResponseMinAggregateOutputType | null
    _max: PersonalityResponseMaxAggregateOutputType | null
  }

  type GetPersonalityResponseGroupByPayload<T extends PersonalityResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalityResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalityResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalityResponseGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalityResponseGroupByOutputType[P]>
        }
      >
    >


  export type PersonalityResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessment_id?: boolean
    question_id?: boolean
    question_text?: boolean
    dimension?: boolean
    response_value?: boolean
    created_at?: boolean
    assessment?: boolean | PersonalityAssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalityResponse"]>

  export type PersonalityResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessment_id?: boolean
    question_id?: boolean
    question_text?: boolean
    dimension?: boolean
    response_value?: boolean
    created_at?: boolean
    assessment?: boolean | PersonalityAssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalityResponse"]>

  export type PersonalityResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessment_id?: boolean
    question_id?: boolean
    question_text?: boolean
    dimension?: boolean
    response_value?: boolean
    created_at?: boolean
    assessment?: boolean | PersonalityAssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalityResponse"]>

  export type PersonalityResponseSelectScalar = {
    id?: boolean
    assessment_id?: boolean
    question_id?: boolean
    question_text?: boolean
    dimension?: boolean
    response_value?: boolean
    created_at?: boolean
  }

  export type PersonalityResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assessment_id" | "question_id" | "question_text" | "dimension" | "response_value" | "created_at", ExtArgs["result"]["personalityResponse"]>
  export type PersonalityResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessment?: boolean | PersonalityAssessmentDefaultArgs<ExtArgs>
  }
  export type PersonalityResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessment?: boolean | PersonalityAssessmentDefaultArgs<ExtArgs>
  }
  export type PersonalityResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessment?: boolean | PersonalityAssessmentDefaultArgs<ExtArgs>
  }

  export type $PersonalityResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonalityResponse"
    objects: {
      assessment: Prisma.$PersonalityAssessmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assessment_id: string
      question_id: string
      question_text: string
      dimension: string
      response_value: number
      created_at: Date
    }, ExtArgs["result"]["personalityResponse"]>
    composites: {}
  }

  type PersonalityResponseGetPayload<S extends boolean | null | undefined | PersonalityResponseDefaultArgs> = $Result.GetResult<Prisma.$PersonalityResponsePayload, S>

  type PersonalityResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonalityResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonalityResponseCountAggregateInputType | true
    }

  export interface PersonalityResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonalityResponse'], meta: { name: 'PersonalityResponse' } }
    /**
     * Find zero or one PersonalityResponse that matches the filter.
     * @param {PersonalityResponseFindUniqueArgs} args - Arguments to find a PersonalityResponse
     * @example
     * // Get one PersonalityResponse
     * const personalityResponse = await prisma.personalityResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonalityResponseFindUniqueArgs>(args: SelectSubset<T, PersonalityResponseFindUniqueArgs<ExtArgs>>): Prisma__PersonalityResponseClient<$Result.GetResult<Prisma.$PersonalityResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonalityResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonalityResponseFindUniqueOrThrowArgs} args - Arguments to find a PersonalityResponse
     * @example
     * // Get one PersonalityResponse
     * const personalityResponse = await prisma.personalityResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonalityResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonalityResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonalityResponseClient<$Result.GetResult<Prisma.$PersonalityResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalityResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityResponseFindFirstArgs} args - Arguments to find a PersonalityResponse
     * @example
     * // Get one PersonalityResponse
     * const personalityResponse = await prisma.personalityResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonalityResponseFindFirstArgs>(args?: SelectSubset<T, PersonalityResponseFindFirstArgs<ExtArgs>>): Prisma__PersonalityResponseClient<$Result.GetResult<Prisma.$PersonalityResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalityResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityResponseFindFirstOrThrowArgs} args - Arguments to find a PersonalityResponse
     * @example
     * // Get one PersonalityResponse
     * const personalityResponse = await prisma.personalityResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonalityResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonalityResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonalityResponseClient<$Result.GetResult<Prisma.$PersonalityResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonalityResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonalityResponses
     * const personalityResponses = await prisma.personalityResponse.findMany()
     * 
     * // Get first 10 PersonalityResponses
     * const personalityResponses = await prisma.personalityResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalityResponseWithIdOnly = await prisma.personalityResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonalityResponseFindManyArgs>(args?: SelectSubset<T, PersonalityResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalityResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonalityResponse.
     * @param {PersonalityResponseCreateArgs} args - Arguments to create a PersonalityResponse.
     * @example
     * // Create one PersonalityResponse
     * const PersonalityResponse = await prisma.personalityResponse.create({
     *   data: {
     *     // ... data to create a PersonalityResponse
     *   }
     * })
     * 
     */
    create<T extends PersonalityResponseCreateArgs>(args: SelectSubset<T, PersonalityResponseCreateArgs<ExtArgs>>): Prisma__PersonalityResponseClient<$Result.GetResult<Prisma.$PersonalityResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonalityResponses.
     * @param {PersonalityResponseCreateManyArgs} args - Arguments to create many PersonalityResponses.
     * @example
     * // Create many PersonalityResponses
     * const personalityResponse = await prisma.personalityResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonalityResponseCreateManyArgs>(args?: SelectSubset<T, PersonalityResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonalityResponses and returns the data saved in the database.
     * @param {PersonalityResponseCreateManyAndReturnArgs} args - Arguments to create many PersonalityResponses.
     * @example
     * // Create many PersonalityResponses
     * const personalityResponse = await prisma.personalityResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonalityResponses and only return the `id`
     * const personalityResponseWithIdOnly = await prisma.personalityResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonalityResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonalityResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalityResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersonalityResponse.
     * @param {PersonalityResponseDeleteArgs} args - Arguments to delete one PersonalityResponse.
     * @example
     * // Delete one PersonalityResponse
     * const PersonalityResponse = await prisma.personalityResponse.delete({
     *   where: {
     *     // ... filter to delete one PersonalityResponse
     *   }
     * })
     * 
     */
    delete<T extends PersonalityResponseDeleteArgs>(args: SelectSubset<T, PersonalityResponseDeleteArgs<ExtArgs>>): Prisma__PersonalityResponseClient<$Result.GetResult<Prisma.$PersonalityResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonalityResponse.
     * @param {PersonalityResponseUpdateArgs} args - Arguments to update one PersonalityResponse.
     * @example
     * // Update one PersonalityResponse
     * const personalityResponse = await prisma.personalityResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonalityResponseUpdateArgs>(args: SelectSubset<T, PersonalityResponseUpdateArgs<ExtArgs>>): Prisma__PersonalityResponseClient<$Result.GetResult<Prisma.$PersonalityResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonalityResponses.
     * @param {PersonalityResponseDeleteManyArgs} args - Arguments to filter PersonalityResponses to delete.
     * @example
     * // Delete a few PersonalityResponses
     * const { count } = await prisma.personalityResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonalityResponseDeleteManyArgs>(args?: SelectSubset<T, PersonalityResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalityResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonalityResponses
     * const personalityResponse = await prisma.personalityResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonalityResponseUpdateManyArgs>(args: SelectSubset<T, PersonalityResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalityResponses and returns the data updated in the database.
     * @param {PersonalityResponseUpdateManyAndReturnArgs} args - Arguments to update many PersonalityResponses.
     * @example
     * // Update many PersonalityResponses
     * const personalityResponse = await prisma.personalityResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersonalityResponses and only return the `id`
     * const personalityResponseWithIdOnly = await prisma.personalityResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonalityResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonalityResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalityResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersonalityResponse.
     * @param {PersonalityResponseUpsertArgs} args - Arguments to update or create a PersonalityResponse.
     * @example
     * // Update or create a PersonalityResponse
     * const personalityResponse = await prisma.personalityResponse.upsert({
     *   create: {
     *     // ... data to create a PersonalityResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonalityResponse we want to update
     *   }
     * })
     */
    upsert<T extends PersonalityResponseUpsertArgs>(args: SelectSubset<T, PersonalityResponseUpsertArgs<ExtArgs>>): Prisma__PersonalityResponseClient<$Result.GetResult<Prisma.$PersonalityResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonalityResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityResponseCountArgs} args - Arguments to filter PersonalityResponses to count.
     * @example
     * // Count the number of PersonalityResponses
     * const count = await prisma.personalityResponse.count({
     *   where: {
     *     // ... the filter for the PersonalityResponses we want to count
     *   }
     * })
    **/
    count<T extends PersonalityResponseCountArgs>(
      args?: Subset<T, PersonalityResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalityResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonalityResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalityResponseAggregateArgs>(args: Subset<T, PersonalityResponseAggregateArgs>): Prisma.PrismaPromise<GetPersonalityResponseAggregateType<T>>

    /**
     * Group by PersonalityResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalityResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalityResponseGroupByArgs['orderBy'] }
        : { orderBy?: PersonalityResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalityResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalityResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonalityResponse model
   */
  readonly fields: PersonalityResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonalityResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonalityResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assessment<T extends PersonalityAssessmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonalityAssessmentDefaultArgs<ExtArgs>>): Prisma__PersonalityAssessmentClient<$Result.GetResult<Prisma.$PersonalityAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonalityResponse model
   */
  interface PersonalityResponseFieldRefs {
    readonly id: FieldRef<"PersonalityResponse", 'String'>
    readonly assessment_id: FieldRef<"PersonalityResponse", 'String'>
    readonly question_id: FieldRef<"PersonalityResponse", 'String'>
    readonly question_text: FieldRef<"PersonalityResponse", 'String'>
    readonly dimension: FieldRef<"PersonalityResponse", 'String'>
    readonly response_value: FieldRef<"PersonalityResponse", 'Int'>
    readonly created_at: FieldRef<"PersonalityResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PersonalityResponse findUnique
   */
  export type PersonalityResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityResponse
     */
    select?: PersonalityResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityResponse
     */
    omit?: PersonalityResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityResponseInclude<ExtArgs> | null
    /**
     * Filter, which PersonalityResponse to fetch.
     */
    where: PersonalityResponseWhereUniqueInput
  }

  /**
   * PersonalityResponse findUniqueOrThrow
   */
  export type PersonalityResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityResponse
     */
    select?: PersonalityResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityResponse
     */
    omit?: PersonalityResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityResponseInclude<ExtArgs> | null
    /**
     * Filter, which PersonalityResponse to fetch.
     */
    where: PersonalityResponseWhereUniqueInput
  }

  /**
   * PersonalityResponse findFirst
   */
  export type PersonalityResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityResponse
     */
    select?: PersonalityResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityResponse
     */
    omit?: PersonalityResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityResponseInclude<ExtArgs> | null
    /**
     * Filter, which PersonalityResponse to fetch.
     */
    where?: PersonalityResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalityResponses to fetch.
     */
    orderBy?: PersonalityResponseOrderByWithRelationInput | PersonalityResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalityResponses.
     */
    cursor?: PersonalityResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalityResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalityResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalityResponses.
     */
    distinct?: PersonalityResponseScalarFieldEnum | PersonalityResponseScalarFieldEnum[]
  }

  /**
   * PersonalityResponse findFirstOrThrow
   */
  export type PersonalityResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityResponse
     */
    select?: PersonalityResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityResponse
     */
    omit?: PersonalityResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityResponseInclude<ExtArgs> | null
    /**
     * Filter, which PersonalityResponse to fetch.
     */
    where?: PersonalityResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalityResponses to fetch.
     */
    orderBy?: PersonalityResponseOrderByWithRelationInput | PersonalityResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalityResponses.
     */
    cursor?: PersonalityResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalityResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalityResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalityResponses.
     */
    distinct?: PersonalityResponseScalarFieldEnum | PersonalityResponseScalarFieldEnum[]
  }

  /**
   * PersonalityResponse findMany
   */
  export type PersonalityResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityResponse
     */
    select?: PersonalityResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityResponse
     */
    omit?: PersonalityResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityResponseInclude<ExtArgs> | null
    /**
     * Filter, which PersonalityResponses to fetch.
     */
    where?: PersonalityResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalityResponses to fetch.
     */
    orderBy?: PersonalityResponseOrderByWithRelationInput | PersonalityResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonalityResponses.
     */
    cursor?: PersonalityResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalityResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalityResponses.
     */
    skip?: number
    distinct?: PersonalityResponseScalarFieldEnum | PersonalityResponseScalarFieldEnum[]
  }

  /**
   * PersonalityResponse create
   */
  export type PersonalityResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityResponse
     */
    select?: PersonalityResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityResponse
     */
    omit?: PersonalityResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonalityResponse.
     */
    data: XOR<PersonalityResponseCreateInput, PersonalityResponseUncheckedCreateInput>
  }

  /**
   * PersonalityResponse createMany
   */
  export type PersonalityResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonalityResponses.
     */
    data: PersonalityResponseCreateManyInput | PersonalityResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonalityResponse createManyAndReturn
   */
  export type PersonalityResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityResponse
     */
    select?: PersonalityResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityResponse
     */
    omit?: PersonalityResponseOmit<ExtArgs> | null
    /**
     * The data used to create many PersonalityResponses.
     */
    data: PersonalityResponseCreateManyInput | PersonalityResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalityResponse update
   */
  export type PersonalityResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityResponse
     */
    select?: PersonalityResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityResponse
     */
    omit?: PersonalityResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonalityResponse.
     */
    data: XOR<PersonalityResponseUpdateInput, PersonalityResponseUncheckedUpdateInput>
    /**
     * Choose, which PersonalityResponse to update.
     */
    where: PersonalityResponseWhereUniqueInput
  }

  /**
   * PersonalityResponse updateMany
   */
  export type PersonalityResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonalityResponses.
     */
    data: XOR<PersonalityResponseUpdateManyMutationInput, PersonalityResponseUncheckedUpdateManyInput>
    /**
     * Filter which PersonalityResponses to update
     */
    where?: PersonalityResponseWhereInput
    /**
     * Limit how many PersonalityResponses to update.
     */
    limit?: number
  }

  /**
   * PersonalityResponse updateManyAndReturn
   */
  export type PersonalityResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityResponse
     */
    select?: PersonalityResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityResponse
     */
    omit?: PersonalityResponseOmit<ExtArgs> | null
    /**
     * The data used to update PersonalityResponses.
     */
    data: XOR<PersonalityResponseUpdateManyMutationInput, PersonalityResponseUncheckedUpdateManyInput>
    /**
     * Filter which PersonalityResponses to update
     */
    where?: PersonalityResponseWhereInput
    /**
     * Limit how many PersonalityResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalityResponse upsert
   */
  export type PersonalityResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityResponse
     */
    select?: PersonalityResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityResponse
     */
    omit?: PersonalityResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonalityResponse to update in case it exists.
     */
    where: PersonalityResponseWhereUniqueInput
    /**
     * In case the PersonalityResponse found by the `where` argument doesn't exist, create a new PersonalityResponse with this data.
     */
    create: XOR<PersonalityResponseCreateInput, PersonalityResponseUncheckedCreateInput>
    /**
     * In case the PersonalityResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalityResponseUpdateInput, PersonalityResponseUncheckedUpdateInput>
  }

  /**
   * PersonalityResponse delete
   */
  export type PersonalityResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityResponse
     */
    select?: PersonalityResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityResponse
     */
    omit?: PersonalityResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityResponseInclude<ExtArgs> | null
    /**
     * Filter which PersonalityResponse to delete.
     */
    where: PersonalityResponseWhereUniqueInput
  }

  /**
   * PersonalityResponse deleteMany
   */
  export type PersonalityResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalityResponses to delete
     */
    where?: PersonalityResponseWhereInput
    /**
     * Limit how many PersonalityResponses to delete.
     */
    limit?: number
  }

  /**
   * PersonalityResponse without action
   */
  export type PersonalityResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityResponse
     */
    select?: PersonalityResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalityResponse
     */
    omit?: PersonalityResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityResponseInclude<ExtArgs> | null
  }


  /**
   * Model AppAdmin
   */

  export type AggregateAppAdmin = {
    _count: AppAdminCountAggregateOutputType | null
    _avg: AppAdminAvgAggregateOutputType | null
    _sum: AppAdminSumAggregateOutputType | null
    _min: AppAdminMinAggregateOutputType | null
    _max: AppAdminMaxAggregateOutputType | null
  }

  export type AppAdminAvgAggregateOutputType = {
    access_level: number | null
    login_count: number | null
    failed_login_attempts: number | null
  }

  export type AppAdminSumAggregateOutputType = {
    access_level: number | null
    login_count: number | null
    failed_login_attempts: number | null
  }

  export type AppAdminMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    role: string | null
    is_active: boolean | null
    email: string | null
    full_name: string | null
    department: string | null
    access_level: number | null
    last_login_at: Date | null
    last_activity_at: Date | null
    login_count: number | null
    failed_login_attempts: number | null
    account_locked_until: Date | null
    must_change_password: boolean | null
    two_factor_enabled: boolean | null
    created_by: string | null
    created_at: Date | null
    updated_by: string | null
    updated_at: Date | null
    deactivated_at: Date | null
    deactivated_by: string | null
    deactivation_reason: string | null
    notes: string | null
  }

  export type AppAdminMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    role: string | null
    is_active: boolean | null
    email: string | null
    full_name: string | null
    department: string | null
    access_level: number | null
    last_login_at: Date | null
    last_activity_at: Date | null
    login_count: number | null
    failed_login_attempts: number | null
    account_locked_until: Date | null
    must_change_password: boolean | null
    two_factor_enabled: boolean | null
    created_by: string | null
    created_at: Date | null
    updated_by: string | null
    updated_at: Date | null
    deactivated_at: Date | null
    deactivated_by: string | null
    deactivation_reason: string | null
    notes: string | null
  }

  export type AppAdminCountAggregateOutputType = {
    id: number
    user_id: number
    role: number
    permissions: number
    is_active: number
    email: number
    full_name: number
    department: number
    access_level: number
    allowed_actions: number
    restricted_actions: number
    last_login_at: number
    last_activity_at: number
    login_count: number
    failed_login_attempts: number
    account_locked_until: number
    must_change_password: number
    two_factor_enabled: number
    created_by: number
    created_at: number
    updated_by: number
    updated_at: number
    deactivated_at: number
    deactivated_by: number
    deactivation_reason: number
    notes: number
    metadata: number
    _all: number
  }


  export type AppAdminAvgAggregateInputType = {
    access_level?: true
    login_count?: true
    failed_login_attempts?: true
  }

  export type AppAdminSumAggregateInputType = {
    access_level?: true
    login_count?: true
    failed_login_attempts?: true
  }

  export type AppAdminMinAggregateInputType = {
    id?: true
    user_id?: true
    role?: true
    is_active?: true
    email?: true
    full_name?: true
    department?: true
    access_level?: true
    last_login_at?: true
    last_activity_at?: true
    login_count?: true
    failed_login_attempts?: true
    account_locked_until?: true
    must_change_password?: true
    two_factor_enabled?: true
    created_by?: true
    created_at?: true
    updated_by?: true
    updated_at?: true
    deactivated_at?: true
    deactivated_by?: true
    deactivation_reason?: true
    notes?: true
  }

  export type AppAdminMaxAggregateInputType = {
    id?: true
    user_id?: true
    role?: true
    is_active?: true
    email?: true
    full_name?: true
    department?: true
    access_level?: true
    last_login_at?: true
    last_activity_at?: true
    login_count?: true
    failed_login_attempts?: true
    account_locked_until?: true
    must_change_password?: true
    two_factor_enabled?: true
    created_by?: true
    created_at?: true
    updated_by?: true
    updated_at?: true
    deactivated_at?: true
    deactivated_by?: true
    deactivation_reason?: true
    notes?: true
  }

  export type AppAdminCountAggregateInputType = {
    id?: true
    user_id?: true
    role?: true
    permissions?: true
    is_active?: true
    email?: true
    full_name?: true
    department?: true
    access_level?: true
    allowed_actions?: true
    restricted_actions?: true
    last_login_at?: true
    last_activity_at?: true
    login_count?: true
    failed_login_attempts?: true
    account_locked_until?: true
    must_change_password?: true
    two_factor_enabled?: true
    created_by?: true
    created_at?: true
    updated_by?: true
    updated_at?: true
    deactivated_at?: true
    deactivated_by?: true
    deactivation_reason?: true
    notes?: true
    metadata?: true
    _all?: true
  }

  export type AppAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppAdmin to aggregate.
     */
    where?: AppAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppAdmins to fetch.
     */
    orderBy?: AppAdminOrderByWithRelationInput | AppAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppAdmins
    **/
    _count?: true | AppAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppAdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppAdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppAdminMaxAggregateInputType
  }

  export type GetAppAdminAggregateType<T extends AppAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAppAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppAdmin[P]>
      : GetScalarType<T[P], AggregateAppAdmin[P]>
  }




  export type AppAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppAdminWhereInput
    orderBy?: AppAdminOrderByWithAggregationInput | AppAdminOrderByWithAggregationInput[]
    by: AppAdminScalarFieldEnum[] | AppAdminScalarFieldEnum
    having?: AppAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppAdminCountAggregateInputType | true
    _avg?: AppAdminAvgAggregateInputType
    _sum?: AppAdminSumAggregateInputType
    _min?: AppAdminMinAggregateInputType
    _max?: AppAdminMaxAggregateInputType
  }

  export type AppAdminGroupByOutputType = {
    id: string
    user_id: string
    role: string
    permissions: string[]
    is_active: boolean
    email: string
    full_name: string | null
    department: string | null
    access_level: number
    allowed_actions: string[]
    restricted_actions: string[]
    last_login_at: Date | null
    last_activity_at: Date | null
    login_count: number
    failed_login_attempts: number
    account_locked_until: Date | null
    must_change_password: boolean
    two_factor_enabled: boolean
    created_by: string | null
    created_at: Date
    updated_by: string | null
    updated_at: Date
    deactivated_at: Date | null
    deactivated_by: string | null
    deactivation_reason: string | null
    notes: string | null
    metadata: JsonValue | null
    _count: AppAdminCountAggregateOutputType | null
    _avg: AppAdminAvgAggregateOutputType | null
    _sum: AppAdminSumAggregateOutputType | null
    _min: AppAdminMinAggregateOutputType | null
    _max: AppAdminMaxAggregateOutputType | null
  }

  type GetAppAdminGroupByPayload<T extends AppAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppAdminGroupByOutputType[P]>
            : GetScalarType<T[P], AppAdminGroupByOutputType[P]>
        }
      >
    >


  export type AppAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    role?: boolean
    permissions?: boolean
    is_active?: boolean
    email?: boolean
    full_name?: boolean
    department?: boolean
    access_level?: boolean
    allowed_actions?: boolean
    restricted_actions?: boolean
    last_login_at?: boolean
    last_activity_at?: boolean
    login_count?: boolean
    failed_login_attempts?: boolean
    account_locked_until?: boolean
    must_change_password?: boolean
    two_factor_enabled?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_by?: boolean
    updated_at?: boolean
    deactivated_at?: boolean
    deactivated_by?: boolean
    deactivation_reason?: boolean
    notes?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["appAdmin"]>

  export type AppAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    role?: boolean
    permissions?: boolean
    is_active?: boolean
    email?: boolean
    full_name?: boolean
    department?: boolean
    access_level?: boolean
    allowed_actions?: boolean
    restricted_actions?: boolean
    last_login_at?: boolean
    last_activity_at?: boolean
    login_count?: boolean
    failed_login_attempts?: boolean
    account_locked_until?: boolean
    must_change_password?: boolean
    two_factor_enabled?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_by?: boolean
    updated_at?: boolean
    deactivated_at?: boolean
    deactivated_by?: boolean
    deactivation_reason?: boolean
    notes?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["appAdmin"]>

  export type AppAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    role?: boolean
    permissions?: boolean
    is_active?: boolean
    email?: boolean
    full_name?: boolean
    department?: boolean
    access_level?: boolean
    allowed_actions?: boolean
    restricted_actions?: boolean
    last_login_at?: boolean
    last_activity_at?: boolean
    login_count?: boolean
    failed_login_attempts?: boolean
    account_locked_until?: boolean
    must_change_password?: boolean
    two_factor_enabled?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_by?: boolean
    updated_at?: boolean
    deactivated_at?: boolean
    deactivated_by?: boolean
    deactivation_reason?: boolean
    notes?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["appAdmin"]>

  export type AppAdminSelectScalar = {
    id?: boolean
    user_id?: boolean
    role?: boolean
    permissions?: boolean
    is_active?: boolean
    email?: boolean
    full_name?: boolean
    department?: boolean
    access_level?: boolean
    allowed_actions?: boolean
    restricted_actions?: boolean
    last_login_at?: boolean
    last_activity_at?: boolean
    login_count?: boolean
    failed_login_attempts?: boolean
    account_locked_until?: boolean
    must_change_password?: boolean
    two_factor_enabled?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_by?: boolean
    updated_at?: boolean
    deactivated_at?: boolean
    deactivated_by?: boolean
    deactivation_reason?: boolean
    notes?: boolean
    metadata?: boolean
  }

  export type AppAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "role" | "permissions" | "is_active" | "email" | "full_name" | "department" | "access_level" | "allowed_actions" | "restricted_actions" | "last_login_at" | "last_activity_at" | "login_count" | "failed_login_attempts" | "account_locked_until" | "must_change_password" | "two_factor_enabled" | "created_by" | "created_at" | "updated_by" | "updated_at" | "deactivated_at" | "deactivated_by" | "deactivation_reason" | "notes" | "metadata", ExtArgs["result"]["appAdmin"]>

  export type $AppAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppAdmin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      role: string
      permissions: string[]
      is_active: boolean
      email: string
      full_name: string | null
      department: string | null
      access_level: number
      allowed_actions: string[]
      restricted_actions: string[]
      last_login_at: Date | null
      last_activity_at: Date | null
      login_count: number
      failed_login_attempts: number
      account_locked_until: Date | null
      must_change_password: boolean
      two_factor_enabled: boolean
      created_by: string | null
      created_at: Date
      updated_by: string | null
      updated_at: Date
      deactivated_at: Date | null
      deactivated_by: string | null
      deactivation_reason: string | null
      notes: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["appAdmin"]>
    composites: {}
  }

  type AppAdminGetPayload<S extends boolean | null | undefined | AppAdminDefaultArgs> = $Result.GetResult<Prisma.$AppAdminPayload, S>

  type AppAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppAdminCountAggregateInputType | true
    }

  export interface AppAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppAdmin'], meta: { name: 'AppAdmin' } }
    /**
     * Find zero or one AppAdmin that matches the filter.
     * @param {AppAdminFindUniqueArgs} args - Arguments to find a AppAdmin
     * @example
     * // Get one AppAdmin
     * const appAdmin = await prisma.appAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppAdminFindUniqueArgs>(args: SelectSubset<T, AppAdminFindUniqueArgs<ExtArgs>>): Prisma__AppAdminClient<$Result.GetResult<Prisma.$AppAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppAdminFindUniqueOrThrowArgs} args - Arguments to find a AppAdmin
     * @example
     * // Get one AppAdmin
     * const appAdmin = await prisma.appAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AppAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppAdminClient<$Result.GetResult<Prisma.$AppAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppAdminFindFirstArgs} args - Arguments to find a AppAdmin
     * @example
     * // Get one AppAdmin
     * const appAdmin = await prisma.appAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppAdminFindFirstArgs>(args?: SelectSubset<T, AppAdminFindFirstArgs<ExtArgs>>): Prisma__AppAdminClient<$Result.GetResult<Prisma.$AppAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppAdminFindFirstOrThrowArgs} args - Arguments to find a AppAdmin
     * @example
     * // Get one AppAdmin
     * const appAdmin = await prisma.appAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AppAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppAdminClient<$Result.GetResult<Prisma.$AppAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppAdmins
     * const appAdmins = await prisma.appAdmin.findMany()
     * 
     * // Get first 10 AppAdmins
     * const appAdmins = await prisma.appAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appAdminWithIdOnly = await prisma.appAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppAdminFindManyArgs>(args?: SelectSubset<T, AppAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppAdmin.
     * @param {AppAdminCreateArgs} args - Arguments to create a AppAdmin.
     * @example
     * // Create one AppAdmin
     * const AppAdmin = await prisma.appAdmin.create({
     *   data: {
     *     // ... data to create a AppAdmin
     *   }
     * })
     * 
     */
    create<T extends AppAdminCreateArgs>(args: SelectSubset<T, AppAdminCreateArgs<ExtArgs>>): Prisma__AppAdminClient<$Result.GetResult<Prisma.$AppAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppAdmins.
     * @param {AppAdminCreateManyArgs} args - Arguments to create many AppAdmins.
     * @example
     * // Create many AppAdmins
     * const appAdmin = await prisma.appAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppAdminCreateManyArgs>(args?: SelectSubset<T, AppAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppAdmins and returns the data saved in the database.
     * @param {AppAdminCreateManyAndReturnArgs} args - Arguments to create many AppAdmins.
     * @example
     * // Create many AppAdmins
     * const appAdmin = await prisma.appAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppAdmins and only return the `id`
     * const appAdminWithIdOnly = await prisma.appAdmin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AppAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppAdmin.
     * @param {AppAdminDeleteArgs} args - Arguments to delete one AppAdmin.
     * @example
     * // Delete one AppAdmin
     * const AppAdmin = await prisma.appAdmin.delete({
     *   where: {
     *     // ... filter to delete one AppAdmin
     *   }
     * })
     * 
     */
    delete<T extends AppAdminDeleteArgs>(args: SelectSubset<T, AppAdminDeleteArgs<ExtArgs>>): Prisma__AppAdminClient<$Result.GetResult<Prisma.$AppAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppAdmin.
     * @param {AppAdminUpdateArgs} args - Arguments to update one AppAdmin.
     * @example
     * // Update one AppAdmin
     * const appAdmin = await prisma.appAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppAdminUpdateArgs>(args: SelectSubset<T, AppAdminUpdateArgs<ExtArgs>>): Prisma__AppAdminClient<$Result.GetResult<Prisma.$AppAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppAdmins.
     * @param {AppAdminDeleteManyArgs} args - Arguments to filter AppAdmins to delete.
     * @example
     * // Delete a few AppAdmins
     * const { count } = await prisma.appAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppAdminDeleteManyArgs>(args?: SelectSubset<T, AppAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppAdmins
     * const appAdmin = await prisma.appAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppAdminUpdateManyArgs>(args: SelectSubset<T, AppAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppAdmins and returns the data updated in the database.
     * @param {AppAdminUpdateManyAndReturnArgs} args - Arguments to update many AppAdmins.
     * @example
     * // Update many AppAdmins
     * const appAdmin = await prisma.appAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppAdmins and only return the `id`
     * const appAdminWithIdOnly = await prisma.appAdmin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AppAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppAdmin.
     * @param {AppAdminUpsertArgs} args - Arguments to update or create a AppAdmin.
     * @example
     * // Update or create a AppAdmin
     * const appAdmin = await prisma.appAdmin.upsert({
     *   create: {
     *     // ... data to create a AppAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppAdmin we want to update
     *   }
     * })
     */
    upsert<T extends AppAdminUpsertArgs>(args: SelectSubset<T, AppAdminUpsertArgs<ExtArgs>>): Prisma__AppAdminClient<$Result.GetResult<Prisma.$AppAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppAdminCountArgs} args - Arguments to filter AppAdmins to count.
     * @example
     * // Count the number of AppAdmins
     * const count = await prisma.appAdmin.count({
     *   where: {
     *     // ... the filter for the AppAdmins we want to count
     *   }
     * })
    **/
    count<T extends AppAdminCountArgs>(
      args?: Subset<T, AppAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppAdminAggregateArgs>(args: Subset<T, AppAdminAggregateArgs>): Prisma.PrismaPromise<GetAppAdminAggregateType<T>>

    /**
     * Group by AppAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppAdminGroupByArgs['orderBy'] }
        : { orderBy?: AppAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppAdmin model
   */
  readonly fields: AppAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppAdmin model
   */
  interface AppAdminFieldRefs {
    readonly id: FieldRef<"AppAdmin", 'String'>
    readonly user_id: FieldRef<"AppAdmin", 'String'>
    readonly role: FieldRef<"AppAdmin", 'String'>
    readonly permissions: FieldRef<"AppAdmin", 'String[]'>
    readonly is_active: FieldRef<"AppAdmin", 'Boolean'>
    readonly email: FieldRef<"AppAdmin", 'String'>
    readonly full_name: FieldRef<"AppAdmin", 'String'>
    readonly department: FieldRef<"AppAdmin", 'String'>
    readonly access_level: FieldRef<"AppAdmin", 'Int'>
    readonly allowed_actions: FieldRef<"AppAdmin", 'String[]'>
    readonly restricted_actions: FieldRef<"AppAdmin", 'String[]'>
    readonly last_login_at: FieldRef<"AppAdmin", 'DateTime'>
    readonly last_activity_at: FieldRef<"AppAdmin", 'DateTime'>
    readonly login_count: FieldRef<"AppAdmin", 'Int'>
    readonly failed_login_attempts: FieldRef<"AppAdmin", 'Int'>
    readonly account_locked_until: FieldRef<"AppAdmin", 'DateTime'>
    readonly must_change_password: FieldRef<"AppAdmin", 'Boolean'>
    readonly two_factor_enabled: FieldRef<"AppAdmin", 'Boolean'>
    readonly created_by: FieldRef<"AppAdmin", 'String'>
    readonly created_at: FieldRef<"AppAdmin", 'DateTime'>
    readonly updated_by: FieldRef<"AppAdmin", 'String'>
    readonly updated_at: FieldRef<"AppAdmin", 'DateTime'>
    readonly deactivated_at: FieldRef<"AppAdmin", 'DateTime'>
    readonly deactivated_by: FieldRef<"AppAdmin", 'String'>
    readonly deactivation_reason: FieldRef<"AppAdmin", 'String'>
    readonly notes: FieldRef<"AppAdmin", 'String'>
    readonly metadata: FieldRef<"AppAdmin", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AppAdmin findUnique
   */
  export type AppAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppAdmin
     */
    select?: AppAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppAdmin
     */
    omit?: AppAdminOmit<ExtArgs> | null
    /**
     * Filter, which AppAdmin to fetch.
     */
    where: AppAdminWhereUniqueInput
  }

  /**
   * AppAdmin findUniqueOrThrow
   */
  export type AppAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppAdmin
     */
    select?: AppAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppAdmin
     */
    omit?: AppAdminOmit<ExtArgs> | null
    /**
     * Filter, which AppAdmin to fetch.
     */
    where: AppAdminWhereUniqueInput
  }

  /**
   * AppAdmin findFirst
   */
  export type AppAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppAdmin
     */
    select?: AppAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppAdmin
     */
    omit?: AppAdminOmit<ExtArgs> | null
    /**
     * Filter, which AppAdmin to fetch.
     */
    where?: AppAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppAdmins to fetch.
     */
    orderBy?: AppAdminOrderByWithRelationInput | AppAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppAdmins.
     */
    cursor?: AppAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppAdmins.
     */
    distinct?: AppAdminScalarFieldEnum | AppAdminScalarFieldEnum[]
  }

  /**
   * AppAdmin findFirstOrThrow
   */
  export type AppAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppAdmin
     */
    select?: AppAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppAdmin
     */
    omit?: AppAdminOmit<ExtArgs> | null
    /**
     * Filter, which AppAdmin to fetch.
     */
    where?: AppAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppAdmins to fetch.
     */
    orderBy?: AppAdminOrderByWithRelationInput | AppAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppAdmins.
     */
    cursor?: AppAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppAdmins.
     */
    distinct?: AppAdminScalarFieldEnum | AppAdminScalarFieldEnum[]
  }

  /**
   * AppAdmin findMany
   */
  export type AppAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppAdmin
     */
    select?: AppAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppAdmin
     */
    omit?: AppAdminOmit<ExtArgs> | null
    /**
     * Filter, which AppAdmins to fetch.
     */
    where?: AppAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppAdmins to fetch.
     */
    orderBy?: AppAdminOrderByWithRelationInput | AppAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppAdmins.
     */
    cursor?: AppAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppAdmins.
     */
    skip?: number
    distinct?: AppAdminScalarFieldEnum | AppAdminScalarFieldEnum[]
  }

  /**
   * AppAdmin create
   */
  export type AppAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppAdmin
     */
    select?: AppAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppAdmin
     */
    omit?: AppAdminOmit<ExtArgs> | null
    /**
     * The data needed to create a AppAdmin.
     */
    data: XOR<AppAdminCreateInput, AppAdminUncheckedCreateInput>
  }

  /**
   * AppAdmin createMany
   */
  export type AppAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppAdmins.
     */
    data: AppAdminCreateManyInput | AppAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppAdmin createManyAndReturn
   */
  export type AppAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppAdmin
     */
    select?: AppAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppAdmin
     */
    omit?: AppAdminOmit<ExtArgs> | null
    /**
     * The data used to create many AppAdmins.
     */
    data: AppAdminCreateManyInput | AppAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppAdmin update
   */
  export type AppAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppAdmin
     */
    select?: AppAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppAdmin
     */
    omit?: AppAdminOmit<ExtArgs> | null
    /**
     * The data needed to update a AppAdmin.
     */
    data: XOR<AppAdminUpdateInput, AppAdminUncheckedUpdateInput>
    /**
     * Choose, which AppAdmin to update.
     */
    where: AppAdminWhereUniqueInput
  }

  /**
   * AppAdmin updateMany
   */
  export type AppAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppAdmins.
     */
    data: XOR<AppAdminUpdateManyMutationInput, AppAdminUncheckedUpdateManyInput>
    /**
     * Filter which AppAdmins to update
     */
    where?: AppAdminWhereInput
    /**
     * Limit how many AppAdmins to update.
     */
    limit?: number
  }

  /**
   * AppAdmin updateManyAndReturn
   */
  export type AppAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppAdmin
     */
    select?: AppAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppAdmin
     */
    omit?: AppAdminOmit<ExtArgs> | null
    /**
     * The data used to update AppAdmins.
     */
    data: XOR<AppAdminUpdateManyMutationInput, AppAdminUncheckedUpdateManyInput>
    /**
     * Filter which AppAdmins to update
     */
    where?: AppAdminWhereInput
    /**
     * Limit how many AppAdmins to update.
     */
    limit?: number
  }

  /**
   * AppAdmin upsert
   */
  export type AppAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppAdmin
     */
    select?: AppAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppAdmin
     */
    omit?: AppAdminOmit<ExtArgs> | null
    /**
     * The filter to search for the AppAdmin to update in case it exists.
     */
    where: AppAdminWhereUniqueInput
    /**
     * In case the AppAdmin found by the `where` argument doesn't exist, create a new AppAdmin with this data.
     */
    create: XOR<AppAdminCreateInput, AppAdminUncheckedCreateInput>
    /**
     * In case the AppAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppAdminUpdateInput, AppAdminUncheckedUpdateInput>
  }

  /**
   * AppAdmin delete
   */
  export type AppAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppAdmin
     */
    select?: AppAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppAdmin
     */
    omit?: AppAdminOmit<ExtArgs> | null
    /**
     * Filter which AppAdmin to delete.
     */
    where: AppAdminWhereUniqueInput
  }

  /**
   * AppAdmin deleteMany
   */
  export type AppAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppAdmins to delete
     */
    where?: AppAdminWhereInput
    /**
     * Limit how many AppAdmins to delete.
     */
    limit?: number
  }

  /**
   * AppAdmin without action
   */
  export type AppAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppAdmin
     */
    select?: AppAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppAdmin
     */
    omit?: AppAdminOmit<ExtArgs> | null
  }


  /**
   * Model TalentStory
   */

  export type AggregateTalentStory = {
    _count: TalentStoryCountAggregateOutputType | null
    _avg: TalentStoryAvgAggregateOutputType | null
    _sum: TalentStorySumAggregateOutputType | null
    _min: TalentStoryMinAggregateOutputType | null
    _max: TalentStoryMaxAggregateOutputType | null
  }

  export type TalentStoryAvgAggregateOutputType = {
    version: number | null
  }

  export type TalentStorySumAggregateOutputType = {
    version: number | null
  }

  export type TalentStoryMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    story: string | null
    model: string | null
    created_at: Date | null
    updated_at: Date | null
    version: number | null
    is_active: boolean | null
  }

  export type TalentStoryMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    story: string | null
    model: string | null
    created_at: Date | null
    updated_at: Date | null
    version: number | null
    is_active: boolean | null
  }

  export type TalentStoryCountAggregateOutputType = {
    id: number
    user_id: number
    story: number
    data: number
    model: number
    created_at: number
    updated_at: number
    version: number
    is_active: number
    _all: number
  }


  export type TalentStoryAvgAggregateInputType = {
    version?: true
  }

  export type TalentStorySumAggregateInputType = {
    version?: true
  }

  export type TalentStoryMinAggregateInputType = {
    id?: true
    user_id?: true
    story?: true
    model?: true
    created_at?: true
    updated_at?: true
    version?: true
    is_active?: true
  }

  export type TalentStoryMaxAggregateInputType = {
    id?: true
    user_id?: true
    story?: true
    model?: true
    created_at?: true
    updated_at?: true
    version?: true
    is_active?: true
  }

  export type TalentStoryCountAggregateInputType = {
    id?: true
    user_id?: true
    story?: true
    data?: true
    model?: true
    created_at?: true
    updated_at?: true
    version?: true
    is_active?: true
    _all?: true
  }

  export type TalentStoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TalentStory to aggregate.
     */
    where?: TalentStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TalentStories to fetch.
     */
    orderBy?: TalentStoryOrderByWithRelationInput | TalentStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TalentStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TalentStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TalentStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TalentStories
    **/
    _count?: true | TalentStoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TalentStoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TalentStorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TalentStoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TalentStoryMaxAggregateInputType
  }

  export type GetTalentStoryAggregateType<T extends TalentStoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTalentStory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTalentStory[P]>
      : GetScalarType<T[P], AggregateTalentStory[P]>
  }




  export type TalentStoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TalentStoryWhereInput
    orderBy?: TalentStoryOrderByWithAggregationInput | TalentStoryOrderByWithAggregationInput[]
    by: TalentStoryScalarFieldEnum[] | TalentStoryScalarFieldEnum
    having?: TalentStoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TalentStoryCountAggregateInputType | true
    _avg?: TalentStoryAvgAggregateInputType
    _sum?: TalentStorySumAggregateInputType
    _min?: TalentStoryMinAggregateInputType
    _max?: TalentStoryMaxAggregateInputType
  }

  export type TalentStoryGroupByOutputType = {
    id: string
    user_id: string
    story: string
    data: JsonValue
    model: string | null
    created_at: Date
    updated_at: Date
    version: number | null
    is_active: boolean
    _count: TalentStoryCountAggregateOutputType | null
    _avg: TalentStoryAvgAggregateOutputType | null
    _sum: TalentStorySumAggregateOutputType | null
    _min: TalentStoryMinAggregateOutputType | null
    _max: TalentStoryMaxAggregateOutputType | null
  }

  type GetTalentStoryGroupByPayload<T extends TalentStoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TalentStoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TalentStoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TalentStoryGroupByOutputType[P]>
            : GetScalarType<T[P], TalentStoryGroupByOutputType[P]>
        }
      >
    >


  export type TalentStorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    story?: boolean
    data?: boolean
    model?: boolean
    created_at?: boolean
    updated_at?: boolean
    version?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["talentStory"]>

  export type TalentStorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    story?: boolean
    data?: boolean
    model?: boolean
    created_at?: boolean
    updated_at?: boolean
    version?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["talentStory"]>

  export type TalentStorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    story?: boolean
    data?: boolean
    model?: boolean
    created_at?: boolean
    updated_at?: boolean
    version?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["talentStory"]>

  export type TalentStorySelectScalar = {
    id?: boolean
    user_id?: boolean
    story?: boolean
    data?: boolean
    model?: boolean
    created_at?: boolean
    updated_at?: boolean
    version?: boolean
    is_active?: boolean
  }

  export type TalentStoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "story" | "data" | "model" | "created_at" | "updated_at" | "version" | "is_active", ExtArgs["result"]["talentStory"]>

  export type $TalentStoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TalentStory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      story: string
      data: Prisma.JsonValue
      model: string | null
      created_at: Date
      updated_at: Date
      version: number | null
      is_active: boolean
    }, ExtArgs["result"]["talentStory"]>
    composites: {}
  }

  type TalentStoryGetPayload<S extends boolean | null | undefined | TalentStoryDefaultArgs> = $Result.GetResult<Prisma.$TalentStoryPayload, S>

  type TalentStoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TalentStoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TalentStoryCountAggregateInputType | true
    }

  export interface TalentStoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TalentStory'], meta: { name: 'TalentStory' } }
    /**
     * Find zero or one TalentStory that matches the filter.
     * @param {TalentStoryFindUniqueArgs} args - Arguments to find a TalentStory
     * @example
     * // Get one TalentStory
     * const talentStory = await prisma.talentStory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TalentStoryFindUniqueArgs>(args: SelectSubset<T, TalentStoryFindUniqueArgs<ExtArgs>>): Prisma__TalentStoryClient<$Result.GetResult<Prisma.$TalentStoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TalentStory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TalentStoryFindUniqueOrThrowArgs} args - Arguments to find a TalentStory
     * @example
     * // Get one TalentStory
     * const talentStory = await prisma.talentStory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TalentStoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TalentStoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TalentStoryClient<$Result.GetResult<Prisma.$TalentStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TalentStory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentStoryFindFirstArgs} args - Arguments to find a TalentStory
     * @example
     * // Get one TalentStory
     * const talentStory = await prisma.talentStory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TalentStoryFindFirstArgs>(args?: SelectSubset<T, TalentStoryFindFirstArgs<ExtArgs>>): Prisma__TalentStoryClient<$Result.GetResult<Prisma.$TalentStoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TalentStory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentStoryFindFirstOrThrowArgs} args - Arguments to find a TalentStory
     * @example
     * // Get one TalentStory
     * const talentStory = await prisma.talentStory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TalentStoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TalentStoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TalentStoryClient<$Result.GetResult<Prisma.$TalentStoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TalentStories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentStoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TalentStories
     * const talentStories = await prisma.talentStory.findMany()
     * 
     * // Get first 10 TalentStories
     * const talentStories = await prisma.talentStory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const talentStoryWithIdOnly = await prisma.talentStory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TalentStoryFindManyArgs>(args?: SelectSubset<T, TalentStoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TalentStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TalentStory.
     * @param {TalentStoryCreateArgs} args - Arguments to create a TalentStory.
     * @example
     * // Create one TalentStory
     * const TalentStory = await prisma.talentStory.create({
     *   data: {
     *     // ... data to create a TalentStory
     *   }
     * })
     * 
     */
    create<T extends TalentStoryCreateArgs>(args: SelectSubset<T, TalentStoryCreateArgs<ExtArgs>>): Prisma__TalentStoryClient<$Result.GetResult<Prisma.$TalentStoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TalentStories.
     * @param {TalentStoryCreateManyArgs} args - Arguments to create many TalentStories.
     * @example
     * // Create many TalentStories
     * const talentStory = await prisma.talentStory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TalentStoryCreateManyArgs>(args?: SelectSubset<T, TalentStoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TalentStories and returns the data saved in the database.
     * @param {TalentStoryCreateManyAndReturnArgs} args - Arguments to create many TalentStories.
     * @example
     * // Create many TalentStories
     * const talentStory = await prisma.talentStory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TalentStories and only return the `id`
     * const talentStoryWithIdOnly = await prisma.talentStory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TalentStoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TalentStoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TalentStoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TalentStory.
     * @param {TalentStoryDeleteArgs} args - Arguments to delete one TalentStory.
     * @example
     * // Delete one TalentStory
     * const TalentStory = await prisma.talentStory.delete({
     *   where: {
     *     // ... filter to delete one TalentStory
     *   }
     * })
     * 
     */
    delete<T extends TalentStoryDeleteArgs>(args: SelectSubset<T, TalentStoryDeleteArgs<ExtArgs>>): Prisma__TalentStoryClient<$Result.GetResult<Prisma.$TalentStoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TalentStory.
     * @param {TalentStoryUpdateArgs} args - Arguments to update one TalentStory.
     * @example
     * // Update one TalentStory
     * const talentStory = await prisma.talentStory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TalentStoryUpdateArgs>(args: SelectSubset<T, TalentStoryUpdateArgs<ExtArgs>>): Prisma__TalentStoryClient<$Result.GetResult<Prisma.$TalentStoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TalentStories.
     * @param {TalentStoryDeleteManyArgs} args - Arguments to filter TalentStories to delete.
     * @example
     * // Delete a few TalentStories
     * const { count } = await prisma.talentStory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TalentStoryDeleteManyArgs>(args?: SelectSubset<T, TalentStoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TalentStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentStoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TalentStories
     * const talentStory = await prisma.talentStory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TalentStoryUpdateManyArgs>(args: SelectSubset<T, TalentStoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TalentStories and returns the data updated in the database.
     * @param {TalentStoryUpdateManyAndReturnArgs} args - Arguments to update many TalentStories.
     * @example
     * // Update many TalentStories
     * const talentStory = await prisma.talentStory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TalentStories and only return the `id`
     * const talentStoryWithIdOnly = await prisma.talentStory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TalentStoryUpdateManyAndReturnArgs>(args: SelectSubset<T, TalentStoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TalentStoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TalentStory.
     * @param {TalentStoryUpsertArgs} args - Arguments to update or create a TalentStory.
     * @example
     * // Update or create a TalentStory
     * const talentStory = await prisma.talentStory.upsert({
     *   create: {
     *     // ... data to create a TalentStory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TalentStory we want to update
     *   }
     * })
     */
    upsert<T extends TalentStoryUpsertArgs>(args: SelectSubset<T, TalentStoryUpsertArgs<ExtArgs>>): Prisma__TalentStoryClient<$Result.GetResult<Prisma.$TalentStoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TalentStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentStoryCountArgs} args - Arguments to filter TalentStories to count.
     * @example
     * // Count the number of TalentStories
     * const count = await prisma.talentStory.count({
     *   where: {
     *     // ... the filter for the TalentStories we want to count
     *   }
     * })
    **/
    count<T extends TalentStoryCountArgs>(
      args?: Subset<T, TalentStoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TalentStoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TalentStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentStoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TalentStoryAggregateArgs>(args: Subset<T, TalentStoryAggregateArgs>): Prisma.PrismaPromise<GetTalentStoryAggregateType<T>>

    /**
     * Group by TalentStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TalentStoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TalentStoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TalentStoryGroupByArgs['orderBy'] }
        : { orderBy?: TalentStoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TalentStoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTalentStoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TalentStory model
   */
  readonly fields: TalentStoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TalentStory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TalentStoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TalentStory model
   */
  interface TalentStoryFieldRefs {
    readonly id: FieldRef<"TalentStory", 'String'>
    readonly user_id: FieldRef<"TalentStory", 'String'>
    readonly story: FieldRef<"TalentStory", 'String'>
    readonly data: FieldRef<"TalentStory", 'Json'>
    readonly model: FieldRef<"TalentStory", 'String'>
    readonly created_at: FieldRef<"TalentStory", 'DateTime'>
    readonly updated_at: FieldRef<"TalentStory", 'DateTime'>
    readonly version: FieldRef<"TalentStory", 'Int'>
    readonly is_active: FieldRef<"TalentStory", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TalentStory findUnique
   */
  export type TalentStoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentStory
     */
    select?: TalentStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TalentStory
     */
    omit?: TalentStoryOmit<ExtArgs> | null
    /**
     * Filter, which TalentStory to fetch.
     */
    where: TalentStoryWhereUniqueInput
  }

  /**
   * TalentStory findUniqueOrThrow
   */
  export type TalentStoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentStory
     */
    select?: TalentStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TalentStory
     */
    omit?: TalentStoryOmit<ExtArgs> | null
    /**
     * Filter, which TalentStory to fetch.
     */
    where: TalentStoryWhereUniqueInput
  }

  /**
   * TalentStory findFirst
   */
  export type TalentStoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentStory
     */
    select?: TalentStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TalentStory
     */
    omit?: TalentStoryOmit<ExtArgs> | null
    /**
     * Filter, which TalentStory to fetch.
     */
    where?: TalentStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TalentStories to fetch.
     */
    orderBy?: TalentStoryOrderByWithRelationInput | TalentStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TalentStories.
     */
    cursor?: TalentStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TalentStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TalentStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TalentStories.
     */
    distinct?: TalentStoryScalarFieldEnum | TalentStoryScalarFieldEnum[]
  }

  /**
   * TalentStory findFirstOrThrow
   */
  export type TalentStoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentStory
     */
    select?: TalentStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TalentStory
     */
    omit?: TalentStoryOmit<ExtArgs> | null
    /**
     * Filter, which TalentStory to fetch.
     */
    where?: TalentStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TalentStories to fetch.
     */
    orderBy?: TalentStoryOrderByWithRelationInput | TalentStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TalentStories.
     */
    cursor?: TalentStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TalentStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TalentStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TalentStories.
     */
    distinct?: TalentStoryScalarFieldEnum | TalentStoryScalarFieldEnum[]
  }

  /**
   * TalentStory findMany
   */
  export type TalentStoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentStory
     */
    select?: TalentStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TalentStory
     */
    omit?: TalentStoryOmit<ExtArgs> | null
    /**
     * Filter, which TalentStories to fetch.
     */
    where?: TalentStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TalentStories to fetch.
     */
    orderBy?: TalentStoryOrderByWithRelationInput | TalentStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TalentStories.
     */
    cursor?: TalentStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TalentStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TalentStories.
     */
    skip?: number
    distinct?: TalentStoryScalarFieldEnum | TalentStoryScalarFieldEnum[]
  }

  /**
   * TalentStory create
   */
  export type TalentStoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentStory
     */
    select?: TalentStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TalentStory
     */
    omit?: TalentStoryOmit<ExtArgs> | null
    /**
     * The data needed to create a TalentStory.
     */
    data: XOR<TalentStoryCreateInput, TalentStoryUncheckedCreateInput>
  }

  /**
   * TalentStory createMany
   */
  export type TalentStoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TalentStories.
     */
    data: TalentStoryCreateManyInput | TalentStoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TalentStory createManyAndReturn
   */
  export type TalentStoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentStory
     */
    select?: TalentStorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TalentStory
     */
    omit?: TalentStoryOmit<ExtArgs> | null
    /**
     * The data used to create many TalentStories.
     */
    data: TalentStoryCreateManyInput | TalentStoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TalentStory update
   */
  export type TalentStoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentStory
     */
    select?: TalentStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TalentStory
     */
    omit?: TalentStoryOmit<ExtArgs> | null
    /**
     * The data needed to update a TalentStory.
     */
    data: XOR<TalentStoryUpdateInput, TalentStoryUncheckedUpdateInput>
    /**
     * Choose, which TalentStory to update.
     */
    where: TalentStoryWhereUniqueInput
  }

  /**
   * TalentStory updateMany
   */
  export type TalentStoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TalentStories.
     */
    data: XOR<TalentStoryUpdateManyMutationInput, TalentStoryUncheckedUpdateManyInput>
    /**
     * Filter which TalentStories to update
     */
    where?: TalentStoryWhereInput
    /**
     * Limit how many TalentStories to update.
     */
    limit?: number
  }

  /**
   * TalentStory updateManyAndReturn
   */
  export type TalentStoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentStory
     */
    select?: TalentStorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TalentStory
     */
    omit?: TalentStoryOmit<ExtArgs> | null
    /**
     * The data used to update TalentStories.
     */
    data: XOR<TalentStoryUpdateManyMutationInput, TalentStoryUncheckedUpdateManyInput>
    /**
     * Filter which TalentStories to update
     */
    where?: TalentStoryWhereInput
    /**
     * Limit how many TalentStories to update.
     */
    limit?: number
  }

  /**
   * TalentStory upsert
   */
  export type TalentStoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentStory
     */
    select?: TalentStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TalentStory
     */
    omit?: TalentStoryOmit<ExtArgs> | null
    /**
     * The filter to search for the TalentStory to update in case it exists.
     */
    where: TalentStoryWhereUniqueInput
    /**
     * In case the TalentStory found by the `where` argument doesn't exist, create a new TalentStory with this data.
     */
    create: XOR<TalentStoryCreateInput, TalentStoryUncheckedCreateInput>
    /**
     * In case the TalentStory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TalentStoryUpdateInput, TalentStoryUncheckedUpdateInput>
  }

  /**
   * TalentStory delete
   */
  export type TalentStoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentStory
     */
    select?: TalentStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TalentStory
     */
    omit?: TalentStoryOmit<ExtArgs> | null
    /**
     * Filter which TalentStory to delete.
     */
    where: TalentStoryWhereUniqueInput
  }

  /**
   * TalentStory deleteMany
   */
  export type TalentStoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TalentStories to delete
     */
    where?: TalentStoryWhereInput
    /**
     * Limit how many TalentStories to delete.
     */
    limit?: number
  }

  /**
   * TalentStory without action
   */
  export type TalentStoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TalentStory
     */
    select?: TalentStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TalentStory
     */
    omit?: TalentStoryOmit<ExtArgs> | null
  }


  /**
   * Model JobPost
   */

  export type AggregateJobPost = {
    _count: JobPostCountAggregateOutputType | null
    _min: JobPostMinAggregateOutputType | null
    _max: JobPostMaxAggregateOutputType | null
  }

  export type JobPostMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    title: string | null
    company: string | null
    location: string | null
    raw_description: string | null
    job_url: string | null
    created_at: Date | null
    updated_at: Date | null
    status: string | null
    applied_at: Date | null
  }

  export type JobPostMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    title: string | null
    company: string | null
    location: string | null
    raw_description: string | null
    job_url: string | null
    created_at: Date | null
    updated_at: Date | null
    status: string | null
    applied_at: Date | null
  }

  export type JobPostCountAggregateOutputType = {
    id: number
    user_id: number
    title: number
    company: number
    location: number
    raw_description: number
    job_url: number
    parsed_data: number
    created_at: number
    updated_at: number
    status: number
    applied_at: number
    _all: number
  }


  export type JobPostMinAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    company?: true
    location?: true
    raw_description?: true
    job_url?: true
    created_at?: true
    updated_at?: true
    status?: true
    applied_at?: true
  }

  export type JobPostMaxAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    company?: true
    location?: true
    raw_description?: true
    job_url?: true
    created_at?: true
    updated_at?: true
    status?: true
    applied_at?: true
  }

  export type JobPostCountAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    company?: true
    location?: true
    raw_description?: true
    job_url?: true
    parsed_data?: true
    created_at?: true
    updated_at?: true
    status?: true
    applied_at?: true
    _all?: true
  }

  export type JobPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPost to aggregate.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPosts
    **/
    _count?: true | JobPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostMaxAggregateInputType
  }

  export type GetJobPostAggregateType<T extends JobPostAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPost[P]>
      : GetScalarType<T[P], AggregateJobPost[P]>
  }




  export type JobPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostWhereInput
    orderBy?: JobPostOrderByWithAggregationInput | JobPostOrderByWithAggregationInput[]
    by: JobPostScalarFieldEnum[] | JobPostScalarFieldEnum
    having?: JobPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostCountAggregateInputType | true
    _min?: JobPostMinAggregateInputType
    _max?: JobPostMaxAggregateInputType
  }

  export type JobPostGroupByOutputType = {
    id: string
    user_id: string
    title: string
    company: string | null
    location: string | null
    raw_description: string
    job_url: string | null
    parsed_data: JsonValue
    created_at: Date
    updated_at: Date
    status: string | null
    applied_at: Date | null
    _count: JobPostCountAggregateOutputType | null
    _min: JobPostMinAggregateOutputType | null
    _max: JobPostMaxAggregateOutputType | null
  }

  type GetJobPostGroupByPayload<T extends JobPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostGroupByOutputType[P]>
        }
      >
    >


  export type JobPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    company?: boolean
    location?: boolean
    raw_description?: boolean
    job_url?: boolean
    parsed_data?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    applied_at?: boolean
    customized_stories?: boolean | JobPost$customized_storiesArgs<ExtArgs>
    _count?: boolean | JobPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPost"]>

  export type JobPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    company?: boolean
    location?: boolean
    raw_description?: boolean
    job_url?: boolean
    parsed_data?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    applied_at?: boolean
  }, ExtArgs["result"]["jobPost"]>

  export type JobPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    company?: boolean
    location?: boolean
    raw_description?: boolean
    job_url?: boolean
    parsed_data?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    applied_at?: boolean
  }, ExtArgs["result"]["jobPost"]>

  export type JobPostSelectScalar = {
    id?: boolean
    user_id?: boolean
    title?: boolean
    company?: boolean
    location?: boolean
    raw_description?: boolean
    job_url?: boolean
    parsed_data?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    applied_at?: boolean
  }

  export type JobPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "title" | "company" | "location" | "raw_description" | "job_url" | "parsed_data" | "created_at" | "updated_at" | "status" | "applied_at", ExtArgs["result"]["jobPost"]>
  export type JobPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customized_stories?: boolean | JobPost$customized_storiesArgs<ExtArgs>
    _count?: boolean | JobPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type JobPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $JobPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPost"
    objects: {
      customized_stories: Prisma.$CustomizedStoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      title: string
      company: string | null
      location: string | null
      raw_description: string
      job_url: string | null
      parsed_data: Prisma.JsonValue
      created_at: Date
      updated_at: Date
      status: string | null
      applied_at: Date | null
    }, ExtArgs["result"]["jobPost"]>
    composites: {}
  }

  type JobPostGetPayload<S extends boolean | null | undefined | JobPostDefaultArgs> = $Result.GetResult<Prisma.$JobPostPayload, S>

  type JobPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobPostCountAggregateInputType | true
    }

  export interface JobPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPost'], meta: { name: 'JobPost' } }
    /**
     * Find zero or one JobPost that matches the filter.
     * @param {JobPostFindUniqueArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobPostFindUniqueArgs>(args: SelectSubset<T, JobPostFindUniqueArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobPostFindUniqueOrThrowArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobPostFindUniqueOrThrowArgs>(args: SelectSubset<T, JobPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindFirstArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobPostFindFirstArgs>(args?: SelectSubset<T, JobPostFindFirstArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindFirstOrThrowArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobPostFindFirstOrThrowArgs>(args?: SelectSubset<T, JobPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPosts
     * const jobPosts = await prisma.jobPost.findMany()
     * 
     * // Get first 10 JobPosts
     * const jobPosts = await prisma.jobPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPostWithIdOnly = await prisma.jobPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobPostFindManyArgs>(args?: SelectSubset<T, JobPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobPost.
     * @param {JobPostCreateArgs} args - Arguments to create a JobPost.
     * @example
     * // Create one JobPost
     * const JobPost = await prisma.jobPost.create({
     *   data: {
     *     // ... data to create a JobPost
     *   }
     * })
     * 
     */
    create<T extends JobPostCreateArgs>(args: SelectSubset<T, JobPostCreateArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobPosts.
     * @param {JobPostCreateManyArgs} args - Arguments to create many JobPosts.
     * @example
     * // Create many JobPosts
     * const jobPost = await prisma.jobPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobPostCreateManyArgs>(args?: SelectSubset<T, JobPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobPosts and returns the data saved in the database.
     * @param {JobPostCreateManyAndReturnArgs} args - Arguments to create many JobPosts.
     * @example
     * // Create many JobPosts
     * const jobPost = await prisma.jobPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobPosts and only return the `id`
     * const jobPostWithIdOnly = await prisma.jobPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobPostCreateManyAndReturnArgs>(args?: SelectSubset<T, JobPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobPost.
     * @param {JobPostDeleteArgs} args - Arguments to delete one JobPost.
     * @example
     * // Delete one JobPost
     * const JobPost = await prisma.jobPost.delete({
     *   where: {
     *     // ... filter to delete one JobPost
     *   }
     * })
     * 
     */
    delete<T extends JobPostDeleteArgs>(args: SelectSubset<T, JobPostDeleteArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobPost.
     * @param {JobPostUpdateArgs} args - Arguments to update one JobPost.
     * @example
     * // Update one JobPost
     * const jobPost = await prisma.jobPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobPostUpdateArgs>(args: SelectSubset<T, JobPostUpdateArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobPosts.
     * @param {JobPostDeleteManyArgs} args - Arguments to filter JobPosts to delete.
     * @example
     * // Delete a few JobPosts
     * const { count } = await prisma.jobPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobPostDeleteManyArgs>(args?: SelectSubset<T, JobPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPosts
     * const jobPost = await prisma.jobPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobPostUpdateManyArgs>(args: SelectSubset<T, JobPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPosts and returns the data updated in the database.
     * @param {JobPostUpdateManyAndReturnArgs} args - Arguments to update many JobPosts.
     * @example
     * // Update many JobPosts
     * const jobPost = await prisma.jobPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobPosts and only return the `id`
     * const jobPostWithIdOnly = await prisma.jobPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobPostUpdateManyAndReturnArgs>(args: SelectSubset<T, JobPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobPost.
     * @param {JobPostUpsertArgs} args - Arguments to update or create a JobPost.
     * @example
     * // Update or create a JobPost
     * const jobPost = await prisma.jobPost.upsert({
     *   create: {
     *     // ... data to create a JobPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPost we want to update
     *   }
     * })
     */
    upsert<T extends JobPostUpsertArgs>(args: SelectSubset<T, JobPostUpsertArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostCountArgs} args - Arguments to filter JobPosts to count.
     * @example
     * // Count the number of JobPosts
     * const count = await prisma.jobPost.count({
     *   where: {
     *     // ... the filter for the JobPosts we want to count
     *   }
     * })
    **/
    count<T extends JobPostCountArgs>(
      args?: Subset<T, JobPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostAggregateArgs>(args: Subset<T, JobPostAggregateArgs>): Prisma.PrismaPromise<GetJobPostAggregateType<T>>

    /**
     * Group by JobPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostGroupByArgs['orderBy'] }
        : { orderBy?: JobPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPost model
   */
  readonly fields: JobPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customized_stories<T extends JobPost$customized_storiesArgs<ExtArgs> = {}>(args?: Subset<T, JobPost$customized_storiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomizedStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobPost model
   */
  interface JobPostFieldRefs {
    readonly id: FieldRef<"JobPost", 'String'>
    readonly user_id: FieldRef<"JobPost", 'String'>
    readonly title: FieldRef<"JobPost", 'String'>
    readonly company: FieldRef<"JobPost", 'String'>
    readonly location: FieldRef<"JobPost", 'String'>
    readonly raw_description: FieldRef<"JobPost", 'String'>
    readonly job_url: FieldRef<"JobPost", 'String'>
    readonly parsed_data: FieldRef<"JobPost", 'Json'>
    readonly created_at: FieldRef<"JobPost", 'DateTime'>
    readonly updated_at: FieldRef<"JobPost", 'DateTime'>
    readonly status: FieldRef<"JobPost", 'String'>
    readonly applied_at: FieldRef<"JobPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobPost findUnique
   */
  export type JobPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where: JobPostWhereUniqueInput
  }

  /**
   * JobPost findUniqueOrThrow
   */
  export type JobPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where: JobPostWhereUniqueInput
  }

  /**
   * JobPost findFirst
   */
  export type JobPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPosts.
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPosts.
     */
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }

  /**
   * JobPost findFirstOrThrow
   */
  export type JobPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPosts.
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPosts.
     */
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }

  /**
   * JobPost findMany
   */
  export type JobPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPosts to fetch.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPosts.
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }

  /**
   * JobPost create
   */
  export type JobPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPost.
     */
    data: XOR<JobPostCreateInput, JobPostUncheckedCreateInput>
  }

  /**
   * JobPost createMany
   */
  export type JobPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPosts.
     */
    data: JobPostCreateManyInput | JobPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPost createManyAndReturn
   */
  export type JobPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * The data used to create many JobPosts.
     */
    data: JobPostCreateManyInput | JobPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPost update
   */
  export type JobPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPost.
     */
    data: XOR<JobPostUpdateInput, JobPostUncheckedUpdateInput>
    /**
     * Choose, which JobPost to update.
     */
    where: JobPostWhereUniqueInput
  }

  /**
   * JobPost updateMany
   */
  export type JobPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPosts.
     */
    data: XOR<JobPostUpdateManyMutationInput, JobPostUncheckedUpdateManyInput>
    /**
     * Filter which JobPosts to update
     */
    where?: JobPostWhereInput
    /**
     * Limit how many JobPosts to update.
     */
    limit?: number
  }

  /**
   * JobPost updateManyAndReturn
   */
  export type JobPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * The data used to update JobPosts.
     */
    data: XOR<JobPostUpdateManyMutationInput, JobPostUncheckedUpdateManyInput>
    /**
     * Filter which JobPosts to update
     */
    where?: JobPostWhereInput
    /**
     * Limit how many JobPosts to update.
     */
    limit?: number
  }

  /**
   * JobPost upsert
   */
  export type JobPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPost to update in case it exists.
     */
    where: JobPostWhereUniqueInput
    /**
     * In case the JobPost found by the `where` argument doesn't exist, create a new JobPost with this data.
     */
    create: XOR<JobPostCreateInput, JobPostUncheckedCreateInput>
    /**
     * In case the JobPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPostUpdateInput, JobPostUncheckedUpdateInput>
  }

  /**
   * JobPost delete
   */
  export type JobPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter which JobPost to delete.
     */
    where: JobPostWhereUniqueInput
  }

  /**
   * JobPost deleteMany
   */
  export type JobPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPosts to delete
     */
    where?: JobPostWhereInput
    /**
     * Limit how many JobPosts to delete.
     */
    limit?: number
  }

  /**
   * JobPost.customized_stories
   */
  export type JobPost$customized_storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomizedStory
     */
    select?: CustomizedStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomizedStory
     */
    omit?: CustomizedStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomizedStoryInclude<ExtArgs> | null
    where?: CustomizedStoryWhereInput
    orderBy?: CustomizedStoryOrderByWithRelationInput | CustomizedStoryOrderByWithRelationInput[]
    cursor?: CustomizedStoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomizedStoryScalarFieldEnum | CustomizedStoryScalarFieldEnum[]
  }

  /**
   * JobPost without action
   */
  export type JobPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
  }


  /**
   * Model CustomizedStory
   */

  export type AggregateCustomizedStory = {
    _count: CustomizedStoryCountAggregateOutputType | null
    _avg: CustomizedStoryAvgAggregateOutputType | null
    _sum: CustomizedStorySumAggregateOutputType | null
    _min: CustomizedStoryMinAggregateOutputType | null
    _max: CustomizedStoryMaxAggregateOutputType | null
  }

  export type CustomizedStoryAvgAggregateOutputType = {
    match_score: number | null
  }

  export type CustomizedStorySumAggregateOutputType = {
    match_score: number | null
  }

  export type CustomizedStoryMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    profile_id: string | null
    job_post_id: string | null
    story: string | null
    match_score: number | null
    created_at: Date | null
    updated_at: Date | null
    is_active: boolean | null
    version_name: string | null
  }

  export type CustomizedStoryMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    profile_id: string | null
    job_post_id: string | null
    story: string | null
    match_score: number | null
    created_at: Date | null
    updated_at: Date | null
    is_active: boolean | null
    version_name: string | null
  }

  export type CustomizedStoryCountAggregateOutputType = {
    id: number
    user_id: number
    profile_id: number
    job_post_id: number
    story: number
    reordered_experience: number
    highlighted_skills: number
    match_score: number
    score_breakdown: number
    created_at: number
    updated_at: number
    is_active: number
    version_name: number
    _all: number
  }


  export type CustomizedStoryAvgAggregateInputType = {
    match_score?: true
  }

  export type CustomizedStorySumAggregateInputType = {
    match_score?: true
  }

  export type CustomizedStoryMinAggregateInputType = {
    id?: true
    user_id?: true
    profile_id?: true
    job_post_id?: true
    story?: true
    match_score?: true
    created_at?: true
    updated_at?: true
    is_active?: true
    version_name?: true
  }

  export type CustomizedStoryMaxAggregateInputType = {
    id?: true
    user_id?: true
    profile_id?: true
    job_post_id?: true
    story?: true
    match_score?: true
    created_at?: true
    updated_at?: true
    is_active?: true
    version_name?: true
  }

  export type CustomizedStoryCountAggregateInputType = {
    id?: true
    user_id?: true
    profile_id?: true
    job_post_id?: true
    story?: true
    reordered_experience?: true
    highlighted_skills?: true
    match_score?: true
    score_breakdown?: true
    created_at?: true
    updated_at?: true
    is_active?: true
    version_name?: true
    _all?: true
  }

  export type CustomizedStoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomizedStory to aggregate.
     */
    where?: CustomizedStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomizedStories to fetch.
     */
    orderBy?: CustomizedStoryOrderByWithRelationInput | CustomizedStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomizedStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomizedStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomizedStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomizedStories
    **/
    _count?: true | CustomizedStoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomizedStoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomizedStorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomizedStoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomizedStoryMaxAggregateInputType
  }

  export type GetCustomizedStoryAggregateType<T extends CustomizedStoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomizedStory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomizedStory[P]>
      : GetScalarType<T[P], AggregateCustomizedStory[P]>
  }




  export type CustomizedStoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomizedStoryWhereInput
    orderBy?: CustomizedStoryOrderByWithAggregationInput | CustomizedStoryOrderByWithAggregationInput[]
    by: CustomizedStoryScalarFieldEnum[] | CustomizedStoryScalarFieldEnum
    having?: CustomizedStoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomizedStoryCountAggregateInputType | true
    _avg?: CustomizedStoryAvgAggregateInputType
    _sum?: CustomizedStorySumAggregateInputType
    _min?: CustomizedStoryMinAggregateInputType
    _max?: CustomizedStoryMaxAggregateInputType
  }

  export type CustomizedStoryGroupByOutputType = {
    id: string
    user_id: string
    profile_id: string | null
    job_post_id: string | null
    story: string
    reordered_experience: JsonValue | null
    highlighted_skills: string[]
    match_score: number
    score_breakdown: JsonValue
    created_at: Date
    updated_at: Date
    is_active: boolean
    version_name: string | null
    _count: CustomizedStoryCountAggregateOutputType | null
    _avg: CustomizedStoryAvgAggregateOutputType | null
    _sum: CustomizedStorySumAggregateOutputType | null
    _min: CustomizedStoryMinAggregateOutputType | null
    _max: CustomizedStoryMaxAggregateOutputType | null
  }

  type GetCustomizedStoryGroupByPayload<T extends CustomizedStoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomizedStoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomizedStoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomizedStoryGroupByOutputType[P]>
            : GetScalarType<T[P], CustomizedStoryGroupByOutputType[P]>
        }
      >
    >


  export type CustomizedStorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    profile_id?: boolean
    job_post_id?: boolean
    story?: boolean
    reordered_experience?: boolean
    highlighted_skills?: boolean
    match_score?: boolean
    score_breakdown?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_active?: boolean
    version_name?: boolean
    job_post?: boolean | CustomizedStory$job_postArgs<ExtArgs>
    profile?: boolean | CustomizedStory$profileArgs<ExtArgs>
  }, ExtArgs["result"]["customizedStory"]>

  export type CustomizedStorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    profile_id?: boolean
    job_post_id?: boolean
    story?: boolean
    reordered_experience?: boolean
    highlighted_skills?: boolean
    match_score?: boolean
    score_breakdown?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_active?: boolean
    version_name?: boolean
    job_post?: boolean | CustomizedStory$job_postArgs<ExtArgs>
    profile?: boolean | CustomizedStory$profileArgs<ExtArgs>
  }, ExtArgs["result"]["customizedStory"]>

  export type CustomizedStorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    profile_id?: boolean
    job_post_id?: boolean
    story?: boolean
    reordered_experience?: boolean
    highlighted_skills?: boolean
    match_score?: boolean
    score_breakdown?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_active?: boolean
    version_name?: boolean
    job_post?: boolean | CustomizedStory$job_postArgs<ExtArgs>
    profile?: boolean | CustomizedStory$profileArgs<ExtArgs>
  }, ExtArgs["result"]["customizedStory"]>

  export type CustomizedStorySelectScalar = {
    id?: boolean
    user_id?: boolean
    profile_id?: boolean
    job_post_id?: boolean
    story?: boolean
    reordered_experience?: boolean
    highlighted_skills?: boolean
    match_score?: boolean
    score_breakdown?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_active?: boolean
    version_name?: boolean
  }

  export type CustomizedStoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "profile_id" | "job_post_id" | "story" | "reordered_experience" | "highlighted_skills" | "match_score" | "score_breakdown" | "created_at" | "updated_at" | "is_active" | "version_name", ExtArgs["result"]["customizedStory"]>
  export type CustomizedStoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_post?: boolean | CustomizedStory$job_postArgs<ExtArgs>
    profile?: boolean | CustomizedStory$profileArgs<ExtArgs>
  }
  export type CustomizedStoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_post?: boolean | CustomizedStory$job_postArgs<ExtArgs>
    profile?: boolean | CustomizedStory$profileArgs<ExtArgs>
  }
  export type CustomizedStoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_post?: boolean | CustomizedStory$job_postArgs<ExtArgs>
    profile?: boolean | CustomizedStory$profileArgs<ExtArgs>
  }

  export type $CustomizedStoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomizedStory"
    objects: {
      job_post: Prisma.$JobPostPayload<ExtArgs> | null
      profile: Prisma.$ProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      profile_id: string | null
      job_post_id: string | null
      story: string
      reordered_experience: Prisma.JsonValue | null
      highlighted_skills: string[]
      match_score: number
      score_breakdown: Prisma.JsonValue
      created_at: Date
      updated_at: Date
      is_active: boolean
      version_name: string | null
    }, ExtArgs["result"]["customizedStory"]>
    composites: {}
  }

  type CustomizedStoryGetPayload<S extends boolean | null | undefined | CustomizedStoryDefaultArgs> = $Result.GetResult<Prisma.$CustomizedStoryPayload, S>

  type CustomizedStoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomizedStoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomizedStoryCountAggregateInputType | true
    }

  export interface CustomizedStoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomizedStory'], meta: { name: 'CustomizedStory' } }
    /**
     * Find zero or one CustomizedStory that matches the filter.
     * @param {CustomizedStoryFindUniqueArgs} args - Arguments to find a CustomizedStory
     * @example
     * // Get one CustomizedStory
     * const customizedStory = await prisma.customizedStory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomizedStoryFindUniqueArgs>(args: SelectSubset<T, CustomizedStoryFindUniqueArgs<ExtArgs>>): Prisma__CustomizedStoryClient<$Result.GetResult<Prisma.$CustomizedStoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomizedStory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomizedStoryFindUniqueOrThrowArgs} args - Arguments to find a CustomizedStory
     * @example
     * // Get one CustomizedStory
     * const customizedStory = await prisma.customizedStory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomizedStoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomizedStoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomizedStoryClient<$Result.GetResult<Prisma.$CustomizedStoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomizedStory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomizedStoryFindFirstArgs} args - Arguments to find a CustomizedStory
     * @example
     * // Get one CustomizedStory
     * const customizedStory = await prisma.customizedStory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomizedStoryFindFirstArgs>(args?: SelectSubset<T, CustomizedStoryFindFirstArgs<ExtArgs>>): Prisma__CustomizedStoryClient<$Result.GetResult<Prisma.$CustomizedStoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomizedStory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomizedStoryFindFirstOrThrowArgs} args - Arguments to find a CustomizedStory
     * @example
     * // Get one CustomizedStory
     * const customizedStory = await prisma.customizedStory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomizedStoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomizedStoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomizedStoryClient<$Result.GetResult<Prisma.$CustomizedStoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomizedStories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomizedStoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomizedStories
     * const customizedStories = await prisma.customizedStory.findMany()
     * 
     * // Get first 10 CustomizedStories
     * const customizedStories = await prisma.customizedStory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customizedStoryWithIdOnly = await prisma.customizedStory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomizedStoryFindManyArgs>(args?: SelectSubset<T, CustomizedStoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomizedStoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomizedStory.
     * @param {CustomizedStoryCreateArgs} args - Arguments to create a CustomizedStory.
     * @example
     * // Create one CustomizedStory
     * const CustomizedStory = await prisma.customizedStory.create({
     *   data: {
     *     // ... data to create a CustomizedStory
     *   }
     * })
     * 
     */
    create<T extends CustomizedStoryCreateArgs>(args: SelectSubset<T, CustomizedStoryCreateArgs<ExtArgs>>): Prisma__CustomizedStoryClient<$Result.GetResult<Prisma.$CustomizedStoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomizedStories.
     * @param {CustomizedStoryCreateManyArgs} args - Arguments to create many CustomizedStories.
     * @example
     * // Create many CustomizedStories
     * const customizedStory = await prisma.customizedStory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomizedStoryCreateManyArgs>(args?: SelectSubset<T, CustomizedStoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomizedStories and returns the data saved in the database.
     * @param {CustomizedStoryCreateManyAndReturnArgs} args - Arguments to create many CustomizedStories.
     * @example
     * // Create many CustomizedStories
     * const customizedStory = await prisma.customizedStory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomizedStories and only return the `id`
     * const customizedStoryWithIdOnly = await prisma.customizedStory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomizedStoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomizedStoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomizedStoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomizedStory.
     * @param {CustomizedStoryDeleteArgs} args - Arguments to delete one CustomizedStory.
     * @example
     * // Delete one CustomizedStory
     * const CustomizedStory = await prisma.customizedStory.delete({
     *   where: {
     *     // ... filter to delete one CustomizedStory
     *   }
     * })
     * 
     */
    delete<T extends CustomizedStoryDeleteArgs>(args: SelectSubset<T, CustomizedStoryDeleteArgs<ExtArgs>>): Prisma__CustomizedStoryClient<$Result.GetResult<Prisma.$CustomizedStoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomizedStory.
     * @param {CustomizedStoryUpdateArgs} args - Arguments to update one CustomizedStory.
     * @example
     * // Update one CustomizedStory
     * const customizedStory = await prisma.customizedStory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomizedStoryUpdateArgs>(args: SelectSubset<T, CustomizedStoryUpdateArgs<ExtArgs>>): Prisma__CustomizedStoryClient<$Result.GetResult<Prisma.$CustomizedStoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomizedStories.
     * @param {CustomizedStoryDeleteManyArgs} args - Arguments to filter CustomizedStories to delete.
     * @example
     * // Delete a few CustomizedStories
     * const { count } = await prisma.customizedStory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomizedStoryDeleteManyArgs>(args?: SelectSubset<T, CustomizedStoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomizedStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomizedStoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomizedStories
     * const customizedStory = await prisma.customizedStory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomizedStoryUpdateManyArgs>(args: SelectSubset<T, CustomizedStoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomizedStories and returns the data updated in the database.
     * @param {CustomizedStoryUpdateManyAndReturnArgs} args - Arguments to update many CustomizedStories.
     * @example
     * // Update many CustomizedStories
     * const customizedStory = await prisma.customizedStory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomizedStories and only return the `id`
     * const customizedStoryWithIdOnly = await prisma.customizedStory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomizedStoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomizedStoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomizedStoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomizedStory.
     * @param {CustomizedStoryUpsertArgs} args - Arguments to update or create a CustomizedStory.
     * @example
     * // Update or create a CustomizedStory
     * const customizedStory = await prisma.customizedStory.upsert({
     *   create: {
     *     // ... data to create a CustomizedStory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomizedStory we want to update
     *   }
     * })
     */
    upsert<T extends CustomizedStoryUpsertArgs>(args: SelectSubset<T, CustomizedStoryUpsertArgs<ExtArgs>>): Prisma__CustomizedStoryClient<$Result.GetResult<Prisma.$CustomizedStoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomizedStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomizedStoryCountArgs} args - Arguments to filter CustomizedStories to count.
     * @example
     * // Count the number of CustomizedStories
     * const count = await prisma.customizedStory.count({
     *   where: {
     *     // ... the filter for the CustomizedStories we want to count
     *   }
     * })
    **/
    count<T extends CustomizedStoryCountArgs>(
      args?: Subset<T, CustomizedStoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomizedStoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomizedStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomizedStoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomizedStoryAggregateArgs>(args: Subset<T, CustomizedStoryAggregateArgs>): Prisma.PrismaPromise<GetCustomizedStoryAggregateType<T>>

    /**
     * Group by CustomizedStory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomizedStoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomizedStoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomizedStoryGroupByArgs['orderBy'] }
        : { orderBy?: CustomizedStoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomizedStoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomizedStoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomizedStory model
   */
  readonly fields: CustomizedStoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomizedStory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomizedStoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job_post<T extends CustomizedStory$job_postArgs<ExtArgs> = {}>(args?: Subset<T, CustomizedStory$job_postArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    profile<T extends CustomizedStory$profileArgs<ExtArgs> = {}>(args?: Subset<T, CustomizedStory$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomizedStory model
   */
  interface CustomizedStoryFieldRefs {
    readonly id: FieldRef<"CustomizedStory", 'String'>
    readonly user_id: FieldRef<"CustomizedStory", 'String'>
    readonly profile_id: FieldRef<"CustomizedStory", 'String'>
    readonly job_post_id: FieldRef<"CustomizedStory", 'String'>
    readonly story: FieldRef<"CustomizedStory", 'String'>
    readonly reordered_experience: FieldRef<"CustomizedStory", 'Json'>
    readonly highlighted_skills: FieldRef<"CustomizedStory", 'String[]'>
    readonly match_score: FieldRef<"CustomizedStory", 'Int'>
    readonly score_breakdown: FieldRef<"CustomizedStory", 'Json'>
    readonly created_at: FieldRef<"CustomizedStory", 'DateTime'>
    readonly updated_at: FieldRef<"CustomizedStory", 'DateTime'>
    readonly is_active: FieldRef<"CustomizedStory", 'Boolean'>
    readonly version_name: FieldRef<"CustomizedStory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CustomizedStory findUnique
   */
  export type CustomizedStoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomizedStory
     */
    select?: CustomizedStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomizedStory
     */
    omit?: CustomizedStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomizedStoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomizedStory to fetch.
     */
    where: CustomizedStoryWhereUniqueInput
  }

  /**
   * CustomizedStory findUniqueOrThrow
   */
  export type CustomizedStoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomizedStory
     */
    select?: CustomizedStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomizedStory
     */
    omit?: CustomizedStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomizedStoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomizedStory to fetch.
     */
    where: CustomizedStoryWhereUniqueInput
  }

  /**
   * CustomizedStory findFirst
   */
  export type CustomizedStoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomizedStory
     */
    select?: CustomizedStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomizedStory
     */
    omit?: CustomizedStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomizedStoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomizedStory to fetch.
     */
    where?: CustomizedStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomizedStories to fetch.
     */
    orderBy?: CustomizedStoryOrderByWithRelationInput | CustomizedStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomizedStories.
     */
    cursor?: CustomizedStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomizedStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomizedStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomizedStories.
     */
    distinct?: CustomizedStoryScalarFieldEnum | CustomizedStoryScalarFieldEnum[]
  }

  /**
   * CustomizedStory findFirstOrThrow
   */
  export type CustomizedStoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomizedStory
     */
    select?: CustomizedStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomizedStory
     */
    omit?: CustomizedStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomizedStoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomizedStory to fetch.
     */
    where?: CustomizedStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomizedStories to fetch.
     */
    orderBy?: CustomizedStoryOrderByWithRelationInput | CustomizedStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomizedStories.
     */
    cursor?: CustomizedStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomizedStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomizedStories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomizedStories.
     */
    distinct?: CustomizedStoryScalarFieldEnum | CustomizedStoryScalarFieldEnum[]
  }

  /**
   * CustomizedStory findMany
   */
  export type CustomizedStoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomizedStory
     */
    select?: CustomizedStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomizedStory
     */
    omit?: CustomizedStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomizedStoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomizedStories to fetch.
     */
    where?: CustomizedStoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomizedStories to fetch.
     */
    orderBy?: CustomizedStoryOrderByWithRelationInput | CustomizedStoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomizedStories.
     */
    cursor?: CustomizedStoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomizedStories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomizedStories.
     */
    skip?: number
    distinct?: CustomizedStoryScalarFieldEnum | CustomizedStoryScalarFieldEnum[]
  }

  /**
   * CustomizedStory create
   */
  export type CustomizedStoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomizedStory
     */
    select?: CustomizedStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomizedStory
     */
    omit?: CustomizedStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomizedStoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomizedStory.
     */
    data: XOR<CustomizedStoryCreateInput, CustomizedStoryUncheckedCreateInput>
  }

  /**
   * CustomizedStory createMany
   */
  export type CustomizedStoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomizedStories.
     */
    data: CustomizedStoryCreateManyInput | CustomizedStoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomizedStory createManyAndReturn
   */
  export type CustomizedStoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomizedStory
     */
    select?: CustomizedStorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomizedStory
     */
    omit?: CustomizedStoryOmit<ExtArgs> | null
    /**
     * The data used to create many CustomizedStories.
     */
    data: CustomizedStoryCreateManyInput | CustomizedStoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomizedStoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomizedStory update
   */
  export type CustomizedStoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomizedStory
     */
    select?: CustomizedStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomizedStory
     */
    omit?: CustomizedStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomizedStoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomizedStory.
     */
    data: XOR<CustomizedStoryUpdateInput, CustomizedStoryUncheckedUpdateInput>
    /**
     * Choose, which CustomizedStory to update.
     */
    where: CustomizedStoryWhereUniqueInput
  }

  /**
   * CustomizedStory updateMany
   */
  export type CustomizedStoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomizedStories.
     */
    data: XOR<CustomizedStoryUpdateManyMutationInput, CustomizedStoryUncheckedUpdateManyInput>
    /**
     * Filter which CustomizedStories to update
     */
    where?: CustomizedStoryWhereInput
    /**
     * Limit how many CustomizedStories to update.
     */
    limit?: number
  }

  /**
   * CustomizedStory updateManyAndReturn
   */
  export type CustomizedStoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomizedStory
     */
    select?: CustomizedStorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomizedStory
     */
    omit?: CustomizedStoryOmit<ExtArgs> | null
    /**
     * The data used to update CustomizedStories.
     */
    data: XOR<CustomizedStoryUpdateManyMutationInput, CustomizedStoryUncheckedUpdateManyInput>
    /**
     * Filter which CustomizedStories to update
     */
    where?: CustomizedStoryWhereInput
    /**
     * Limit how many CustomizedStories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomizedStoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomizedStory upsert
   */
  export type CustomizedStoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomizedStory
     */
    select?: CustomizedStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomizedStory
     */
    omit?: CustomizedStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomizedStoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomizedStory to update in case it exists.
     */
    where: CustomizedStoryWhereUniqueInput
    /**
     * In case the CustomizedStory found by the `where` argument doesn't exist, create a new CustomizedStory with this data.
     */
    create: XOR<CustomizedStoryCreateInput, CustomizedStoryUncheckedCreateInput>
    /**
     * In case the CustomizedStory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomizedStoryUpdateInput, CustomizedStoryUncheckedUpdateInput>
  }

  /**
   * CustomizedStory delete
   */
  export type CustomizedStoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomizedStory
     */
    select?: CustomizedStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomizedStory
     */
    omit?: CustomizedStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomizedStoryInclude<ExtArgs> | null
    /**
     * Filter which CustomizedStory to delete.
     */
    where: CustomizedStoryWhereUniqueInput
  }

  /**
   * CustomizedStory deleteMany
   */
  export type CustomizedStoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomizedStories to delete
     */
    where?: CustomizedStoryWhereInput
    /**
     * Limit how many CustomizedStories to delete.
     */
    limit?: number
  }

  /**
   * CustomizedStory.job_post
   */
  export type CustomizedStory$job_postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPost
     */
    omit?: JobPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostInclude<ExtArgs> | null
    where?: JobPostWhereInput
  }

  /**
   * CustomizedStory.profile
   */
  export type CustomizedStory$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * CustomizedStory without action
   */
  export type CustomizedStoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomizedStory
     */
    select?: CustomizedStorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomizedStory
     */
    omit?: CustomizedStoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomizedStoryInclude<ExtArgs> | null
  }


  /**
   * Model Story
   */

  export type AggregateStory = {
    _count: StoryCountAggregateOutputType | null
    _avg: StoryAvgAggregateOutputType | null
    _sum: StorySumAggregateOutputType | null
    _min: StoryMinAggregateOutputType | null
    _max: StoryMaxAggregateOutputType | null
  }

  export type StoryAvgAggregateOutputType = {
    relevance_score: number | null
  }

  export type StorySumAggregateOutputType = {
    relevance_score: number | null
  }

  export type StoryMinAggregateOutputType = {
    id: string | null
    experience_id: string | null
    created_at: Date | null
    updated_at: Date | null
    situation: string | null
    task: string | null
    action: string | null
    result: string | null
    full_story: string | null
    ai_generated: boolean | null
    title: string | null
    is_draft: boolean | null
    relevance_score: number | null
  }

  export type StoryMaxAggregateOutputType = {
    id: string | null
    experience_id: string | null
    created_at: Date | null
    updated_at: Date | null
    situation: string | null
    task: string | null
    action: string | null
    result: string | null
    full_story: string | null
    ai_generated: boolean | null
    title: string | null
    is_draft: boolean | null
    relevance_score: number | null
  }

  export type StoryCountAggregateOutputType = {
    id: number
    experience_id: number
    created_at: number
    updated_at: number
    situation: number
    task: number
    action: number
    result: number
    full_story: number
    ai_generated: number
    metrics: number
    title: number
    tags: number
    is_draft: number
    relevance_score: number
    job_match_scores: number
    _all: number
  }


  export type StoryAvgAggregateInputType = {
    relevance_score?: true
  }

  export type StorySumAggregateInputType = {
    relevance_score?: true
  }

  export type StoryMinAggregateInputType = {
    id?: true
    experience_id?: true
    created_at?: true
    updated_at?: true
    situation?: true
    task?: true
    action?: true
    result?: true
    full_story?: true
    ai_generated?: true
    title?: true
    is_draft?: true
    relevance_score?: true
  }

  export type StoryMaxAggregateInputType = {
    id?: true
    experience_id?: true
    created_at?: true
    updated_at?: true
    situation?: true
    task?: true
    action?: true
    result?: true
    full_story?: true
    ai_generated?: true
    title?: true
    is_draft?: true
    relevance_score?: true
  }

  export type StoryCountAggregateInputType = {
    id?: true
    experience_id?: true
    created_at?: true
    updated_at?: true
    situation?: true
    task?: true
    action?: true
    result?: true
    full_story?: true
    ai_generated?: true
    metrics?: true
    title?: true
    tags?: true
    is_draft?: true
    relevance_score?: true
    job_match_scores?: true
    _all?: true
  }

  export type StoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Story to aggregate.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stories
    **/
    _count?: true | StoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryMaxAggregateInputType
  }

  export type GetStoryAggregateType<T extends StoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStory[P]>
      : GetScalarType<T[P], AggregateStory[P]>
  }




  export type StoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryWhereInput
    orderBy?: StoryOrderByWithAggregationInput | StoryOrderByWithAggregationInput[]
    by: StoryScalarFieldEnum[] | StoryScalarFieldEnum
    having?: StoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryCountAggregateInputType | true
    _avg?: StoryAvgAggregateInputType
    _sum?: StorySumAggregateInputType
    _min?: StoryMinAggregateInputType
    _max?: StoryMaxAggregateInputType
  }

  export type StoryGroupByOutputType = {
    id: string
    experience_id: string
    created_at: Date
    updated_at: Date
    situation: string | null
    task: string | null
    action: string | null
    result: string | null
    full_story: string | null
    ai_generated: boolean
    metrics: JsonValue | null
    title: string | null
    tags: string[]
    is_draft: boolean
    relevance_score: number | null
    job_match_scores: JsonValue | null
    _count: StoryCountAggregateOutputType | null
    _avg: StoryAvgAggregateOutputType | null
    _sum: StorySumAggregateOutputType | null
    _min: StoryMinAggregateOutputType | null
    _max: StoryMaxAggregateOutputType | null
  }

  type GetStoryGroupByPayload<T extends StoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryGroupByOutputType[P]>
            : GetScalarType<T[P], StoryGroupByOutputType[P]>
        }
      >
    >


  export type StorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experience_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    situation?: boolean
    task?: boolean
    action?: boolean
    result?: boolean
    full_story?: boolean
    ai_generated?: boolean
    metrics?: boolean
    title?: boolean
    tags?: boolean
    is_draft?: boolean
    relevance_score?: boolean
    job_match_scores?: boolean
    experience?: boolean | ExperienceDefaultArgs<ExtArgs>
    versions?: boolean | Story$versionsArgs<ExtArgs>
    skills?: boolean | Story$skillsArgs<ExtArgs>
    _count?: boolean | StoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["story"]>

  export type StorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experience_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    situation?: boolean
    task?: boolean
    action?: boolean
    result?: boolean
    full_story?: boolean
    ai_generated?: boolean
    metrics?: boolean
    title?: boolean
    tags?: boolean
    is_draft?: boolean
    relevance_score?: boolean
    job_match_scores?: boolean
    experience?: boolean | ExperienceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["story"]>

  export type StorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experience_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    situation?: boolean
    task?: boolean
    action?: boolean
    result?: boolean
    full_story?: boolean
    ai_generated?: boolean
    metrics?: boolean
    title?: boolean
    tags?: boolean
    is_draft?: boolean
    relevance_score?: boolean
    job_match_scores?: boolean
    experience?: boolean | ExperienceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["story"]>

  export type StorySelectScalar = {
    id?: boolean
    experience_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    situation?: boolean
    task?: boolean
    action?: boolean
    result?: boolean
    full_story?: boolean
    ai_generated?: boolean
    metrics?: boolean
    title?: boolean
    tags?: boolean
    is_draft?: boolean
    relevance_score?: boolean
    job_match_scores?: boolean
  }

  export type StoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "experience_id" | "created_at" | "updated_at" | "situation" | "task" | "action" | "result" | "full_story" | "ai_generated" | "metrics" | "title" | "tags" | "is_draft" | "relevance_score" | "job_match_scores", ExtArgs["result"]["story"]>
  export type StoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experience?: boolean | ExperienceDefaultArgs<ExtArgs>
    versions?: boolean | Story$versionsArgs<ExtArgs>
    skills?: boolean | Story$skillsArgs<ExtArgs>
    _count?: boolean | StoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experience?: boolean | ExperienceDefaultArgs<ExtArgs>
  }
  export type StoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experience?: boolean | ExperienceDefaultArgs<ExtArgs>
  }

  export type $StoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Story"
    objects: {
      experience: Prisma.$ExperiencePayload<ExtArgs>
      versions: Prisma.$StoryVersionPayload<ExtArgs>[]
      skills: Prisma.$StorySkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      experience_id: string
      created_at: Date
      updated_at: Date
      situation: string | null
      task: string | null
      action: string | null
      result: string | null
      full_story: string | null
      ai_generated: boolean
      metrics: Prisma.JsonValue | null
      title: string | null
      tags: string[]
      is_draft: boolean
      relevance_score: number | null
      job_match_scores: Prisma.JsonValue | null
    }, ExtArgs["result"]["story"]>
    composites: {}
  }

  type StoryGetPayload<S extends boolean | null | undefined | StoryDefaultArgs> = $Result.GetResult<Prisma.$StoryPayload, S>

  type StoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryCountAggregateInputType | true
    }

  export interface StoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Story'], meta: { name: 'Story' } }
    /**
     * Find zero or one Story that matches the filter.
     * @param {StoryFindUniqueArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryFindUniqueArgs>(args: SelectSubset<T, StoryFindUniqueArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Story that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryFindUniqueOrThrowArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Story that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindFirstArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryFindFirstArgs>(args?: SelectSubset<T, StoryFindFirstArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Story that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindFirstOrThrowArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stories
     * const stories = await prisma.story.findMany()
     * 
     * // Get first 10 Stories
     * const stories = await prisma.story.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyWithIdOnly = await prisma.story.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryFindManyArgs>(args?: SelectSubset<T, StoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Story.
     * @param {StoryCreateArgs} args - Arguments to create a Story.
     * @example
     * // Create one Story
     * const Story = await prisma.story.create({
     *   data: {
     *     // ... data to create a Story
     *   }
     * })
     * 
     */
    create<T extends StoryCreateArgs>(args: SelectSubset<T, StoryCreateArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stories.
     * @param {StoryCreateManyArgs} args - Arguments to create many Stories.
     * @example
     * // Create many Stories
     * const story = await prisma.story.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryCreateManyArgs>(args?: SelectSubset<T, StoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stories and returns the data saved in the database.
     * @param {StoryCreateManyAndReturnArgs} args - Arguments to create many Stories.
     * @example
     * // Create many Stories
     * const story = await prisma.story.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stories and only return the `id`
     * const storyWithIdOnly = await prisma.story.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Story.
     * @param {StoryDeleteArgs} args - Arguments to delete one Story.
     * @example
     * // Delete one Story
     * const Story = await prisma.story.delete({
     *   where: {
     *     // ... filter to delete one Story
     *   }
     * })
     * 
     */
    delete<T extends StoryDeleteArgs>(args: SelectSubset<T, StoryDeleteArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Story.
     * @param {StoryUpdateArgs} args - Arguments to update one Story.
     * @example
     * // Update one Story
     * const story = await prisma.story.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryUpdateArgs>(args: SelectSubset<T, StoryUpdateArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stories.
     * @param {StoryDeleteManyArgs} args - Arguments to filter Stories to delete.
     * @example
     * // Delete a few Stories
     * const { count } = await prisma.story.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryDeleteManyArgs>(args?: SelectSubset<T, StoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stories
     * const story = await prisma.story.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryUpdateManyArgs>(args: SelectSubset<T, StoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stories and returns the data updated in the database.
     * @param {StoryUpdateManyAndReturnArgs} args - Arguments to update many Stories.
     * @example
     * // Update many Stories
     * const story = await prisma.story.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stories and only return the `id`
     * const storyWithIdOnly = await prisma.story.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Story.
     * @param {StoryUpsertArgs} args - Arguments to update or create a Story.
     * @example
     * // Update or create a Story
     * const story = await prisma.story.upsert({
     *   create: {
     *     // ... data to create a Story
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Story we want to update
     *   }
     * })
     */
    upsert<T extends StoryUpsertArgs>(args: SelectSubset<T, StoryUpsertArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryCountArgs} args - Arguments to filter Stories to count.
     * @example
     * // Count the number of Stories
     * const count = await prisma.story.count({
     *   where: {
     *     // ... the filter for the Stories we want to count
     *   }
     * })
    **/
    count<T extends StoryCountArgs>(
      args?: Subset<T, StoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryAggregateArgs>(args: Subset<T, StoryAggregateArgs>): Prisma.PrismaPromise<GetStoryAggregateType<T>>

    /**
     * Group by Story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryGroupByArgs['orderBy'] }
        : { orderBy?: StoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Story model
   */
  readonly fields: StoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Story.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    experience<T extends ExperienceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExperienceDefaultArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    versions<T extends Story$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Story$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skills<T extends Story$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Story$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorySkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Story model
   */
  interface StoryFieldRefs {
    readonly id: FieldRef<"Story", 'String'>
    readonly experience_id: FieldRef<"Story", 'String'>
    readonly created_at: FieldRef<"Story", 'DateTime'>
    readonly updated_at: FieldRef<"Story", 'DateTime'>
    readonly situation: FieldRef<"Story", 'String'>
    readonly task: FieldRef<"Story", 'String'>
    readonly action: FieldRef<"Story", 'String'>
    readonly result: FieldRef<"Story", 'String'>
    readonly full_story: FieldRef<"Story", 'String'>
    readonly ai_generated: FieldRef<"Story", 'Boolean'>
    readonly metrics: FieldRef<"Story", 'Json'>
    readonly title: FieldRef<"Story", 'String'>
    readonly tags: FieldRef<"Story", 'String[]'>
    readonly is_draft: FieldRef<"Story", 'Boolean'>
    readonly relevance_score: FieldRef<"Story", 'Float'>
    readonly job_match_scores: FieldRef<"Story", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Story findUnique
   */
  export type StoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story findUniqueOrThrow
   */
  export type StoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story findFirst
   */
  export type StoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stories.
     */
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story findFirstOrThrow
   */
  export type StoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stories.
     */
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story findMany
   */
  export type StoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Stories to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story create
   */
  export type StoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Story.
     */
    data: XOR<StoryCreateInput, StoryUncheckedCreateInput>
  }

  /**
   * Story createMany
   */
  export type StoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stories.
     */
    data: StoryCreateManyInput | StoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Story createManyAndReturn
   */
  export type StoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * The data used to create many Stories.
     */
    data: StoryCreateManyInput | StoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Story update
   */
  export type StoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Story.
     */
    data: XOR<StoryUpdateInput, StoryUncheckedUpdateInput>
    /**
     * Choose, which Story to update.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story updateMany
   */
  export type StoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stories.
     */
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyInput>
    /**
     * Filter which Stories to update
     */
    where?: StoryWhereInput
    /**
     * Limit how many Stories to update.
     */
    limit?: number
  }

  /**
   * Story updateManyAndReturn
   */
  export type StoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * The data used to update Stories.
     */
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyInput>
    /**
     * Filter which Stories to update
     */
    where?: StoryWhereInput
    /**
     * Limit how many Stories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Story upsert
   */
  export type StoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Story to update in case it exists.
     */
    where: StoryWhereUniqueInput
    /**
     * In case the Story found by the `where` argument doesn't exist, create a new Story with this data.
     */
    create: XOR<StoryCreateInput, StoryUncheckedCreateInput>
    /**
     * In case the Story was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryUpdateInput, StoryUncheckedUpdateInput>
  }

  /**
   * Story delete
   */
  export type StoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter which Story to delete.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story deleteMany
   */
  export type StoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stories to delete
     */
    where?: StoryWhereInput
    /**
     * Limit how many Stories to delete.
     */
    limit?: number
  }

  /**
   * Story.versions
   */
  export type Story$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    where?: StoryVersionWhereInput
    orderBy?: StoryVersionOrderByWithRelationInput | StoryVersionOrderByWithRelationInput[]
    cursor?: StoryVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryVersionScalarFieldEnum | StoryVersionScalarFieldEnum[]
  }

  /**
   * Story.skills
   */
  export type Story$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorySkill
     */
    select?: StorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorySkill
     */
    omit?: StorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorySkillInclude<ExtArgs> | null
    where?: StorySkillWhereInput
    orderBy?: StorySkillOrderByWithRelationInput | StorySkillOrderByWithRelationInput[]
    cursor?: StorySkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorySkillScalarFieldEnum | StorySkillScalarFieldEnum[]
  }

  /**
   * Story without action
   */
  export type StoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
  }


  /**
   * Model StoryVersion
   */

  export type AggregateStoryVersion = {
    _count: StoryVersionCountAggregateOutputType | null
    _avg: StoryVersionAvgAggregateOutputType | null
    _sum: StoryVersionSumAggregateOutputType | null
    _min: StoryVersionMinAggregateOutputType | null
    _max: StoryVersionMaxAggregateOutputType | null
  }

  export type StoryVersionAvgAggregateOutputType = {
    version_number: number | null
  }

  export type StoryVersionSumAggregateOutputType = {
    version_number: number | null
  }

  export type StoryVersionMinAggregateOutputType = {
    id: string | null
    story_id: string | null
    created_at: Date | null
    version_number: number | null
    situation: string | null
    task: string | null
    action: string | null
    result: string | null
    full_story: string | null
    change_summary: string | null
    created_by_ai: boolean | null
  }

  export type StoryVersionMaxAggregateOutputType = {
    id: string | null
    story_id: string | null
    created_at: Date | null
    version_number: number | null
    situation: string | null
    task: string | null
    action: string | null
    result: string | null
    full_story: string | null
    change_summary: string | null
    created_by_ai: boolean | null
  }

  export type StoryVersionCountAggregateOutputType = {
    id: number
    story_id: number
    created_at: number
    version_number: number
    situation: number
    task: number
    action: number
    result: number
    full_story: number
    metrics: number
    change_summary: number
    created_by_ai: number
    _all: number
  }


  export type StoryVersionAvgAggregateInputType = {
    version_number?: true
  }

  export type StoryVersionSumAggregateInputType = {
    version_number?: true
  }

  export type StoryVersionMinAggregateInputType = {
    id?: true
    story_id?: true
    created_at?: true
    version_number?: true
    situation?: true
    task?: true
    action?: true
    result?: true
    full_story?: true
    change_summary?: true
    created_by_ai?: true
  }

  export type StoryVersionMaxAggregateInputType = {
    id?: true
    story_id?: true
    created_at?: true
    version_number?: true
    situation?: true
    task?: true
    action?: true
    result?: true
    full_story?: true
    change_summary?: true
    created_by_ai?: true
  }

  export type StoryVersionCountAggregateInputType = {
    id?: true
    story_id?: true
    created_at?: true
    version_number?: true
    situation?: true
    task?: true
    action?: true
    result?: true
    full_story?: true
    metrics?: true
    change_summary?: true
    created_by_ai?: true
    _all?: true
  }

  export type StoryVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryVersion to aggregate.
     */
    where?: StoryVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryVersions to fetch.
     */
    orderBy?: StoryVersionOrderByWithRelationInput | StoryVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoryVersions
    **/
    _count?: true | StoryVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoryVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoryVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryVersionMaxAggregateInputType
  }

  export type GetStoryVersionAggregateType<T extends StoryVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateStoryVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoryVersion[P]>
      : GetScalarType<T[P], AggregateStoryVersion[P]>
  }




  export type StoryVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryVersionWhereInput
    orderBy?: StoryVersionOrderByWithAggregationInput | StoryVersionOrderByWithAggregationInput[]
    by: StoryVersionScalarFieldEnum[] | StoryVersionScalarFieldEnum
    having?: StoryVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryVersionCountAggregateInputType | true
    _avg?: StoryVersionAvgAggregateInputType
    _sum?: StoryVersionSumAggregateInputType
    _min?: StoryVersionMinAggregateInputType
    _max?: StoryVersionMaxAggregateInputType
  }

  export type StoryVersionGroupByOutputType = {
    id: string
    story_id: string
    created_at: Date
    version_number: number
    situation: string | null
    task: string | null
    action: string | null
    result: string | null
    full_story: string | null
    metrics: JsonValue | null
    change_summary: string | null
    created_by_ai: boolean
    _count: StoryVersionCountAggregateOutputType | null
    _avg: StoryVersionAvgAggregateOutputType | null
    _sum: StoryVersionSumAggregateOutputType | null
    _min: StoryVersionMinAggregateOutputType | null
    _max: StoryVersionMaxAggregateOutputType | null
  }

  type GetStoryVersionGroupByPayload<T extends StoryVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryVersionGroupByOutputType[P]>
            : GetScalarType<T[P], StoryVersionGroupByOutputType[P]>
        }
      >
    >


  export type StoryVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    story_id?: boolean
    created_at?: boolean
    version_number?: boolean
    situation?: boolean
    task?: boolean
    action?: boolean
    result?: boolean
    full_story?: boolean
    metrics?: boolean
    change_summary?: boolean
    created_by_ai?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyVersion"]>

  export type StoryVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    story_id?: boolean
    created_at?: boolean
    version_number?: boolean
    situation?: boolean
    task?: boolean
    action?: boolean
    result?: boolean
    full_story?: boolean
    metrics?: boolean
    change_summary?: boolean
    created_by_ai?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyVersion"]>

  export type StoryVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    story_id?: boolean
    created_at?: boolean
    version_number?: boolean
    situation?: boolean
    task?: boolean
    action?: boolean
    result?: boolean
    full_story?: boolean
    metrics?: boolean
    change_summary?: boolean
    created_by_ai?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyVersion"]>

  export type StoryVersionSelectScalar = {
    id?: boolean
    story_id?: boolean
    created_at?: boolean
    version_number?: boolean
    situation?: boolean
    task?: boolean
    action?: boolean
    result?: boolean
    full_story?: boolean
    metrics?: boolean
    change_summary?: boolean
    created_by_ai?: boolean
  }

  export type StoryVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "story_id" | "created_at" | "version_number" | "situation" | "task" | "action" | "result" | "full_story" | "metrics" | "change_summary" | "created_by_ai", ExtArgs["result"]["storyVersion"]>
  export type StoryVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
  }
  export type StoryVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
  }
  export type StoryVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
  }

  export type $StoryVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoryVersion"
    objects: {
      story: Prisma.$StoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      story_id: string
      created_at: Date
      version_number: number
      situation: string | null
      task: string | null
      action: string | null
      result: string | null
      full_story: string | null
      metrics: Prisma.JsonValue | null
      change_summary: string | null
      created_by_ai: boolean
    }, ExtArgs["result"]["storyVersion"]>
    composites: {}
  }

  type StoryVersionGetPayload<S extends boolean | null | undefined | StoryVersionDefaultArgs> = $Result.GetResult<Prisma.$StoryVersionPayload, S>

  type StoryVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryVersionCountAggregateInputType | true
    }

  export interface StoryVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoryVersion'], meta: { name: 'StoryVersion' } }
    /**
     * Find zero or one StoryVersion that matches the filter.
     * @param {StoryVersionFindUniqueArgs} args - Arguments to find a StoryVersion
     * @example
     * // Get one StoryVersion
     * const storyVersion = await prisma.storyVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryVersionFindUniqueArgs>(args: SelectSubset<T, StoryVersionFindUniqueArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoryVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryVersionFindUniqueOrThrowArgs} args - Arguments to find a StoryVersion
     * @example
     * // Get one StoryVersion
     * const storyVersion = await prisma.storyVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryVersionFindFirstArgs} args - Arguments to find a StoryVersion
     * @example
     * // Get one StoryVersion
     * const storyVersion = await prisma.storyVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryVersionFindFirstArgs>(args?: SelectSubset<T, StoryVersionFindFirstArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryVersionFindFirstOrThrowArgs} args - Arguments to find a StoryVersion
     * @example
     * // Get one StoryVersion
     * const storyVersion = await prisma.storyVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoryVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoryVersions
     * const storyVersions = await prisma.storyVersion.findMany()
     * 
     * // Get first 10 StoryVersions
     * const storyVersions = await prisma.storyVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyVersionWithIdOnly = await prisma.storyVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryVersionFindManyArgs>(args?: SelectSubset<T, StoryVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoryVersion.
     * @param {StoryVersionCreateArgs} args - Arguments to create a StoryVersion.
     * @example
     * // Create one StoryVersion
     * const StoryVersion = await prisma.storyVersion.create({
     *   data: {
     *     // ... data to create a StoryVersion
     *   }
     * })
     * 
     */
    create<T extends StoryVersionCreateArgs>(args: SelectSubset<T, StoryVersionCreateArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoryVersions.
     * @param {StoryVersionCreateManyArgs} args - Arguments to create many StoryVersions.
     * @example
     * // Create many StoryVersions
     * const storyVersion = await prisma.storyVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryVersionCreateManyArgs>(args?: SelectSubset<T, StoryVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoryVersions and returns the data saved in the database.
     * @param {StoryVersionCreateManyAndReturnArgs} args - Arguments to create many StoryVersions.
     * @example
     * // Create many StoryVersions
     * const storyVersion = await prisma.storyVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoryVersions and only return the `id`
     * const storyVersionWithIdOnly = await prisma.storyVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StoryVersion.
     * @param {StoryVersionDeleteArgs} args - Arguments to delete one StoryVersion.
     * @example
     * // Delete one StoryVersion
     * const StoryVersion = await prisma.storyVersion.delete({
     *   where: {
     *     // ... filter to delete one StoryVersion
     *   }
     * })
     * 
     */
    delete<T extends StoryVersionDeleteArgs>(args: SelectSubset<T, StoryVersionDeleteArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoryVersion.
     * @param {StoryVersionUpdateArgs} args - Arguments to update one StoryVersion.
     * @example
     * // Update one StoryVersion
     * const storyVersion = await prisma.storyVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryVersionUpdateArgs>(args: SelectSubset<T, StoryVersionUpdateArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoryVersions.
     * @param {StoryVersionDeleteManyArgs} args - Arguments to filter StoryVersions to delete.
     * @example
     * // Delete a few StoryVersions
     * const { count } = await prisma.storyVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryVersionDeleteManyArgs>(args?: SelectSubset<T, StoryVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoryVersions
     * const storyVersion = await prisma.storyVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryVersionUpdateManyArgs>(args: SelectSubset<T, StoryVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryVersions and returns the data updated in the database.
     * @param {StoryVersionUpdateManyAndReturnArgs} args - Arguments to update many StoryVersions.
     * @example
     * // Update many StoryVersions
     * const storyVersion = await prisma.storyVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StoryVersions and only return the `id`
     * const storyVersionWithIdOnly = await prisma.storyVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StoryVersion.
     * @param {StoryVersionUpsertArgs} args - Arguments to update or create a StoryVersion.
     * @example
     * // Update or create a StoryVersion
     * const storyVersion = await prisma.storyVersion.upsert({
     *   create: {
     *     // ... data to create a StoryVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoryVersion we want to update
     *   }
     * })
     */
    upsert<T extends StoryVersionUpsertArgs>(args: SelectSubset<T, StoryVersionUpsertArgs<ExtArgs>>): Prisma__StoryVersionClient<$Result.GetResult<Prisma.$StoryVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoryVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryVersionCountArgs} args - Arguments to filter StoryVersions to count.
     * @example
     * // Count the number of StoryVersions
     * const count = await prisma.storyVersion.count({
     *   where: {
     *     // ... the filter for the StoryVersions we want to count
     *   }
     * })
    **/
    count<T extends StoryVersionCountArgs>(
      args?: Subset<T, StoryVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoryVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryVersionAggregateArgs>(args: Subset<T, StoryVersionAggregateArgs>): Prisma.PrismaPromise<GetStoryVersionAggregateType<T>>

    /**
     * Group by StoryVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryVersionGroupByArgs['orderBy'] }
        : { orderBy?: StoryVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoryVersion model
   */
  readonly fields: StoryVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoryVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends StoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoryDefaultArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoryVersion model
   */
  interface StoryVersionFieldRefs {
    readonly id: FieldRef<"StoryVersion", 'String'>
    readonly story_id: FieldRef<"StoryVersion", 'String'>
    readonly created_at: FieldRef<"StoryVersion", 'DateTime'>
    readonly version_number: FieldRef<"StoryVersion", 'Int'>
    readonly situation: FieldRef<"StoryVersion", 'String'>
    readonly task: FieldRef<"StoryVersion", 'String'>
    readonly action: FieldRef<"StoryVersion", 'String'>
    readonly result: FieldRef<"StoryVersion", 'String'>
    readonly full_story: FieldRef<"StoryVersion", 'String'>
    readonly metrics: FieldRef<"StoryVersion", 'Json'>
    readonly change_summary: FieldRef<"StoryVersion", 'String'>
    readonly created_by_ai: FieldRef<"StoryVersion", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * StoryVersion findUnique
   */
  export type StoryVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * Filter, which StoryVersion to fetch.
     */
    where: StoryVersionWhereUniqueInput
  }

  /**
   * StoryVersion findUniqueOrThrow
   */
  export type StoryVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * Filter, which StoryVersion to fetch.
     */
    where: StoryVersionWhereUniqueInput
  }

  /**
   * StoryVersion findFirst
   */
  export type StoryVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * Filter, which StoryVersion to fetch.
     */
    where?: StoryVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryVersions to fetch.
     */
    orderBy?: StoryVersionOrderByWithRelationInput | StoryVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryVersions.
     */
    cursor?: StoryVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryVersions.
     */
    distinct?: StoryVersionScalarFieldEnum | StoryVersionScalarFieldEnum[]
  }

  /**
   * StoryVersion findFirstOrThrow
   */
  export type StoryVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * Filter, which StoryVersion to fetch.
     */
    where?: StoryVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryVersions to fetch.
     */
    orderBy?: StoryVersionOrderByWithRelationInput | StoryVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryVersions.
     */
    cursor?: StoryVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryVersions.
     */
    distinct?: StoryVersionScalarFieldEnum | StoryVersionScalarFieldEnum[]
  }

  /**
   * StoryVersion findMany
   */
  export type StoryVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * Filter, which StoryVersions to fetch.
     */
    where?: StoryVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryVersions to fetch.
     */
    orderBy?: StoryVersionOrderByWithRelationInput | StoryVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoryVersions.
     */
    cursor?: StoryVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryVersions.
     */
    skip?: number
    distinct?: StoryVersionScalarFieldEnum | StoryVersionScalarFieldEnum[]
  }

  /**
   * StoryVersion create
   */
  export type StoryVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a StoryVersion.
     */
    data: XOR<StoryVersionCreateInput, StoryVersionUncheckedCreateInput>
  }

  /**
   * StoryVersion createMany
   */
  export type StoryVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoryVersions.
     */
    data: StoryVersionCreateManyInput | StoryVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoryVersion createManyAndReturn
   */
  export type StoryVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * The data used to create many StoryVersions.
     */
    data: StoryVersionCreateManyInput | StoryVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryVersion update
   */
  export type StoryVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a StoryVersion.
     */
    data: XOR<StoryVersionUpdateInput, StoryVersionUncheckedUpdateInput>
    /**
     * Choose, which StoryVersion to update.
     */
    where: StoryVersionWhereUniqueInput
  }

  /**
   * StoryVersion updateMany
   */
  export type StoryVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoryVersions.
     */
    data: XOR<StoryVersionUpdateManyMutationInput, StoryVersionUncheckedUpdateManyInput>
    /**
     * Filter which StoryVersions to update
     */
    where?: StoryVersionWhereInput
    /**
     * Limit how many StoryVersions to update.
     */
    limit?: number
  }

  /**
   * StoryVersion updateManyAndReturn
   */
  export type StoryVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * The data used to update StoryVersions.
     */
    data: XOR<StoryVersionUpdateManyMutationInput, StoryVersionUncheckedUpdateManyInput>
    /**
     * Filter which StoryVersions to update
     */
    where?: StoryVersionWhereInput
    /**
     * Limit how many StoryVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryVersion upsert
   */
  export type StoryVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the StoryVersion to update in case it exists.
     */
    where: StoryVersionWhereUniqueInput
    /**
     * In case the StoryVersion found by the `where` argument doesn't exist, create a new StoryVersion with this data.
     */
    create: XOR<StoryVersionCreateInput, StoryVersionUncheckedCreateInput>
    /**
     * In case the StoryVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryVersionUpdateInput, StoryVersionUncheckedUpdateInput>
  }

  /**
   * StoryVersion delete
   */
  export type StoryVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
    /**
     * Filter which StoryVersion to delete.
     */
    where: StoryVersionWhereUniqueInput
  }

  /**
   * StoryVersion deleteMany
   */
  export type StoryVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryVersions to delete
     */
    where?: StoryVersionWhereInput
    /**
     * Limit how many StoryVersions to delete.
     */
    limit?: number
  }

  /**
   * StoryVersion without action
   */
  export type StoryVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryVersion
     */
    select?: StoryVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryVersion
     */
    omit?: StoryVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryVersionInclude<ExtArgs> | null
  }


  /**
   * Model StorySkill
   */

  export type AggregateStorySkill = {
    _count: StorySkillCountAggregateOutputType | null
    _min: StorySkillMinAggregateOutputType | null
    _max: StorySkillMaxAggregateOutputType | null
  }

  export type StorySkillMinAggregateOutputType = {
    id: string | null
    story_id: string | null
    skill_id: string | null
    created_at: Date | null
  }

  export type StorySkillMaxAggregateOutputType = {
    id: string | null
    story_id: string | null
    skill_id: string | null
    created_at: Date | null
  }

  export type StorySkillCountAggregateOutputType = {
    id: number
    story_id: number
    skill_id: number
    created_at: number
    _all: number
  }


  export type StorySkillMinAggregateInputType = {
    id?: true
    story_id?: true
    skill_id?: true
    created_at?: true
  }

  export type StorySkillMaxAggregateInputType = {
    id?: true
    story_id?: true
    skill_id?: true
    created_at?: true
  }

  export type StorySkillCountAggregateInputType = {
    id?: true
    story_id?: true
    skill_id?: true
    created_at?: true
    _all?: true
  }

  export type StorySkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorySkill to aggregate.
     */
    where?: StorySkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorySkills to fetch.
     */
    orderBy?: StorySkillOrderByWithRelationInput | StorySkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorySkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorySkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorySkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorySkills
    **/
    _count?: true | StorySkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorySkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorySkillMaxAggregateInputType
  }

  export type GetStorySkillAggregateType<T extends StorySkillAggregateArgs> = {
        [P in keyof T & keyof AggregateStorySkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorySkill[P]>
      : GetScalarType<T[P], AggregateStorySkill[P]>
  }




  export type StorySkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorySkillWhereInput
    orderBy?: StorySkillOrderByWithAggregationInput | StorySkillOrderByWithAggregationInput[]
    by: StorySkillScalarFieldEnum[] | StorySkillScalarFieldEnum
    having?: StorySkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorySkillCountAggregateInputType | true
    _min?: StorySkillMinAggregateInputType
    _max?: StorySkillMaxAggregateInputType
  }

  export type StorySkillGroupByOutputType = {
    id: string
    story_id: string
    skill_id: string
    created_at: Date
    _count: StorySkillCountAggregateOutputType | null
    _min: StorySkillMinAggregateOutputType | null
    _max: StorySkillMaxAggregateOutputType | null
  }

  type GetStorySkillGroupByPayload<T extends StorySkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorySkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorySkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorySkillGroupByOutputType[P]>
            : GetScalarType<T[P], StorySkillGroupByOutputType[P]>
        }
      >
    >


  export type StorySkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    story_id?: boolean
    skill_id?: boolean
    created_at?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storySkill"]>

  export type StorySkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    story_id?: boolean
    skill_id?: boolean
    created_at?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storySkill"]>

  export type StorySkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    story_id?: boolean
    skill_id?: boolean
    created_at?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storySkill"]>

  export type StorySkillSelectScalar = {
    id?: boolean
    story_id?: boolean
    skill_id?: boolean
    created_at?: boolean
  }

  export type StorySkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "story_id" | "skill_id" | "created_at", ExtArgs["result"]["storySkill"]>
  export type StorySkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type StorySkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type StorySkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $StorySkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorySkill"
    objects: {
      story: Prisma.$StoryPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      story_id: string
      skill_id: string
      created_at: Date
    }, ExtArgs["result"]["storySkill"]>
    composites: {}
  }

  type StorySkillGetPayload<S extends boolean | null | undefined | StorySkillDefaultArgs> = $Result.GetResult<Prisma.$StorySkillPayload, S>

  type StorySkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StorySkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StorySkillCountAggregateInputType | true
    }

  export interface StorySkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorySkill'], meta: { name: 'StorySkill' } }
    /**
     * Find zero or one StorySkill that matches the filter.
     * @param {StorySkillFindUniqueArgs} args - Arguments to find a StorySkill
     * @example
     * // Get one StorySkill
     * const storySkill = await prisma.storySkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StorySkillFindUniqueArgs>(args: SelectSubset<T, StorySkillFindUniqueArgs<ExtArgs>>): Prisma__StorySkillClient<$Result.GetResult<Prisma.$StorySkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StorySkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StorySkillFindUniqueOrThrowArgs} args - Arguments to find a StorySkill
     * @example
     * // Get one StorySkill
     * const storySkill = await prisma.storySkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StorySkillFindUniqueOrThrowArgs>(args: SelectSubset<T, StorySkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StorySkillClient<$Result.GetResult<Prisma.$StorySkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StorySkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorySkillFindFirstArgs} args - Arguments to find a StorySkill
     * @example
     * // Get one StorySkill
     * const storySkill = await prisma.storySkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StorySkillFindFirstArgs>(args?: SelectSubset<T, StorySkillFindFirstArgs<ExtArgs>>): Prisma__StorySkillClient<$Result.GetResult<Prisma.$StorySkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StorySkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorySkillFindFirstOrThrowArgs} args - Arguments to find a StorySkill
     * @example
     * // Get one StorySkill
     * const storySkill = await prisma.storySkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StorySkillFindFirstOrThrowArgs>(args?: SelectSubset<T, StorySkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__StorySkillClient<$Result.GetResult<Prisma.$StorySkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StorySkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorySkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorySkills
     * const storySkills = await prisma.storySkill.findMany()
     * 
     * // Get first 10 StorySkills
     * const storySkills = await prisma.storySkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storySkillWithIdOnly = await prisma.storySkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StorySkillFindManyArgs>(args?: SelectSubset<T, StorySkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorySkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StorySkill.
     * @param {StorySkillCreateArgs} args - Arguments to create a StorySkill.
     * @example
     * // Create one StorySkill
     * const StorySkill = await prisma.storySkill.create({
     *   data: {
     *     // ... data to create a StorySkill
     *   }
     * })
     * 
     */
    create<T extends StorySkillCreateArgs>(args: SelectSubset<T, StorySkillCreateArgs<ExtArgs>>): Prisma__StorySkillClient<$Result.GetResult<Prisma.$StorySkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StorySkills.
     * @param {StorySkillCreateManyArgs} args - Arguments to create many StorySkills.
     * @example
     * // Create many StorySkills
     * const storySkill = await prisma.storySkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StorySkillCreateManyArgs>(args?: SelectSubset<T, StorySkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StorySkills and returns the data saved in the database.
     * @param {StorySkillCreateManyAndReturnArgs} args - Arguments to create many StorySkills.
     * @example
     * // Create many StorySkills
     * const storySkill = await prisma.storySkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StorySkills and only return the `id`
     * const storySkillWithIdOnly = await prisma.storySkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StorySkillCreateManyAndReturnArgs>(args?: SelectSubset<T, StorySkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorySkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StorySkill.
     * @param {StorySkillDeleteArgs} args - Arguments to delete one StorySkill.
     * @example
     * // Delete one StorySkill
     * const StorySkill = await prisma.storySkill.delete({
     *   where: {
     *     // ... filter to delete one StorySkill
     *   }
     * })
     * 
     */
    delete<T extends StorySkillDeleteArgs>(args: SelectSubset<T, StorySkillDeleteArgs<ExtArgs>>): Prisma__StorySkillClient<$Result.GetResult<Prisma.$StorySkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StorySkill.
     * @param {StorySkillUpdateArgs} args - Arguments to update one StorySkill.
     * @example
     * // Update one StorySkill
     * const storySkill = await prisma.storySkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StorySkillUpdateArgs>(args: SelectSubset<T, StorySkillUpdateArgs<ExtArgs>>): Prisma__StorySkillClient<$Result.GetResult<Prisma.$StorySkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StorySkills.
     * @param {StorySkillDeleteManyArgs} args - Arguments to filter StorySkills to delete.
     * @example
     * // Delete a few StorySkills
     * const { count } = await prisma.storySkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StorySkillDeleteManyArgs>(args?: SelectSubset<T, StorySkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorySkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorySkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorySkills
     * const storySkill = await prisma.storySkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StorySkillUpdateManyArgs>(args: SelectSubset<T, StorySkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorySkills and returns the data updated in the database.
     * @param {StorySkillUpdateManyAndReturnArgs} args - Arguments to update many StorySkills.
     * @example
     * // Update many StorySkills
     * const storySkill = await prisma.storySkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StorySkills and only return the `id`
     * const storySkillWithIdOnly = await prisma.storySkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StorySkillUpdateManyAndReturnArgs>(args: SelectSubset<T, StorySkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorySkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StorySkill.
     * @param {StorySkillUpsertArgs} args - Arguments to update or create a StorySkill.
     * @example
     * // Update or create a StorySkill
     * const storySkill = await prisma.storySkill.upsert({
     *   create: {
     *     // ... data to create a StorySkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorySkill we want to update
     *   }
     * })
     */
    upsert<T extends StorySkillUpsertArgs>(args: SelectSubset<T, StorySkillUpsertArgs<ExtArgs>>): Prisma__StorySkillClient<$Result.GetResult<Prisma.$StorySkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StorySkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorySkillCountArgs} args - Arguments to filter StorySkills to count.
     * @example
     * // Count the number of StorySkills
     * const count = await prisma.storySkill.count({
     *   where: {
     *     // ... the filter for the StorySkills we want to count
     *   }
     * })
    **/
    count<T extends StorySkillCountArgs>(
      args?: Subset<T, StorySkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorySkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorySkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorySkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorySkillAggregateArgs>(args: Subset<T, StorySkillAggregateArgs>): Prisma.PrismaPromise<GetStorySkillAggregateType<T>>

    /**
     * Group by StorySkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorySkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorySkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorySkillGroupByArgs['orderBy'] }
        : { orderBy?: StorySkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorySkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorySkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorySkill model
   */
  readonly fields: StorySkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorySkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorySkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends StoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoryDefaultArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StorySkill model
   */
  interface StorySkillFieldRefs {
    readonly id: FieldRef<"StorySkill", 'String'>
    readonly story_id: FieldRef<"StorySkill", 'String'>
    readonly skill_id: FieldRef<"StorySkill", 'String'>
    readonly created_at: FieldRef<"StorySkill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StorySkill findUnique
   */
  export type StorySkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorySkill
     */
    select?: StorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorySkill
     */
    omit?: StorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorySkillInclude<ExtArgs> | null
    /**
     * Filter, which StorySkill to fetch.
     */
    where: StorySkillWhereUniqueInput
  }

  /**
   * StorySkill findUniqueOrThrow
   */
  export type StorySkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorySkill
     */
    select?: StorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorySkill
     */
    omit?: StorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorySkillInclude<ExtArgs> | null
    /**
     * Filter, which StorySkill to fetch.
     */
    where: StorySkillWhereUniqueInput
  }

  /**
   * StorySkill findFirst
   */
  export type StorySkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorySkill
     */
    select?: StorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorySkill
     */
    omit?: StorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorySkillInclude<ExtArgs> | null
    /**
     * Filter, which StorySkill to fetch.
     */
    where?: StorySkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorySkills to fetch.
     */
    orderBy?: StorySkillOrderByWithRelationInput | StorySkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorySkills.
     */
    cursor?: StorySkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorySkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorySkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorySkills.
     */
    distinct?: StorySkillScalarFieldEnum | StorySkillScalarFieldEnum[]
  }

  /**
   * StorySkill findFirstOrThrow
   */
  export type StorySkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorySkill
     */
    select?: StorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorySkill
     */
    omit?: StorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorySkillInclude<ExtArgs> | null
    /**
     * Filter, which StorySkill to fetch.
     */
    where?: StorySkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorySkills to fetch.
     */
    orderBy?: StorySkillOrderByWithRelationInput | StorySkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorySkills.
     */
    cursor?: StorySkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorySkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorySkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorySkills.
     */
    distinct?: StorySkillScalarFieldEnum | StorySkillScalarFieldEnum[]
  }

  /**
   * StorySkill findMany
   */
  export type StorySkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorySkill
     */
    select?: StorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorySkill
     */
    omit?: StorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorySkillInclude<ExtArgs> | null
    /**
     * Filter, which StorySkills to fetch.
     */
    where?: StorySkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorySkills to fetch.
     */
    orderBy?: StorySkillOrderByWithRelationInput | StorySkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorySkills.
     */
    cursor?: StorySkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorySkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorySkills.
     */
    skip?: number
    distinct?: StorySkillScalarFieldEnum | StorySkillScalarFieldEnum[]
  }

  /**
   * StorySkill create
   */
  export type StorySkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorySkill
     */
    select?: StorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorySkill
     */
    omit?: StorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorySkillInclude<ExtArgs> | null
    /**
     * The data needed to create a StorySkill.
     */
    data: XOR<StorySkillCreateInput, StorySkillUncheckedCreateInput>
  }

  /**
   * StorySkill createMany
   */
  export type StorySkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorySkills.
     */
    data: StorySkillCreateManyInput | StorySkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorySkill createManyAndReturn
   */
  export type StorySkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorySkill
     */
    select?: StorySkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StorySkill
     */
    omit?: StorySkillOmit<ExtArgs> | null
    /**
     * The data used to create many StorySkills.
     */
    data: StorySkillCreateManyInput | StorySkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorySkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StorySkill update
   */
  export type StorySkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorySkill
     */
    select?: StorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorySkill
     */
    omit?: StorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorySkillInclude<ExtArgs> | null
    /**
     * The data needed to update a StorySkill.
     */
    data: XOR<StorySkillUpdateInput, StorySkillUncheckedUpdateInput>
    /**
     * Choose, which StorySkill to update.
     */
    where: StorySkillWhereUniqueInput
  }

  /**
   * StorySkill updateMany
   */
  export type StorySkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorySkills.
     */
    data: XOR<StorySkillUpdateManyMutationInput, StorySkillUncheckedUpdateManyInput>
    /**
     * Filter which StorySkills to update
     */
    where?: StorySkillWhereInput
    /**
     * Limit how many StorySkills to update.
     */
    limit?: number
  }

  /**
   * StorySkill updateManyAndReturn
   */
  export type StorySkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorySkill
     */
    select?: StorySkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StorySkill
     */
    omit?: StorySkillOmit<ExtArgs> | null
    /**
     * The data used to update StorySkills.
     */
    data: XOR<StorySkillUpdateManyMutationInput, StorySkillUncheckedUpdateManyInput>
    /**
     * Filter which StorySkills to update
     */
    where?: StorySkillWhereInput
    /**
     * Limit how many StorySkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorySkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StorySkill upsert
   */
  export type StorySkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorySkill
     */
    select?: StorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorySkill
     */
    omit?: StorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorySkillInclude<ExtArgs> | null
    /**
     * The filter to search for the StorySkill to update in case it exists.
     */
    where: StorySkillWhereUniqueInput
    /**
     * In case the StorySkill found by the `where` argument doesn't exist, create a new StorySkill with this data.
     */
    create: XOR<StorySkillCreateInput, StorySkillUncheckedCreateInput>
    /**
     * In case the StorySkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorySkillUpdateInput, StorySkillUncheckedUpdateInput>
  }

  /**
   * StorySkill delete
   */
  export type StorySkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorySkill
     */
    select?: StorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorySkill
     */
    omit?: StorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorySkillInclude<ExtArgs> | null
    /**
     * Filter which StorySkill to delete.
     */
    where: StorySkillWhereUniqueInput
  }

  /**
   * StorySkill deleteMany
   */
  export type StorySkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorySkills to delete
     */
    where?: StorySkillWhereInput
    /**
     * Limit how many StorySkills to delete.
     */
    limit?: number
  }

  /**
   * StorySkill without action
   */
  export type StorySkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorySkill
     */
    select?: StorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorySkill
     */
    omit?: StorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorySkillInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ExportHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    format: 'format',
    filename: 'filename',
    fileUrl: 'fileUrl',
    settings: 'settings',
    createdAt: 'createdAt'
  };

  export type ExportHistoryScalarFieldEnum = (typeof ExportHistoryScalarFieldEnum)[keyof typeof ExportHistoryScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    full_name: 'full_name',
    preferred_name: 'preferred_name',
    headline: 'headline',
    summary: 'summary',
    location: 'location',
    website: 'website',
    email: 'email',
    phone: 'phone',
    about: 'about',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const ParsedDocumentScalarFieldEnum: {
    id: 'id',
    profile_id: 'profile_id',
    user_id: 'user_id',
    file_name: 'file_name',
    storage_path: 'storage_path',
    content_type: 'content_type',
    size_bytes: 'size_bytes',
    text_extracted: 'text_extracted',
    parsed_json: 'parsed_json',
    parser_version: 'parser_version',
    status: 'status',
    error_text: 'error_text',
    parsed_at: 'parsed_at',
    created_at: 'created_at'
  };

  export type ParsedDocumentScalarFieldEnum = (typeof ParsedDocumentScalarFieldEnum)[keyof typeof ParsedDocumentScalarFieldEnum]


  export const ExperienceScalarFieldEnum: {
    id: 'id',
    profile_id: 'profile_id',
    title: 'title',
    company: 'company',
    location: 'location',
    start_date: 'start_date',
    end_date: 'end_date',
    is_current: 'is_current',
    description: 'description',
    raw_json: 'raw_json',
    order_index: 'order_index',
    created_at: 'created_at'
  };

  export type ExperienceScalarFieldEnum = (typeof ExperienceScalarFieldEnum)[keyof typeof ExperienceScalarFieldEnum]


  export const EducationScalarFieldEnum: {
    id: 'id',
    profile_id: 'profile_id',
    school: 'school',
    degree: 'degree',
    field_of_study: 'field_of_study',
    start_year: 'start_year',
    end_year: 'end_year',
    description: 'description',
    raw_json: 'raw_json',
    created_at: 'created_at'
  };

  export type EducationScalarFieldEnum = (typeof EducationScalarFieldEnum)[keyof typeof EducationScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    profile_id: 'profile_id',
    skill: 'skill',
    confidence: 'confidence',
    raw_json: 'raw_json',
    created_at: 'created_at'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const CertificationScalarFieldEnum: {
    id: 'id',
    profile_id: 'profile_id',
    name: 'name',
    authority: 'authority',
    issued_date: 'issued_date',
    expiry_date: 'expiry_date',
    raw_json: 'raw_json',
    created_at: 'created_at'
  };

  export type CertificationScalarFieldEnum = (typeof CertificationScalarFieldEnum)[keyof typeof CertificationScalarFieldEnum]


  export const ParsingJobScalarFieldEnum: {
    id: 'id',
    parsed_document_id: 'parsed_document_id',
    status: 'status',
    attempts: 'attempts',
    worker: 'worker',
    started_at: 'started_at',
    finished_at: 'finished_at',
    created_at: 'created_at'
  };

  export type ParsingJobScalarFieldEnum = (typeof ParsingJobScalarFieldEnum)[keyof typeof ParsingJobScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    profile_id: 'profile_id',
    name: 'name',
    authority: 'authority',
    issued_date: 'issued_date',
    expiry_date: 'expiry_date',
    raw_json: 'raw_json',
    created_at: 'created_at'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const VolunteeringScalarFieldEnum: {
    id: 'id',
    profile_id: 'profile_id',
    name: 'name',
    authority: 'authority',
    issued_date: 'issued_date',
    expiry_date: 'expiry_date',
    raw_json: 'raw_json',
    created_at: 'created_at'
  };

  export type VolunteeringScalarFieldEnum = (typeof VolunteeringScalarFieldEnum)[keyof typeof VolunteeringScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    profile_id: 'profile_id',
    language: 'language',
    proficiency: 'proficiency',
    raw_json: 'raw_json',
    created_at: 'created_at'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    profile_id: 'profile_id',
    name: 'name',
    authority: 'authority',
    issued_date: 'issued_date',
    expiry_date: 'expiry_date',
    raw_json: 'raw_json',
    created_at: 'created_at'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const MediaLibraryScalarFieldEnum: {
    id: 'id',
    profile_id: 'profile_id',
    file_name: 'file_name',
    file_type: 'file_type',
    mime_type: 'mime_type',
    file_size: 'file_size',
    storage_path: 'storage_path',
    storage_bucket: 'storage_bucket',
    title: 'title',
    description: 'description',
    tags: 'tags',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MediaLibraryScalarFieldEnum = (typeof MediaLibraryScalarFieldEnum)[keyof typeof MediaLibraryScalarFieldEnum]


  export const PersonalityAssessmentScalarFieldEnum: {
    id: 'id',
    users_id: 'users_id',
    assessment_date: 'assessment_date',
    completed: 'completed',
    time_taken_seconds: 'time_taken_seconds',
    openness_score: 'openness_score',
    conscientiousness_score: 'conscientiousness_score',
    extraversion_score: 'extraversion_score',
    agreeableness_score: 'agreeableness_score',
    emotional_stability_score: 'emotional_stability_score',
    overall_score: 'overall_score',
    responses: 'responses',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PersonalityAssessmentScalarFieldEnum = (typeof PersonalityAssessmentScalarFieldEnum)[keyof typeof PersonalityAssessmentScalarFieldEnum]


  export const PersonalityResponseScalarFieldEnum: {
    id: 'id',
    assessment_id: 'assessment_id',
    question_id: 'question_id',
    question_text: 'question_text',
    dimension: 'dimension',
    response_value: 'response_value',
    created_at: 'created_at'
  };

  export type PersonalityResponseScalarFieldEnum = (typeof PersonalityResponseScalarFieldEnum)[keyof typeof PersonalityResponseScalarFieldEnum]


  export const AppAdminScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    role: 'role',
    permissions: 'permissions',
    is_active: 'is_active',
    email: 'email',
    full_name: 'full_name',
    department: 'department',
    access_level: 'access_level',
    allowed_actions: 'allowed_actions',
    restricted_actions: 'restricted_actions',
    last_login_at: 'last_login_at',
    last_activity_at: 'last_activity_at',
    login_count: 'login_count',
    failed_login_attempts: 'failed_login_attempts',
    account_locked_until: 'account_locked_until',
    must_change_password: 'must_change_password',
    two_factor_enabled: 'two_factor_enabled',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_by: 'updated_by',
    updated_at: 'updated_at',
    deactivated_at: 'deactivated_at',
    deactivated_by: 'deactivated_by',
    deactivation_reason: 'deactivation_reason',
    notes: 'notes',
    metadata: 'metadata'
  };

  export type AppAdminScalarFieldEnum = (typeof AppAdminScalarFieldEnum)[keyof typeof AppAdminScalarFieldEnum]


  export const TalentStoryScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    story: 'story',
    data: 'data',
    model: 'model',
    created_at: 'created_at',
    updated_at: 'updated_at',
    version: 'version',
    is_active: 'is_active'
  };

  export type TalentStoryScalarFieldEnum = (typeof TalentStoryScalarFieldEnum)[keyof typeof TalentStoryScalarFieldEnum]


  export const JobPostScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    title: 'title',
    company: 'company',
    location: 'location',
    raw_description: 'raw_description',
    job_url: 'job_url',
    parsed_data: 'parsed_data',
    created_at: 'created_at',
    updated_at: 'updated_at',
    status: 'status',
    applied_at: 'applied_at'
  };

  export type JobPostScalarFieldEnum = (typeof JobPostScalarFieldEnum)[keyof typeof JobPostScalarFieldEnum]


  export const CustomizedStoryScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    profile_id: 'profile_id',
    job_post_id: 'job_post_id',
    story: 'story',
    reordered_experience: 'reordered_experience',
    highlighted_skills: 'highlighted_skills',
    match_score: 'match_score',
    score_breakdown: 'score_breakdown',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_active: 'is_active',
    version_name: 'version_name'
  };

  export type CustomizedStoryScalarFieldEnum = (typeof CustomizedStoryScalarFieldEnum)[keyof typeof CustomizedStoryScalarFieldEnum]


  export const StoryScalarFieldEnum: {
    id: 'id',
    experience_id: 'experience_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    situation: 'situation',
    task: 'task',
    action: 'action',
    result: 'result',
    full_story: 'full_story',
    ai_generated: 'ai_generated',
    metrics: 'metrics',
    title: 'title',
    tags: 'tags',
    is_draft: 'is_draft',
    relevance_score: 'relevance_score',
    job_match_scores: 'job_match_scores'
  };

  export type StoryScalarFieldEnum = (typeof StoryScalarFieldEnum)[keyof typeof StoryScalarFieldEnum]


  export const StoryVersionScalarFieldEnum: {
    id: 'id',
    story_id: 'story_id',
    created_at: 'created_at',
    version_number: 'version_number',
    situation: 'situation',
    task: 'task',
    action: 'action',
    result: 'result',
    full_story: 'full_story',
    metrics: 'metrics',
    change_summary: 'change_summary',
    created_by_ai: 'created_by_ai'
  };

  export type StoryVersionScalarFieldEnum = (typeof StoryVersionScalarFieldEnum)[keyof typeof StoryVersionScalarFieldEnum]


  export const StorySkillScalarFieldEnum: {
    id: 'id',
    story_id: 'story_id',
    skill_id: 'skill_id',
    created_at: 'created_at'
  };

  export type StorySkillScalarFieldEnum = (typeof StorySkillScalarFieldEnum)[keyof typeof StorySkillScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ExportHistoryWhereInput = {
    AND?: ExportHistoryWhereInput | ExportHistoryWhereInput[]
    OR?: ExportHistoryWhereInput[]
    NOT?: ExportHistoryWhereInput | ExportHistoryWhereInput[]
    id?: StringFilter<"ExportHistory"> | string
    userId?: StringFilter<"ExportHistory"> | string
    format?: StringFilter<"ExportHistory"> | string
    filename?: StringFilter<"ExportHistory"> | string
    fileUrl?: StringFilter<"ExportHistory"> | string
    settings?: JsonNullableFilter<"ExportHistory">
    createdAt?: DateTimeFilter<"ExportHistory"> | Date | string
  }

  export type ExportHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    filename?: SortOrder
    fileUrl?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ExportHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExportHistoryWhereInput | ExportHistoryWhereInput[]
    OR?: ExportHistoryWhereInput[]
    NOT?: ExportHistoryWhereInput | ExportHistoryWhereInput[]
    userId?: StringFilter<"ExportHistory"> | string
    format?: StringFilter<"ExportHistory"> | string
    filename?: StringFilter<"ExportHistory"> | string
    fileUrl?: StringFilter<"ExportHistory"> | string
    settings?: JsonNullableFilter<"ExportHistory">
    createdAt?: DateTimeFilter<"ExportHistory"> | Date | string
  }, "id">

  export type ExportHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    filename?: SortOrder
    fileUrl?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ExportHistoryCountOrderByAggregateInput
    _max?: ExportHistoryMaxOrderByAggregateInput
    _min?: ExportHistoryMinOrderByAggregateInput
  }

  export type ExportHistoryScalarWhereWithAggregatesInput = {
    AND?: ExportHistoryScalarWhereWithAggregatesInput | ExportHistoryScalarWhereWithAggregatesInput[]
    OR?: ExportHistoryScalarWhereWithAggregatesInput[]
    NOT?: ExportHistoryScalarWhereWithAggregatesInput | ExportHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExportHistory"> | string
    userId?: StringWithAggregatesFilter<"ExportHistory"> | string
    format?: StringWithAggregatesFilter<"ExportHistory"> | string
    filename?: StringWithAggregatesFilter<"ExportHistory"> | string
    fileUrl?: StringWithAggregatesFilter<"ExportHistory"> | string
    settings?: JsonNullableWithAggregatesFilter<"ExportHistory">
    createdAt?: DateTimeWithAggregatesFilter<"ExportHistory"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    user_id?: StringNullableFilter<"Profile"> | string | null
    full_name?: StringNullableFilter<"Profile"> | string | null
    preferred_name?: StringNullableFilter<"Profile"> | string | null
    headline?: StringNullableFilter<"Profile"> | string | null
    summary?: StringNullableFilter<"Profile"> | string | null
    location?: StringNullableFilter<"Profile"> | string | null
    website?: StringNullableFilter<"Profile"> | string | null
    email?: StringNullableFilter<"Profile"> | string | null
    phone?: StringNullableFilter<"Profile"> | string | null
    about?: StringNullableFilter<"Profile"> | string | null
    created_at?: DateTimeFilter<"Profile"> | Date | string
    updated_at?: DateTimeFilter<"Profile"> | Date | string
    experiences?: ExperienceListRelationFilter
    education?: EducationListRelationFilter
    skills?: SkillListRelationFilter
    certifications?: CertificationListRelationFilter
    projects?: ProjectListRelationFilter
    volunteering?: VolunteeringListRelationFilter
    languages?: LanguageListRelationFilter
    organizations?: OrganizationListRelationFilter
    parsed_documents?: ParsedDocumentListRelationFilter
    mediaLibrary?: MediaLibraryListRelationFilter
    customizedStories?: CustomizedStoryListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    full_name?: SortOrderInput | SortOrder
    preferred_name?: SortOrderInput | SortOrder
    headline?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    about?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    experiences?: ExperienceOrderByRelationAggregateInput
    education?: EducationOrderByRelationAggregateInput
    skills?: SkillOrderByRelationAggregateInput
    certifications?: CertificationOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    volunteering?: VolunteeringOrderByRelationAggregateInput
    languages?: LanguageOrderByRelationAggregateInput
    organizations?: OrganizationOrderByRelationAggregateInput
    parsed_documents?: ParsedDocumentOrderByRelationAggregateInput
    mediaLibrary?: MediaLibraryOrderByRelationAggregateInput
    customizedStories?: CustomizedStoryOrderByRelationAggregateInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    user_id?: StringNullableFilter<"Profile"> | string | null
    full_name?: StringNullableFilter<"Profile"> | string | null
    preferred_name?: StringNullableFilter<"Profile"> | string | null
    headline?: StringNullableFilter<"Profile"> | string | null
    summary?: StringNullableFilter<"Profile"> | string | null
    location?: StringNullableFilter<"Profile"> | string | null
    website?: StringNullableFilter<"Profile"> | string | null
    email?: StringNullableFilter<"Profile"> | string | null
    phone?: StringNullableFilter<"Profile"> | string | null
    about?: StringNullableFilter<"Profile"> | string | null
    created_at?: DateTimeFilter<"Profile"> | Date | string
    updated_at?: DateTimeFilter<"Profile"> | Date | string
    experiences?: ExperienceListRelationFilter
    education?: EducationListRelationFilter
    skills?: SkillListRelationFilter
    certifications?: CertificationListRelationFilter
    projects?: ProjectListRelationFilter
    volunteering?: VolunteeringListRelationFilter
    languages?: LanguageListRelationFilter
    organizations?: OrganizationListRelationFilter
    parsed_documents?: ParsedDocumentListRelationFilter
    mediaLibrary?: MediaLibraryListRelationFilter
    customizedStories?: CustomizedStoryListRelationFilter
  }, "id">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    full_name?: SortOrderInput | SortOrder
    preferred_name?: SortOrderInput | SortOrder
    headline?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    about?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    user_id?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    full_name?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    preferred_name?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    headline?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    summary?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    location?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    website?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    email?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    about?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type ParsedDocumentWhereInput = {
    AND?: ParsedDocumentWhereInput | ParsedDocumentWhereInput[]
    OR?: ParsedDocumentWhereInput[]
    NOT?: ParsedDocumentWhereInput | ParsedDocumentWhereInput[]
    id?: StringFilter<"ParsedDocument"> | string
    profile_id?: StringNullableFilter<"ParsedDocument"> | string | null
    user_id?: StringNullableFilter<"ParsedDocument"> | string | null
    file_name?: StringNullableFilter<"ParsedDocument"> | string | null
    storage_path?: StringNullableFilter<"ParsedDocument"> | string | null
    content_type?: StringNullableFilter<"ParsedDocument"> | string | null
    size_bytes?: IntNullableFilter<"ParsedDocument"> | number | null
    text_extracted?: StringNullableFilter<"ParsedDocument"> | string | null
    parsed_json?: JsonNullableFilter<"ParsedDocument">
    parser_version?: StringNullableFilter<"ParsedDocument"> | string | null
    status?: StringNullableFilter<"ParsedDocument"> | string | null
    error_text?: StringNullableFilter<"ParsedDocument"> | string | null
    parsed_at?: DateTimeNullableFilter<"ParsedDocument"> | Date | string | null
    created_at?: DateTimeFilter<"ParsedDocument"> | Date | string
    parsing_jobs?: ParsingJobListRelationFilter
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }

  export type ParsedDocumentOrderByWithRelationInput = {
    id?: SortOrder
    profile_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    file_name?: SortOrderInput | SortOrder
    storage_path?: SortOrderInput | SortOrder
    content_type?: SortOrderInput | SortOrder
    size_bytes?: SortOrderInput | SortOrder
    text_extracted?: SortOrderInput | SortOrder
    parsed_json?: SortOrderInput | SortOrder
    parser_version?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    error_text?: SortOrderInput | SortOrder
    parsed_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    parsing_jobs?: ParsingJobOrderByRelationAggregateInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type ParsedDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParsedDocumentWhereInput | ParsedDocumentWhereInput[]
    OR?: ParsedDocumentWhereInput[]
    NOT?: ParsedDocumentWhereInput | ParsedDocumentWhereInput[]
    profile_id?: StringNullableFilter<"ParsedDocument"> | string | null
    user_id?: StringNullableFilter<"ParsedDocument"> | string | null
    file_name?: StringNullableFilter<"ParsedDocument"> | string | null
    storage_path?: StringNullableFilter<"ParsedDocument"> | string | null
    content_type?: StringNullableFilter<"ParsedDocument"> | string | null
    size_bytes?: IntNullableFilter<"ParsedDocument"> | number | null
    text_extracted?: StringNullableFilter<"ParsedDocument"> | string | null
    parsed_json?: JsonNullableFilter<"ParsedDocument">
    parser_version?: StringNullableFilter<"ParsedDocument"> | string | null
    status?: StringNullableFilter<"ParsedDocument"> | string | null
    error_text?: StringNullableFilter<"ParsedDocument"> | string | null
    parsed_at?: DateTimeNullableFilter<"ParsedDocument"> | Date | string | null
    created_at?: DateTimeFilter<"ParsedDocument"> | Date | string
    parsing_jobs?: ParsingJobListRelationFilter
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }, "id">

  export type ParsedDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    profile_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    file_name?: SortOrderInput | SortOrder
    storage_path?: SortOrderInput | SortOrder
    content_type?: SortOrderInput | SortOrder
    size_bytes?: SortOrderInput | SortOrder
    text_extracted?: SortOrderInput | SortOrder
    parsed_json?: SortOrderInput | SortOrder
    parser_version?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    error_text?: SortOrderInput | SortOrder
    parsed_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ParsedDocumentCountOrderByAggregateInput
    _avg?: ParsedDocumentAvgOrderByAggregateInput
    _max?: ParsedDocumentMaxOrderByAggregateInput
    _min?: ParsedDocumentMinOrderByAggregateInput
    _sum?: ParsedDocumentSumOrderByAggregateInput
  }

  export type ParsedDocumentScalarWhereWithAggregatesInput = {
    AND?: ParsedDocumentScalarWhereWithAggregatesInput | ParsedDocumentScalarWhereWithAggregatesInput[]
    OR?: ParsedDocumentScalarWhereWithAggregatesInput[]
    NOT?: ParsedDocumentScalarWhereWithAggregatesInput | ParsedDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParsedDocument"> | string
    profile_id?: StringNullableWithAggregatesFilter<"ParsedDocument"> | string | null
    user_id?: StringNullableWithAggregatesFilter<"ParsedDocument"> | string | null
    file_name?: StringNullableWithAggregatesFilter<"ParsedDocument"> | string | null
    storage_path?: StringNullableWithAggregatesFilter<"ParsedDocument"> | string | null
    content_type?: StringNullableWithAggregatesFilter<"ParsedDocument"> | string | null
    size_bytes?: IntNullableWithAggregatesFilter<"ParsedDocument"> | number | null
    text_extracted?: StringNullableWithAggregatesFilter<"ParsedDocument"> | string | null
    parsed_json?: JsonNullableWithAggregatesFilter<"ParsedDocument">
    parser_version?: StringNullableWithAggregatesFilter<"ParsedDocument"> | string | null
    status?: StringNullableWithAggregatesFilter<"ParsedDocument"> | string | null
    error_text?: StringNullableWithAggregatesFilter<"ParsedDocument"> | string | null
    parsed_at?: DateTimeNullableWithAggregatesFilter<"ParsedDocument"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"ParsedDocument"> | Date | string
  }

  export type ExperienceWhereInput = {
    AND?: ExperienceWhereInput | ExperienceWhereInput[]
    OR?: ExperienceWhereInput[]
    NOT?: ExperienceWhereInput | ExperienceWhereInput[]
    id?: StringFilter<"Experience"> | string
    profile_id?: StringFilter<"Experience"> | string
    title?: StringNullableFilter<"Experience"> | string | null
    company?: StringNullableFilter<"Experience"> | string | null
    location?: StringNullableFilter<"Experience"> | string | null
    start_date?: DateTimeNullableFilter<"Experience"> | Date | string | null
    end_date?: DateTimeNullableFilter<"Experience"> | Date | string | null
    is_current?: BoolFilter<"Experience"> | boolean
    description?: StringNullableFilter<"Experience"> | string | null
    raw_json?: JsonNullableFilter<"Experience">
    order_index?: IntNullableFilter<"Experience"> | number | null
    created_at?: DateTimeFilter<"Experience"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    stories?: StoryListRelationFilter
  }

  export type ExperienceOrderByWithRelationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    title?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    is_current?: SortOrder
    description?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    order_index?: SortOrderInput | SortOrder
    created_at?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    stories?: StoryOrderByRelationAggregateInput
  }

  export type ExperienceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExperienceWhereInput | ExperienceWhereInput[]
    OR?: ExperienceWhereInput[]
    NOT?: ExperienceWhereInput | ExperienceWhereInput[]
    profile_id?: StringFilter<"Experience"> | string
    title?: StringNullableFilter<"Experience"> | string | null
    company?: StringNullableFilter<"Experience"> | string | null
    location?: StringNullableFilter<"Experience"> | string | null
    start_date?: DateTimeNullableFilter<"Experience"> | Date | string | null
    end_date?: DateTimeNullableFilter<"Experience"> | Date | string | null
    is_current?: BoolFilter<"Experience"> | boolean
    description?: StringNullableFilter<"Experience"> | string | null
    raw_json?: JsonNullableFilter<"Experience">
    order_index?: IntNullableFilter<"Experience"> | number | null
    created_at?: DateTimeFilter<"Experience"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    stories?: StoryListRelationFilter
  }, "id">

  export type ExperienceOrderByWithAggregationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    title?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    is_current?: SortOrder
    description?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    order_index?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ExperienceCountOrderByAggregateInput
    _avg?: ExperienceAvgOrderByAggregateInput
    _max?: ExperienceMaxOrderByAggregateInput
    _min?: ExperienceMinOrderByAggregateInput
    _sum?: ExperienceSumOrderByAggregateInput
  }

  export type ExperienceScalarWhereWithAggregatesInput = {
    AND?: ExperienceScalarWhereWithAggregatesInput | ExperienceScalarWhereWithAggregatesInput[]
    OR?: ExperienceScalarWhereWithAggregatesInput[]
    NOT?: ExperienceScalarWhereWithAggregatesInput | ExperienceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Experience"> | string
    profile_id?: StringWithAggregatesFilter<"Experience"> | string
    title?: StringNullableWithAggregatesFilter<"Experience"> | string | null
    company?: StringNullableWithAggregatesFilter<"Experience"> | string | null
    location?: StringNullableWithAggregatesFilter<"Experience"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"Experience"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"Experience"> | Date | string | null
    is_current?: BoolWithAggregatesFilter<"Experience"> | boolean
    description?: StringNullableWithAggregatesFilter<"Experience"> | string | null
    raw_json?: JsonNullableWithAggregatesFilter<"Experience">
    order_index?: IntNullableWithAggregatesFilter<"Experience"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Experience"> | Date | string
  }

  export type EducationWhereInput = {
    AND?: EducationWhereInput | EducationWhereInput[]
    OR?: EducationWhereInput[]
    NOT?: EducationWhereInput | EducationWhereInput[]
    id?: StringFilter<"Education"> | string
    profile_id?: StringFilter<"Education"> | string
    school?: StringNullableFilter<"Education"> | string | null
    degree?: StringNullableFilter<"Education"> | string | null
    field_of_study?: StringNullableFilter<"Education"> | string | null
    start_year?: IntNullableFilter<"Education"> | number | null
    end_year?: IntNullableFilter<"Education"> | number | null
    description?: StringNullableFilter<"Education"> | string | null
    raw_json?: JsonNullableFilter<"Education">
    created_at?: DateTimeFilter<"Education"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type EducationOrderByWithRelationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    school?: SortOrderInput | SortOrder
    degree?: SortOrderInput | SortOrder
    field_of_study?: SortOrderInput | SortOrder
    start_year?: SortOrderInput | SortOrder
    end_year?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    created_at?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type EducationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EducationWhereInput | EducationWhereInput[]
    OR?: EducationWhereInput[]
    NOT?: EducationWhereInput | EducationWhereInput[]
    profile_id?: StringFilter<"Education"> | string
    school?: StringNullableFilter<"Education"> | string | null
    degree?: StringNullableFilter<"Education"> | string | null
    field_of_study?: StringNullableFilter<"Education"> | string | null
    start_year?: IntNullableFilter<"Education"> | number | null
    end_year?: IntNullableFilter<"Education"> | number | null
    description?: StringNullableFilter<"Education"> | string | null
    raw_json?: JsonNullableFilter<"Education">
    created_at?: DateTimeFilter<"Education"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id">

  export type EducationOrderByWithAggregationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    school?: SortOrderInput | SortOrder
    degree?: SortOrderInput | SortOrder
    field_of_study?: SortOrderInput | SortOrder
    start_year?: SortOrderInput | SortOrder
    end_year?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: EducationCountOrderByAggregateInput
    _avg?: EducationAvgOrderByAggregateInput
    _max?: EducationMaxOrderByAggregateInput
    _min?: EducationMinOrderByAggregateInput
    _sum?: EducationSumOrderByAggregateInput
  }

  export type EducationScalarWhereWithAggregatesInput = {
    AND?: EducationScalarWhereWithAggregatesInput | EducationScalarWhereWithAggregatesInput[]
    OR?: EducationScalarWhereWithAggregatesInput[]
    NOT?: EducationScalarWhereWithAggregatesInput | EducationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Education"> | string
    profile_id?: StringWithAggregatesFilter<"Education"> | string
    school?: StringNullableWithAggregatesFilter<"Education"> | string | null
    degree?: StringNullableWithAggregatesFilter<"Education"> | string | null
    field_of_study?: StringNullableWithAggregatesFilter<"Education"> | string | null
    start_year?: IntNullableWithAggregatesFilter<"Education"> | number | null
    end_year?: IntNullableWithAggregatesFilter<"Education"> | number | null
    description?: StringNullableWithAggregatesFilter<"Education"> | string | null
    raw_json?: JsonNullableWithAggregatesFilter<"Education">
    created_at?: DateTimeWithAggregatesFilter<"Education"> | Date | string
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: StringFilter<"Skill"> | string
    profile_id?: StringFilter<"Skill"> | string
    skill?: StringNullableFilter<"Skill"> | string | null
    confidence?: FloatNullableFilter<"Skill"> | number | null
    raw_json?: JsonNullableFilter<"Skill">
    created_at?: DateTimeFilter<"Skill"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    storySkills?: StorySkillListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    skill?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    created_at?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    storySkills?: StorySkillOrderByRelationAggregateInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    profile_id?: StringFilter<"Skill"> | string
    skill?: StringNullableFilter<"Skill"> | string | null
    confidence?: FloatNullableFilter<"Skill"> | number | null
    raw_json?: JsonNullableFilter<"Skill">
    created_at?: DateTimeFilter<"Skill"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    storySkills?: StorySkillListRelationFilter
  }, "id">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    skill?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: SkillCountOrderByAggregateInput
    _avg?: SkillAvgOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
    _sum?: SkillSumOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Skill"> | string
    profile_id?: StringWithAggregatesFilter<"Skill"> | string
    skill?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    confidence?: FloatNullableWithAggregatesFilter<"Skill"> | number | null
    raw_json?: JsonNullableWithAggregatesFilter<"Skill">
    created_at?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
  }

  export type CertificationWhereInput = {
    AND?: CertificationWhereInput | CertificationWhereInput[]
    OR?: CertificationWhereInput[]
    NOT?: CertificationWhereInput | CertificationWhereInput[]
    id?: StringFilter<"Certification"> | string
    profile_id?: StringFilter<"Certification"> | string
    name?: StringNullableFilter<"Certification"> | string | null
    authority?: StringNullableFilter<"Certification"> | string | null
    issued_date?: DateTimeNullableFilter<"Certification"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"Certification"> | Date | string | null
    raw_json?: JsonNullableFilter<"Certification">
    created_at?: DateTimeFilter<"Certification"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type CertificationOrderByWithRelationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrderInput | SortOrder
    authority?: SortOrderInput | SortOrder
    issued_date?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    created_at?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type CertificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificationWhereInput | CertificationWhereInput[]
    OR?: CertificationWhereInput[]
    NOT?: CertificationWhereInput | CertificationWhereInput[]
    profile_id?: StringFilter<"Certification"> | string
    name?: StringNullableFilter<"Certification"> | string | null
    authority?: StringNullableFilter<"Certification"> | string | null
    issued_date?: DateTimeNullableFilter<"Certification"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"Certification"> | Date | string | null
    raw_json?: JsonNullableFilter<"Certification">
    created_at?: DateTimeFilter<"Certification"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id">

  export type CertificationOrderByWithAggregationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrderInput | SortOrder
    authority?: SortOrderInput | SortOrder
    issued_date?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: CertificationCountOrderByAggregateInput
    _max?: CertificationMaxOrderByAggregateInput
    _min?: CertificationMinOrderByAggregateInput
  }

  export type CertificationScalarWhereWithAggregatesInput = {
    AND?: CertificationScalarWhereWithAggregatesInput | CertificationScalarWhereWithAggregatesInput[]
    OR?: CertificationScalarWhereWithAggregatesInput[]
    NOT?: CertificationScalarWhereWithAggregatesInput | CertificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certification"> | string
    profile_id?: StringWithAggregatesFilter<"Certification"> | string
    name?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    authority?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    issued_date?: DateTimeNullableWithAggregatesFilter<"Certification"> | Date | string | null
    expiry_date?: DateTimeNullableWithAggregatesFilter<"Certification"> | Date | string | null
    raw_json?: JsonNullableWithAggregatesFilter<"Certification">
    created_at?: DateTimeWithAggregatesFilter<"Certification"> | Date | string
  }

  export type ParsingJobWhereInput = {
    AND?: ParsingJobWhereInput | ParsingJobWhereInput[]
    OR?: ParsingJobWhereInput[]
    NOT?: ParsingJobWhereInput | ParsingJobWhereInput[]
    id?: StringFilter<"ParsingJob"> | string
    parsed_document_id?: StringFilter<"ParsingJob"> | string
    status?: StringNullableFilter<"ParsingJob"> | string | null
    attempts?: IntNullableFilter<"ParsingJob"> | number | null
    worker?: StringNullableFilter<"ParsingJob"> | string | null
    started_at?: DateTimeNullableFilter<"ParsingJob"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"ParsingJob"> | Date | string | null
    created_at?: DateTimeFilter<"ParsingJob"> | Date | string
    parsed_document?: XOR<ParsedDocumentScalarRelationFilter, ParsedDocumentWhereInput>
  }

  export type ParsingJobOrderByWithRelationInput = {
    id?: SortOrder
    parsed_document_id?: SortOrder
    status?: SortOrderInput | SortOrder
    attempts?: SortOrderInput | SortOrder
    worker?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    finished_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    parsed_document?: ParsedDocumentOrderByWithRelationInput
  }

  export type ParsingJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParsingJobWhereInput | ParsingJobWhereInput[]
    OR?: ParsingJobWhereInput[]
    NOT?: ParsingJobWhereInput | ParsingJobWhereInput[]
    parsed_document_id?: StringFilter<"ParsingJob"> | string
    status?: StringNullableFilter<"ParsingJob"> | string | null
    attempts?: IntNullableFilter<"ParsingJob"> | number | null
    worker?: StringNullableFilter<"ParsingJob"> | string | null
    started_at?: DateTimeNullableFilter<"ParsingJob"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"ParsingJob"> | Date | string | null
    created_at?: DateTimeFilter<"ParsingJob"> | Date | string
    parsed_document?: XOR<ParsedDocumentScalarRelationFilter, ParsedDocumentWhereInput>
  }, "id">

  export type ParsingJobOrderByWithAggregationInput = {
    id?: SortOrder
    parsed_document_id?: SortOrder
    status?: SortOrderInput | SortOrder
    attempts?: SortOrderInput | SortOrder
    worker?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    finished_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ParsingJobCountOrderByAggregateInput
    _avg?: ParsingJobAvgOrderByAggregateInput
    _max?: ParsingJobMaxOrderByAggregateInput
    _min?: ParsingJobMinOrderByAggregateInput
    _sum?: ParsingJobSumOrderByAggregateInput
  }

  export type ParsingJobScalarWhereWithAggregatesInput = {
    AND?: ParsingJobScalarWhereWithAggregatesInput | ParsingJobScalarWhereWithAggregatesInput[]
    OR?: ParsingJobScalarWhereWithAggregatesInput[]
    NOT?: ParsingJobScalarWhereWithAggregatesInput | ParsingJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParsingJob"> | string
    parsed_document_id?: StringWithAggregatesFilter<"ParsingJob"> | string
    status?: StringNullableWithAggregatesFilter<"ParsingJob"> | string | null
    attempts?: IntNullableWithAggregatesFilter<"ParsingJob"> | number | null
    worker?: StringNullableWithAggregatesFilter<"ParsingJob"> | string | null
    started_at?: DateTimeNullableWithAggregatesFilter<"ParsingJob"> | Date | string | null
    finished_at?: DateTimeNullableWithAggregatesFilter<"ParsingJob"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"ParsingJob"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    profile_id?: StringFilter<"Project"> | string
    name?: StringNullableFilter<"Project"> | string | null
    authority?: StringNullableFilter<"Project"> | string | null
    issued_date?: DateTimeNullableFilter<"Project"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"Project"> | Date | string | null
    raw_json?: JsonNullableFilter<"Project">
    created_at?: DateTimeFilter<"Project"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrderInput | SortOrder
    authority?: SortOrderInput | SortOrder
    issued_date?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    created_at?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    profile_id?: StringFilter<"Project"> | string
    name?: StringNullableFilter<"Project"> | string | null
    authority?: StringNullableFilter<"Project"> | string | null
    issued_date?: DateTimeNullableFilter<"Project"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"Project"> | Date | string | null
    raw_json?: JsonNullableFilter<"Project">
    created_at?: DateTimeFilter<"Project"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrderInput | SortOrder
    authority?: SortOrderInput | SortOrder
    issued_date?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    profile_id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringNullableWithAggregatesFilter<"Project"> | string | null
    authority?: StringNullableWithAggregatesFilter<"Project"> | string | null
    issued_date?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    expiry_date?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    raw_json?: JsonNullableWithAggregatesFilter<"Project">
    created_at?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type VolunteeringWhereInput = {
    AND?: VolunteeringWhereInput | VolunteeringWhereInput[]
    OR?: VolunteeringWhereInput[]
    NOT?: VolunteeringWhereInput | VolunteeringWhereInput[]
    id?: StringFilter<"Volunteering"> | string
    profile_id?: StringFilter<"Volunteering"> | string
    name?: StringNullableFilter<"Volunteering"> | string | null
    authority?: StringNullableFilter<"Volunteering"> | string | null
    issued_date?: DateTimeNullableFilter<"Volunteering"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"Volunteering"> | Date | string | null
    raw_json?: JsonNullableFilter<"Volunteering">
    created_at?: DateTimeFilter<"Volunteering"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type VolunteeringOrderByWithRelationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrderInput | SortOrder
    authority?: SortOrderInput | SortOrder
    issued_date?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    created_at?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type VolunteeringWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VolunteeringWhereInput | VolunteeringWhereInput[]
    OR?: VolunteeringWhereInput[]
    NOT?: VolunteeringWhereInput | VolunteeringWhereInput[]
    profile_id?: StringFilter<"Volunteering"> | string
    name?: StringNullableFilter<"Volunteering"> | string | null
    authority?: StringNullableFilter<"Volunteering"> | string | null
    issued_date?: DateTimeNullableFilter<"Volunteering"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"Volunteering"> | Date | string | null
    raw_json?: JsonNullableFilter<"Volunteering">
    created_at?: DateTimeFilter<"Volunteering"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id">

  export type VolunteeringOrderByWithAggregationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrderInput | SortOrder
    authority?: SortOrderInput | SortOrder
    issued_date?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: VolunteeringCountOrderByAggregateInput
    _max?: VolunteeringMaxOrderByAggregateInput
    _min?: VolunteeringMinOrderByAggregateInput
  }

  export type VolunteeringScalarWhereWithAggregatesInput = {
    AND?: VolunteeringScalarWhereWithAggregatesInput | VolunteeringScalarWhereWithAggregatesInput[]
    OR?: VolunteeringScalarWhereWithAggregatesInput[]
    NOT?: VolunteeringScalarWhereWithAggregatesInput | VolunteeringScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Volunteering"> | string
    profile_id?: StringWithAggregatesFilter<"Volunteering"> | string
    name?: StringNullableWithAggregatesFilter<"Volunteering"> | string | null
    authority?: StringNullableWithAggregatesFilter<"Volunteering"> | string | null
    issued_date?: DateTimeNullableWithAggregatesFilter<"Volunteering"> | Date | string | null
    expiry_date?: DateTimeNullableWithAggregatesFilter<"Volunteering"> | Date | string | null
    raw_json?: JsonNullableWithAggregatesFilter<"Volunteering">
    created_at?: DateTimeWithAggregatesFilter<"Volunteering"> | Date | string
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    id?: StringFilter<"Language"> | string
    profile_id?: StringFilter<"Language"> | string
    language?: StringNullableFilter<"Language"> | string | null
    proficiency?: StringNullableFilter<"Language"> | string | null
    raw_json?: JsonNullableFilter<"Language">
    created_at?: DateTimeFilter<"Language"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    language?: SortOrderInput | SortOrder
    proficiency?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    created_at?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    profile_id?: StringFilter<"Language"> | string
    language?: StringNullableFilter<"Language"> | string | null
    proficiency?: StringNullableFilter<"Language"> | string | null
    raw_json?: JsonNullableFilter<"Language">
    created_at?: DateTimeFilter<"Language"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id">

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    language?: SortOrderInput | SortOrder
    proficiency?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Language"> | string
    profile_id?: StringWithAggregatesFilter<"Language"> | string
    language?: StringNullableWithAggregatesFilter<"Language"> | string | null
    proficiency?: StringNullableWithAggregatesFilter<"Language"> | string | null
    raw_json?: JsonNullableWithAggregatesFilter<"Language">
    created_at?: DateTimeWithAggregatesFilter<"Language"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    profile_id?: StringFilter<"Organization"> | string
    name?: StringNullableFilter<"Organization"> | string | null
    authority?: StringNullableFilter<"Organization"> | string | null
    issued_date?: DateTimeNullableFilter<"Organization"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"Organization"> | Date | string | null
    raw_json?: JsonNullableFilter<"Organization">
    created_at?: DateTimeFilter<"Organization"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrderInput | SortOrder
    authority?: SortOrderInput | SortOrder
    issued_date?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    created_at?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    profile_id?: StringFilter<"Organization"> | string
    name?: StringNullableFilter<"Organization"> | string | null
    authority?: StringNullableFilter<"Organization"> | string | null
    issued_date?: DateTimeNullableFilter<"Organization"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"Organization"> | Date | string | null
    raw_json?: JsonNullableFilter<"Organization">
    created_at?: DateTimeFilter<"Organization"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrderInput | SortOrder
    authority?: SortOrderInput | SortOrder
    issued_date?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    raw_json?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    profile_id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    authority?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    issued_date?: DateTimeNullableWithAggregatesFilter<"Organization"> | Date | string | null
    expiry_date?: DateTimeNullableWithAggregatesFilter<"Organization"> | Date | string | null
    raw_json?: JsonNullableWithAggregatesFilter<"Organization">
    created_at?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type MediaLibraryWhereInput = {
    AND?: MediaLibraryWhereInput | MediaLibraryWhereInput[]
    OR?: MediaLibraryWhereInput[]
    NOT?: MediaLibraryWhereInput | MediaLibraryWhereInput[]
    id?: StringFilter<"MediaLibrary"> | string
    profile_id?: StringFilter<"MediaLibrary"> | string
    file_name?: StringFilter<"MediaLibrary"> | string
    file_type?: StringFilter<"MediaLibrary"> | string
    mime_type?: StringFilter<"MediaLibrary"> | string
    file_size?: BigIntFilter<"MediaLibrary"> | bigint | number
    storage_path?: StringFilter<"MediaLibrary"> | string
    storage_bucket?: StringFilter<"MediaLibrary"> | string
    title?: StringNullableFilter<"MediaLibrary"> | string | null
    description?: StringNullableFilter<"MediaLibrary"> | string | null
    tags?: StringNullableListFilter<"MediaLibrary">
    metadata?: JsonNullableFilter<"MediaLibrary">
    created_at?: DateTimeFilter<"MediaLibrary"> | Date | string
    updated_at?: DateTimeFilter<"MediaLibrary"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type MediaLibraryOrderByWithRelationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    storage_path?: SortOrder
    storage_bucket?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type MediaLibraryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaLibraryWhereInput | MediaLibraryWhereInput[]
    OR?: MediaLibraryWhereInput[]
    NOT?: MediaLibraryWhereInput | MediaLibraryWhereInput[]
    profile_id?: StringFilter<"MediaLibrary"> | string
    file_name?: StringFilter<"MediaLibrary"> | string
    file_type?: StringFilter<"MediaLibrary"> | string
    mime_type?: StringFilter<"MediaLibrary"> | string
    file_size?: BigIntFilter<"MediaLibrary"> | bigint | number
    storage_path?: StringFilter<"MediaLibrary"> | string
    storage_bucket?: StringFilter<"MediaLibrary"> | string
    title?: StringNullableFilter<"MediaLibrary"> | string | null
    description?: StringNullableFilter<"MediaLibrary"> | string | null
    tags?: StringNullableListFilter<"MediaLibrary">
    metadata?: JsonNullableFilter<"MediaLibrary">
    created_at?: DateTimeFilter<"MediaLibrary"> | Date | string
    updated_at?: DateTimeFilter<"MediaLibrary"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id">

  export type MediaLibraryOrderByWithAggregationInput = {
    id?: SortOrder
    profile_id?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    storage_path?: SortOrder
    storage_bucket?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: MediaLibraryCountOrderByAggregateInput
    _avg?: MediaLibraryAvgOrderByAggregateInput
    _max?: MediaLibraryMaxOrderByAggregateInput
    _min?: MediaLibraryMinOrderByAggregateInput
    _sum?: MediaLibrarySumOrderByAggregateInput
  }

  export type MediaLibraryScalarWhereWithAggregatesInput = {
    AND?: MediaLibraryScalarWhereWithAggregatesInput | MediaLibraryScalarWhereWithAggregatesInput[]
    OR?: MediaLibraryScalarWhereWithAggregatesInput[]
    NOT?: MediaLibraryScalarWhereWithAggregatesInput | MediaLibraryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MediaLibrary"> | string
    profile_id?: StringWithAggregatesFilter<"MediaLibrary"> | string
    file_name?: StringWithAggregatesFilter<"MediaLibrary"> | string
    file_type?: StringWithAggregatesFilter<"MediaLibrary"> | string
    mime_type?: StringWithAggregatesFilter<"MediaLibrary"> | string
    file_size?: BigIntWithAggregatesFilter<"MediaLibrary"> | bigint | number
    storage_path?: StringWithAggregatesFilter<"MediaLibrary"> | string
    storage_bucket?: StringWithAggregatesFilter<"MediaLibrary"> | string
    title?: StringNullableWithAggregatesFilter<"MediaLibrary"> | string | null
    description?: StringNullableWithAggregatesFilter<"MediaLibrary"> | string | null
    tags?: StringNullableListFilter<"MediaLibrary">
    metadata?: JsonNullableWithAggregatesFilter<"MediaLibrary">
    created_at?: DateTimeWithAggregatesFilter<"MediaLibrary"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MediaLibrary"> | Date | string
  }

  export type PersonalityAssessmentWhereInput = {
    AND?: PersonalityAssessmentWhereInput | PersonalityAssessmentWhereInput[]
    OR?: PersonalityAssessmentWhereInput[]
    NOT?: PersonalityAssessmentWhereInput | PersonalityAssessmentWhereInput[]
    id?: StringFilter<"PersonalityAssessment"> | string
    users_id?: StringFilter<"PersonalityAssessment"> | string
    assessment_date?: DateTimeFilter<"PersonalityAssessment"> | Date | string
    completed?: BoolFilter<"PersonalityAssessment"> | boolean
    time_taken_seconds?: IntNullableFilter<"PersonalityAssessment"> | number | null
    openness_score?: IntNullableFilter<"PersonalityAssessment"> | number | null
    conscientiousness_score?: IntNullableFilter<"PersonalityAssessment"> | number | null
    extraversion_score?: IntNullableFilter<"PersonalityAssessment"> | number | null
    agreeableness_score?: IntNullableFilter<"PersonalityAssessment"> | number | null
    emotional_stability_score?: IntNullableFilter<"PersonalityAssessment"> | number | null
    overall_score?: FloatNullableFilter<"PersonalityAssessment"> | number | null
    responses?: JsonNullableFilter<"PersonalityAssessment">
    created_at?: DateTimeFilter<"PersonalityAssessment"> | Date | string
    updated_at?: DateTimeFilter<"PersonalityAssessment"> | Date | string
    responses_rel?: PersonalityResponseListRelationFilter
  }

  export type PersonalityAssessmentOrderByWithRelationInput = {
    id?: SortOrder
    users_id?: SortOrder
    assessment_date?: SortOrder
    completed?: SortOrder
    time_taken_seconds?: SortOrderInput | SortOrder
    openness_score?: SortOrderInput | SortOrder
    conscientiousness_score?: SortOrderInput | SortOrder
    extraversion_score?: SortOrderInput | SortOrder
    agreeableness_score?: SortOrderInput | SortOrder
    emotional_stability_score?: SortOrderInput | SortOrder
    overall_score?: SortOrderInput | SortOrder
    responses?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    responses_rel?: PersonalityResponseOrderByRelationAggregateInput
  }

  export type PersonalityAssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonalityAssessmentWhereInput | PersonalityAssessmentWhereInput[]
    OR?: PersonalityAssessmentWhereInput[]
    NOT?: PersonalityAssessmentWhereInput | PersonalityAssessmentWhereInput[]
    users_id?: StringFilter<"PersonalityAssessment"> | string
    assessment_date?: DateTimeFilter<"PersonalityAssessment"> | Date | string
    completed?: BoolFilter<"PersonalityAssessment"> | boolean
    time_taken_seconds?: IntNullableFilter<"PersonalityAssessment"> | number | null
    openness_score?: IntNullableFilter<"PersonalityAssessment"> | number | null
    conscientiousness_score?: IntNullableFilter<"PersonalityAssessment"> | number | null
    extraversion_score?: IntNullableFilter<"PersonalityAssessment"> | number | null
    agreeableness_score?: IntNullableFilter<"PersonalityAssessment"> | number | null
    emotional_stability_score?: IntNullableFilter<"PersonalityAssessment"> | number | null
    overall_score?: FloatNullableFilter<"PersonalityAssessment"> | number | null
    responses?: JsonNullableFilter<"PersonalityAssessment">
    created_at?: DateTimeFilter<"PersonalityAssessment"> | Date | string
    updated_at?: DateTimeFilter<"PersonalityAssessment"> | Date | string
    responses_rel?: PersonalityResponseListRelationFilter
  }, "id">

  export type PersonalityAssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    users_id?: SortOrder
    assessment_date?: SortOrder
    completed?: SortOrder
    time_taken_seconds?: SortOrderInput | SortOrder
    openness_score?: SortOrderInput | SortOrder
    conscientiousness_score?: SortOrderInput | SortOrder
    extraversion_score?: SortOrderInput | SortOrder
    agreeableness_score?: SortOrderInput | SortOrder
    emotional_stability_score?: SortOrderInput | SortOrder
    overall_score?: SortOrderInput | SortOrder
    responses?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PersonalityAssessmentCountOrderByAggregateInput
    _avg?: PersonalityAssessmentAvgOrderByAggregateInput
    _max?: PersonalityAssessmentMaxOrderByAggregateInput
    _min?: PersonalityAssessmentMinOrderByAggregateInput
    _sum?: PersonalityAssessmentSumOrderByAggregateInput
  }

  export type PersonalityAssessmentScalarWhereWithAggregatesInput = {
    AND?: PersonalityAssessmentScalarWhereWithAggregatesInput | PersonalityAssessmentScalarWhereWithAggregatesInput[]
    OR?: PersonalityAssessmentScalarWhereWithAggregatesInput[]
    NOT?: PersonalityAssessmentScalarWhereWithAggregatesInput | PersonalityAssessmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PersonalityAssessment"> | string
    users_id?: StringWithAggregatesFilter<"PersonalityAssessment"> | string
    assessment_date?: DateTimeWithAggregatesFilter<"PersonalityAssessment"> | Date | string
    completed?: BoolWithAggregatesFilter<"PersonalityAssessment"> | boolean
    time_taken_seconds?: IntNullableWithAggregatesFilter<"PersonalityAssessment"> | number | null
    openness_score?: IntNullableWithAggregatesFilter<"PersonalityAssessment"> | number | null
    conscientiousness_score?: IntNullableWithAggregatesFilter<"PersonalityAssessment"> | number | null
    extraversion_score?: IntNullableWithAggregatesFilter<"PersonalityAssessment"> | number | null
    agreeableness_score?: IntNullableWithAggregatesFilter<"PersonalityAssessment"> | number | null
    emotional_stability_score?: IntNullableWithAggregatesFilter<"PersonalityAssessment"> | number | null
    overall_score?: FloatNullableWithAggregatesFilter<"PersonalityAssessment"> | number | null
    responses?: JsonNullableWithAggregatesFilter<"PersonalityAssessment">
    created_at?: DateTimeWithAggregatesFilter<"PersonalityAssessment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"PersonalityAssessment"> | Date | string
  }

  export type PersonalityResponseWhereInput = {
    AND?: PersonalityResponseWhereInput | PersonalityResponseWhereInput[]
    OR?: PersonalityResponseWhereInput[]
    NOT?: PersonalityResponseWhereInput | PersonalityResponseWhereInput[]
    id?: StringFilter<"PersonalityResponse"> | string
    assessment_id?: StringFilter<"PersonalityResponse"> | string
    question_id?: StringFilter<"PersonalityResponse"> | string
    question_text?: StringFilter<"PersonalityResponse"> | string
    dimension?: StringFilter<"PersonalityResponse"> | string
    response_value?: IntFilter<"PersonalityResponse"> | number
    created_at?: DateTimeFilter<"PersonalityResponse"> | Date | string
    assessment?: XOR<PersonalityAssessmentScalarRelationFilter, PersonalityAssessmentWhereInput>
  }

  export type PersonalityResponseOrderByWithRelationInput = {
    id?: SortOrder
    assessment_id?: SortOrder
    question_id?: SortOrder
    question_text?: SortOrder
    dimension?: SortOrder
    response_value?: SortOrder
    created_at?: SortOrder
    assessment?: PersonalityAssessmentOrderByWithRelationInput
  }

  export type PersonalityResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonalityResponseWhereInput | PersonalityResponseWhereInput[]
    OR?: PersonalityResponseWhereInput[]
    NOT?: PersonalityResponseWhereInput | PersonalityResponseWhereInput[]
    assessment_id?: StringFilter<"PersonalityResponse"> | string
    question_id?: StringFilter<"PersonalityResponse"> | string
    question_text?: StringFilter<"PersonalityResponse"> | string
    dimension?: StringFilter<"PersonalityResponse"> | string
    response_value?: IntFilter<"PersonalityResponse"> | number
    created_at?: DateTimeFilter<"PersonalityResponse"> | Date | string
    assessment?: XOR<PersonalityAssessmentScalarRelationFilter, PersonalityAssessmentWhereInput>
  }, "id">

  export type PersonalityResponseOrderByWithAggregationInput = {
    id?: SortOrder
    assessment_id?: SortOrder
    question_id?: SortOrder
    question_text?: SortOrder
    dimension?: SortOrder
    response_value?: SortOrder
    created_at?: SortOrder
    _count?: PersonalityResponseCountOrderByAggregateInput
    _avg?: PersonalityResponseAvgOrderByAggregateInput
    _max?: PersonalityResponseMaxOrderByAggregateInput
    _min?: PersonalityResponseMinOrderByAggregateInput
    _sum?: PersonalityResponseSumOrderByAggregateInput
  }

  export type PersonalityResponseScalarWhereWithAggregatesInput = {
    AND?: PersonalityResponseScalarWhereWithAggregatesInput | PersonalityResponseScalarWhereWithAggregatesInput[]
    OR?: PersonalityResponseScalarWhereWithAggregatesInput[]
    NOT?: PersonalityResponseScalarWhereWithAggregatesInput | PersonalityResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PersonalityResponse"> | string
    assessment_id?: StringWithAggregatesFilter<"PersonalityResponse"> | string
    question_id?: StringWithAggregatesFilter<"PersonalityResponse"> | string
    question_text?: StringWithAggregatesFilter<"PersonalityResponse"> | string
    dimension?: StringWithAggregatesFilter<"PersonalityResponse"> | string
    response_value?: IntWithAggregatesFilter<"PersonalityResponse"> | number
    created_at?: DateTimeWithAggregatesFilter<"PersonalityResponse"> | Date | string
  }

  export type AppAdminWhereInput = {
    AND?: AppAdminWhereInput | AppAdminWhereInput[]
    OR?: AppAdminWhereInput[]
    NOT?: AppAdminWhereInput | AppAdminWhereInput[]
    id?: StringFilter<"AppAdmin"> | string
    user_id?: StringFilter<"AppAdmin"> | string
    role?: StringFilter<"AppAdmin"> | string
    permissions?: StringNullableListFilter<"AppAdmin">
    is_active?: BoolFilter<"AppAdmin"> | boolean
    email?: StringFilter<"AppAdmin"> | string
    full_name?: StringNullableFilter<"AppAdmin"> | string | null
    department?: StringNullableFilter<"AppAdmin"> | string | null
    access_level?: IntFilter<"AppAdmin"> | number
    allowed_actions?: StringNullableListFilter<"AppAdmin">
    restricted_actions?: StringNullableListFilter<"AppAdmin">
    last_login_at?: DateTimeNullableFilter<"AppAdmin"> | Date | string | null
    last_activity_at?: DateTimeNullableFilter<"AppAdmin"> | Date | string | null
    login_count?: IntFilter<"AppAdmin"> | number
    failed_login_attempts?: IntFilter<"AppAdmin"> | number
    account_locked_until?: DateTimeNullableFilter<"AppAdmin"> | Date | string | null
    must_change_password?: BoolFilter<"AppAdmin"> | boolean
    two_factor_enabled?: BoolFilter<"AppAdmin"> | boolean
    created_by?: StringNullableFilter<"AppAdmin"> | string | null
    created_at?: DateTimeFilter<"AppAdmin"> | Date | string
    updated_by?: StringNullableFilter<"AppAdmin"> | string | null
    updated_at?: DateTimeFilter<"AppAdmin"> | Date | string
    deactivated_at?: DateTimeNullableFilter<"AppAdmin"> | Date | string | null
    deactivated_by?: StringNullableFilter<"AppAdmin"> | string | null
    deactivation_reason?: StringNullableFilter<"AppAdmin"> | string | null
    notes?: StringNullableFilter<"AppAdmin"> | string | null
    metadata?: JsonNullableFilter<"AppAdmin">
  }

  export type AppAdminOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    is_active?: SortOrder
    email?: SortOrder
    full_name?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    access_level?: SortOrder
    allowed_actions?: SortOrder
    restricted_actions?: SortOrder
    last_login_at?: SortOrderInput | SortOrder
    last_activity_at?: SortOrderInput | SortOrder
    login_count?: SortOrder
    failed_login_attempts?: SortOrder
    account_locked_until?: SortOrderInput | SortOrder
    must_change_password?: SortOrder
    two_factor_enabled?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    deactivated_at?: SortOrderInput | SortOrder
    deactivated_by?: SortOrderInput | SortOrder
    deactivation_reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type AppAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: string
    AND?: AppAdminWhereInput | AppAdminWhereInput[]
    OR?: AppAdminWhereInput[]
    NOT?: AppAdminWhereInput | AppAdminWhereInput[]
    role?: StringFilter<"AppAdmin"> | string
    permissions?: StringNullableListFilter<"AppAdmin">
    is_active?: BoolFilter<"AppAdmin"> | boolean
    email?: StringFilter<"AppAdmin"> | string
    full_name?: StringNullableFilter<"AppAdmin"> | string | null
    department?: StringNullableFilter<"AppAdmin"> | string | null
    access_level?: IntFilter<"AppAdmin"> | number
    allowed_actions?: StringNullableListFilter<"AppAdmin">
    restricted_actions?: StringNullableListFilter<"AppAdmin">
    last_login_at?: DateTimeNullableFilter<"AppAdmin"> | Date | string | null
    last_activity_at?: DateTimeNullableFilter<"AppAdmin"> | Date | string | null
    login_count?: IntFilter<"AppAdmin"> | number
    failed_login_attempts?: IntFilter<"AppAdmin"> | number
    account_locked_until?: DateTimeNullableFilter<"AppAdmin"> | Date | string | null
    must_change_password?: BoolFilter<"AppAdmin"> | boolean
    two_factor_enabled?: BoolFilter<"AppAdmin"> | boolean
    created_by?: StringNullableFilter<"AppAdmin"> | string | null
    created_at?: DateTimeFilter<"AppAdmin"> | Date | string
    updated_by?: StringNullableFilter<"AppAdmin"> | string | null
    updated_at?: DateTimeFilter<"AppAdmin"> | Date | string
    deactivated_at?: DateTimeNullableFilter<"AppAdmin"> | Date | string | null
    deactivated_by?: StringNullableFilter<"AppAdmin"> | string | null
    deactivation_reason?: StringNullableFilter<"AppAdmin"> | string | null
    notes?: StringNullableFilter<"AppAdmin"> | string | null
    metadata?: JsonNullableFilter<"AppAdmin">
  }, "id" | "unique_user_admin">

  export type AppAdminOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    is_active?: SortOrder
    email?: SortOrder
    full_name?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    access_level?: SortOrder
    allowed_actions?: SortOrder
    restricted_actions?: SortOrder
    last_login_at?: SortOrderInput | SortOrder
    last_activity_at?: SortOrderInput | SortOrder
    login_count?: SortOrder
    failed_login_attempts?: SortOrder
    account_locked_until?: SortOrderInput | SortOrder
    must_change_password?: SortOrder
    two_factor_enabled?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    deactivated_at?: SortOrderInput | SortOrder
    deactivated_by?: SortOrderInput | SortOrder
    deactivation_reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: AppAdminCountOrderByAggregateInput
    _avg?: AppAdminAvgOrderByAggregateInput
    _max?: AppAdminMaxOrderByAggregateInput
    _min?: AppAdminMinOrderByAggregateInput
    _sum?: AppAdminSumOrderByAggregateInput
  }

  export type AppAdminScalarWhereWithAggregatesInput = {
    AND?: AppAdminScalarWhereWithAggregatesInput | AppAdminScalarWhereWithAggregatesInput[]
    OR?: AppAdminScalarWhereWithAggregatesInput[]
    NOT?: AppAdminScalarWhereWithAggregatesInput | AppAdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AppAdmin"> | string
    user_id?: StringWithAggregatesFilter<"AppAdmin"> | string
    role?: StringWithAggregatesFilter<"AppAdmin"> | string
    permissions?: StringNullableListFilter<"AppAdmin">
    is_active?: BoolWithAggregatesFilter<"AppAdmin"> | boolean
    email?: StringWithAggregatesFilter<"AppAdmin"> | string
    full_name?: StringNullableWithAggregatesFilter<"AppAdmin"> | string | null
    department?: StringNullableWithAggregatesFilter<"AppAdmin"> | string | null
    access_level?: IntWithAggregatesFilter<"AppAdmin"> | number
    allowed_actions?: StringNullableListFilter<"AppAdmin">
    restricted_actions?: StringNullableListFilter<"AppAdmin">
    last_login_at?: DateTimeNullableWithAggregatesFilter<"AppAdmin"> | Date | string | null
    last_activity_at?: DateTimeNullableWithAggregatesFilter<"AppAdmin"> | Date | string | null
    login_count?: IntWithAggregatesFilter<"AppAdmin"> | number
    failed_login_attempts?: IntWithAggregatesFilter<"AppAdmin"> | number
    account_locked_until?: DateTimeNullableWithAggregatesFilter<"AppAdmin"> | Date | string | null
    must_change_password?: BoolWithAggregatesFilter<"AppAdmin"> | boolean
    two_factor_enabled?: BoolWithAggregatesFilter<"AppAdmin"> | boolean
    created_by?: StringNullableWithAggregatesFilter<"AppAdmin"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"AppAdmin"> | Date | string
    updated_by?: StringNullableWithAggregatesFilter<"AppAdmin"> | string | null
    updated_at?: DateTimeWithAggregatesFilter<"AppAdmin"> | Date | string
    deactivated_at?: DateTimeNullableWithAggregatesFilter<"AppAdmin"> | Date | string | null
    deactivated_by?: StringNullableWithAggregatesFilter<"AppAdmin"> | string | null
    deactivation_reason?: StringNullableWithAggregatesFilter<"AppAdmin"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AppAdmin"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AppAdmin">
  }

  export type TalentStoryWhereInput = {
    AND?: TalentStoryWhereInput | TalentStoryWhereInput[]
    OR?: TalentStoryWhereInput[]
    NOT?: TalentStoryWhereInput | TalentStoryWhereInput[]
    id?: StringFilter<"TalentStory"> | string
    user_id?: StringFilter<"TalentStory"> | string
    story?: StringFilter<"TalentStory"> | string
    data?: JsonFilter<"TalentStory">
    model?: StringNullableFilter<"TalentStory"> | string | null
    created_at?: DateTimeFilter<"TalentStory"> | Date | string
    updated_at?: DateTimeFilter<"TalentStory"> | Date | string
    version?: IntNullableFilter<"TalentStory"> | number | null
    is_active?: BoolFilter<"TalentStory"> | boolean
  }

  export type TalentStoryOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    story?: SortOrder
    data?: SortOrder
    model?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    version?: SortOrderInput | SortOrder
    is_active?: SortOrder
  }

  export type TalentStoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TalentStoryWhereInput | TalentStoryWhereInput[]
    OR?: TalentStoryWhereInput[]
    NOT?: TalentStoryWhereInput | TalentStoryWhereInput[]
    user_id?: StringFilter<"TalentStory"> | string
    story?: StringFilter<"TalentStory"> | string
    data?: JsonFilter<"TalentStory">
    model?: StringNullableFilter<"TalentStory"> | string | null
    created_at?: DateTimeFilter<"TalentStory"> | Date | string
    updated_at?: DateTimeFilter<"TalentStory"> | Date | string
    version?: IntNullableFilter<"TalentStory"> | number | null
    is_active?: BoolFilter<"TalentStory"> | boolean
  }, "id">

  export type TalentStoryOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    story?: SortOrder
    data?: SortOrder
    model?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    version?: SortOrderInput | SortOrder
    is_active?: SortOrder
    _count?: TalentStoryCountOrderByAggregateInput
    _avg?: TalentStoryAvgOrderByAggregateInput
    _max?: TalentStoryMaxOrderByAggregateInput
    _min?: TalentStoryMinOrderByAggregateInput
    _sum?: TalentStorySumOrderByAggregateInput
  }

  export type TalentStoryScalarWhereWithAggregatesInput = {
    AND?: TalentStoryScalarWhereWithAggregatesInput | TalentStoryScalarWhereWithAggregatesInput[]
    OR?: TalentStoryScalarWhereWithAggregatesInput[]
    NOT?: TalentStoryScalarWhereWithAggregatesInput | TalentStoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TalentStory"> | string
    user_id?: StringWithAggregatesFilter<"TalentStory"> | string
    story?: StringWithAggregatesFilter<"TalentStory"> | string
    data?: JsonWithAggregatesFilter<"TalentStory">
    model?: StringNullableWithAggregatesFilter<"TalentStory"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"TalentStory"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"TalentStory"> | Date | string
    version?: IntNullableWithAggregatesFilter<"TalentStory"> | number | null
    is_active?: BoolWithAggregatesFilter<"TalentStory"> | boolean
  }

  export type JobPostWhereInput = {
    AND?: JobPostWhereInput | JobPostWhereInput[]
    OR?: JobPostWhereInput[]
    NOT?: JobPostWhereInput | JobPostWhereInput[]
    id?: StringFilter<"JobPost"> | string
    user_id?: StringFilter<"JobPost"> | string
    title?: StringFilter<"JobPost"> | string
    company?: StringNullableFilter<"JobPost"> | string | null
    location?: StringNullableFilter<"JobPost"> | string | null
    raw_description?: StringFilter<"JobPost"> | string
    job_url?: StringNullableFilter<"JobPost"> | string | null
    parsed_data?: JsonFilter<"JobPost">
    created_at?: DateTimeFilter<"JobPost"> | Date | string
    updated_at?: DateTimeFilter<"JobPost"> | Date | string
    status?: StringNullableFilter<"JobPost"> | string | null
    applied_at?: DateTimeNullableFilter<"JobPost"> | Date | string | null
    customized_stories?: CustomizedStoryListRelationFilter
  }

  export type JobPostOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    company?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    raw_description?: SortOrder
    job_url?: SortOrderInput | SortOrder
    parsed_data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrderInput | SortOrder
    applied_at?: SortOrderInput | SortOrder
    customized_stories?: CustomizedStoryOrderByRelationAggregateInput
  }

  export type JobPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobPostWhereInput | JobPostWhereInput[]
    OR?: JobPostWhereInput[]
    NOT?: JobPostWhereInput | JobPostWhereInput[]
    user_id?: StringFilter<"JobPost"> | string
    title?: StringFilter<"JobPost"> | string
    company?: StringNullableFilter<"JobPost"> | string | null
    location?: StringNullableFilter<"JobPost"> | string | null
    raw_description?: StringFilter<"JobPost"> | string
    job_url?: StringNullableFilter<"JobPost"> | string | null
    parsed_data?: JsonFilter<"JobPost">
    created_at?: DateTimeFilter<"JobPost"> | Date | string
    updated_at?: DateTimeFilter<"JobPost"> | Date | string
    status?: StringNullableFilter<"JobPost"> | string | null
    applied_at?: DateTimeNullableFilter<"JobPost"> | Date | string | null
    customized_stories?: CustomizedStoryListRelationFilter
  }, "id">

  export type JobPostOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    company?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    raw_description?: SortOrder
    job_url?: SortOrderInput | SortOrder
    parsed_data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrderInput | SortOrder
    applied_at?: SortOrderInput | SortOrder
    _count?: JobPostCountOrderByAggregateInput
    _max?: JobPostMaxOrderByAggregateInput
    _min?: JobPostMinOrderByAggregateInput
  }

  export type JobPostScalarWhereWithAggregatesInput = {
    AND?: JobPostScalarWhereWithAggregatesInput | JobPostScalarWhereWithAggregatesInput[]
    OR?: JobPostScalarWhereWithAggregatesInput[]
    NOT?: JobPostScalarWhereWithAggregatesInput | JobPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobPost"> | string
    user_id?: StringWithAggregatesFilter<"JobPost"> | string
    title?: StringWithAggregatesFilter<"JobPost"> | string
    company?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    location?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    raw_description?: StringWithAggregatesFilter<"JobPost"> | string
    job_url?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    parsed_data?: JsonWithAggregatesFilter<"JobPost">
    created_at?: DateTimeWithAggregatesFilter<"JobPost"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"JobPost"> | Date | string
    status?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    applied_at?: DateTimeNullableWithAggregatesFilter<"JobPost"> | Date | string | null
  }

  export type CustomizedStoryWhereInput = {
    AND?: CustomizedStoryWhereInput | CustomizedStoryWhereInput[]
    OR?: CustomizedStoryWhereInput[]
    NOT?: CustomizedStoryWhereInput | CustomizedStoryWhereInput[]
    id?: StringFilter<"CustomizedStory"> | string
    user_id?: StringFilter<"CustomizedStory"> | string
    profile_id?: StringNullableFilter<"CustomizedStory"> | string | null
    job_post_id?: StringNullableFilter<"CustomizedStory"> | string | null
    story?: StringFilter<"CustomizedStory"> | string
    reordered_experience?: JsonNullableFilter<"CustomizedStory">
    highlighted_skills?: StringNullableListFilter<"CustomizedStory">
    match_score?: IntFilter<"CustomizedStory"> | number
    score_breakdown?: JsonFilter<"CustomizedStory">
    created_at?: DateTimeFilter<"CustomizedStory"> | Date | string
    updated_at?: DateTimeFilter<"CustomizedStory"> | Date | string
    is_active?: BoolFilter<"CustomizedStory"> | boolean
    version_name?: StringNullableFilter<"CustomizedStory"> | string | null
    job_post?: XOR<JobPostNullableScalarRelationFilter, JobPostWhereInput> | null
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }

  export type CustomizedStoryOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    profile_id?: SortOrderInput | SortOrder
    job_post_id?: SortOrderInput | SortOrder
    story?: SortOrder
    reordered_experience?: SortOrderInput | SortOrder
    highlighted_skills?: SortOrder
    match_score?: SortOrder
    score_breakdown?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_active?: SortOrder
    version_name?: SortOrderInput | SortOrder
    job_post?: JobPostOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type CustomizedStoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomizedStoryWhereInput | CustomizedStoryWhereInput[]
    OR?: CustomizedStoryWhereInput[]
    NOT?: CustomizedStoryWhereInput | CustomizedStoryWhereInput[]
    user_id?: StringFilter<"CustomizedStory"> | string
    profile_id?: StringNullableFilter<"CustomizedStory"> | string | null
    job_post_id?: StringNullableFilter<"CustomizedStory"> | string | null
    story?: StringFilter<"CustomizedStory"> | string
    reordered_experience?: JsonNullableFilter<"CustomizedStory">
    highlighted_skills?: StringNullableListFilter<"CustomizedStory">
    match_score?: IntFilter<"CustomizedStory"> | number
    score_breakdown?: JsonFilter<"CustomizedStory">
    created_at?: DateTimeFilter<"CustomizedStory"> | Date | string
    updated_at?: DateTimeFilter<"CustomizedStory"> | Date | string
    is_active?: BoolFilter<"CustomizedStory"> | boolean
    version_name?: StringNullableFilter<"CustomizedStory"> | string | null
    job_post?: XOR<JobPostNullableScalarRelationFilter, JobPostWhereInput> | null
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }, "id">

  export type CustomizedStoryOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    profile_id?: SortOrderInput | SortOrder
    job_post_id?: SortOrderInput | SortOrder
    story?: SortOrder
    reordered_experience?: SortOrderInput | SortOrder
    highlighted_skills?: SortOrder
    match_score?: SortOrder
    score_breakdown?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_active?: SortOrder
    version_name?: SortOrderInput | SortOrder
    _count?: CustomizedStoryCountOrderByAggregateInput
    _avg?: CustomizedStoryAvgOrderByAggregateInput
    _max?: CustomizedStoryMaxOrderByAggregateInput
    _min?: CustomizedStoryMinOrderByAggregateInput
    _sum?: CustomizedStorySumOrderByAggregateInput
  }

  export type CustomizedStoryScalarWhereWithAggregatesInput = {
    AND?: CustomizedStoryScalarWhereWithAggregatesInput | CustomizedStoryScalarWhereWithAggregatesInput[]
    OR?: CustomizedStoryScalarWhereWithAggregatesInput[]
    NOT?: CustomizedStoryScalarWhereWithAggregatesInput | CustomizedStoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomizedStory"> | string
    user_id?: StringWithAggregatesFilter<"CustomizedStory"> | string
    profile_id?: StringNullableWithAggregatesFilter<"CustomizedStory"> | string | null
    job_post_id?: StringNullableWithAggregatesFilter<"CustomizedStory"> | string | null
    story?: StringWithAggregatesFilter<"CustomizedStory"> | string
    reordered_experience?: JsonNullableWithAggregatesFilter<"CustomizedStory">
    highlighted_skills?: StringNullableListFilter<"CustomizedStory">
    match_score?: IntWithAggregatesFilter<"CustomizedStory"> | number
    score_breakdown?: JsonWithAggregatesFilter<"CustomizedStory">
    created_at?: DateTimeWithAggregatesFilter<"CustomizedStory"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CustomizedStory"> | Date | string
    is_active?: BoolWithAggregatesFilter<"CustomizedStory"> | boolean
    version_name?: StringNullableWithAggregatesFilter<"CustomizedStory"> | string | null
  }

  export type StoryWhereInput = {
    AND?: StoryWhereInput | StoryWhereInput[]
    OR?: StoryWhereInput[]
    NOT?: StoryWhereInput | StoryWhereInput[]
    id?: StringFilter<"Story"> | string
    experience_id?: StringFilter<"Story"> | string
    created_at?: DateTimeFilter<"Story"> | Date | string
    updated_at?: DateTimeFilter<"Story"> | Date | string
    situation?: StringNullableFilter<"Story"> | string | null
    task?: StringNullableFilter<"Story"> | string | null
    action?: StringNullableFilter<"Story"> | string | null
    result?: StringNullableFilter<"Story"> | string | null
    full_story?: StringNullableFilter<"Story"> | string | null
    ai_generated?: BoolFilter<"Story"> | boolean
    metrics?: JsonNullableFilter<"Story">
    title?: StringNullableFilter<"Story"> | string | null
    tags?: StringNullableListFilter<"Story">
    is_draft?: BoolFilter<"Story"> | boolean
    relevance_score?: FloatNullableFilter<"Story"> | number | null
    job_match_scores?: JsonNullableFilter<"Story">
    experience?: XOR<ExperienceScalarRelationFilter, ExperienceWhereInput>
    versions?: StoryVersionListRelationFilter
    skills?: StorySkillListRelationFilter
  }

  export type StoryOrderByWithRelationInput = {
    id?: SortOrder
    experience_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    situation?: SortOrderInput | SortOrder
    task?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    full_story?: SortOrderInput | SortOrder
    ai_generated?: SortOrder
    metrics?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    tags?: SortOrder
    is_draft?: SortOrder
    relevance_score?: SortOrderInput | SortOrder
    job_match_scores?: SortOrderInput | SortOrder
    experience?: ExperienceOrderByWithRelationInput
    versions?: StoryVersionOrderByRelationAggregateInput
    skills?: StorySkillOrderByRelationAggregateInput
  }

  export type StoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoryWhereInput | StoryWhereInput[]
    OR?: StoryWhereInput[]
    NOT?: StoryWhereInput | StoryWhereInput[]
    experience_id?: StringFilter<"Story"> | string
    created_at?: DateTimeFilter<"Story"> | Date | string
    updated_at?: DateTimeFilter<"Story"> | Date | string
    situation?: StringNullableFilter<"Story"> | string | null
    task?: StringNullableFilter<"Story"> | string | null
    action?: StringNullableFilter<"Story"> | string | null
    result?: StringNullableFilter<"Story"> | string | null
    full_story?: StringNullableFilter<"Story"> | string | null
    ai_generated?: BoolFilter<"Story"> | boolean
    metrics?: JsonNullableFilter<"Story">
    title?: StringNullableFilter<"Story"> | string | null
    tags?: StringNullableListFilter<"Story">
    is_draft?: BoolFilter<"Story"> | boolean
    relevance_score?: FloatNullableFilter<"Story"> | number | null
    job_match_scores?: JsonNullableFilter<"Story">
    experience?: XOR<ExperienceScalarRelationFilter, ExperienceWhereInput>
    versions?: StoryVersionListRelationFilter
    skills?: StorySkillListRelationFilter
  }, "id">

  export type StoryOrderByWithAggregationInput = {
    id?: SortOrder
    experience_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    situation?: SortOrderInput | SortOrder
    task?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    full_story?: SortOrderInput | SortOrder
    ai_generated?: SortOrder
    metrics?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    tags?: SortOrder
    is_draft?: SortOrder
    relevance_score?: SortOrderInput | SortOrder
    job_match_scores?: SortOrderInput | SortOrder
    _count?: StoryCountOrderByAggregateInput
    _avg?: StoryAvgOrderByAggregateInput
    _max?: StoryMaxOrderByAggregateInput
    _min?: StoryMinOrderByAggregateInput
    _sum?: StorySumOrderByAggregateInput
  }

  export type StoryScalarWhereWithAggregatesInput = {
    AND?: StoryScalarWhereWithAggregatesInput | StoryScalarWhereWithAggregatesInput[]
    OR?: StoryScalarWhereWithAggregatesInput[]
    NOT?: StoryScalarWhereWithAggregatesInput | StoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Story"> | string
    experience_id?: StringWithAggregatesFilter<"Story"> | string
    created_at?: DateTimeWithAggregatesFilter<"Story"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Story"> | Date | string
    situation?: StringNullableWithAggregatesFilter<"Story"> | string | null
    task?: StringNullableWithAggregatesFilter<"Story"> | string | null
    action?: StringNullableWithAggregatesFilter<"Story"> | string | null
    result?: StringNullableWithAggregatesFilter<"Story"> | string | null
    full_story?: StringNullableWithAggregatesFilter<"Story"> | string | null
    ai_generated?: BoolWithAggregatesFilter<"Story"> | boolean
    metrics?: JsonNullableWithAggregatesFilter<"Story">
    title?: StringNullableWithAggregatesFilter<"Story"> | string | null
    tags?: StringNullableListFilter<"Story">
    is_draft?: BoolWithAggregatesFilter<"Story"> | boolean
    relevance_score?: FloatNullableWithAggregatesFilter<"Story"> | number | null
    job_match_scores?: JsonNullableWithAggregatesFilter<"Story">
  }

  export type StoryVersionWhereInput = {
    AND?: StoryVersionWhereInput | StoryVersionWhereInput[]
    OR?: StoryVersionWhereInput[]
    NOT?: StoryVersionWhereInput | StoryVersionWhereInput[]
    id?: StringFilter<"StoryVersion"> | string
    story_id?: StringFilter<"StoryVersion"> | string
    created_at?: DateTimeFilter<"StoryVersion"> | Date | string
    version_number?: IntFilter<"StoryVersion"> | number
    situation?: StringNullableFilter<"StoryVersion"> | string | null
    task?: StringNullableFilter<"StoryVersion"> | string | null
    action?: StringNullableFilter<"StoryVersion"> | string | null
    result?: StringNullableFilter<"StoryVersion"> | string | null
    full_story?: StringNullableFilter<"StoryVersion"> | string | null
    metrics?: JsonNullableFilter<"StoryVersion">
    change_summary?: StringNullableFilter<"StoryVersion"> | string | null
    created_by_ai?: BoolFilter<"StoryVersion"> | boolean
    story?: XOR<StoryScalarRelationFilter, StoryWhereInput>
  }

  export type StoryVersionOrderByWithRelationInput = {
    id?: SortOrder
    story_id?: SortOrder
    created_at?: SortOrder
    version_number?: SortOrder
    situation?: SortOrderInput | SortOrder
    task?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    full_story?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    change_summary?: SortOrderInput | SortOrder
    created_by_ai?: SortOrder
    story?: StoryOrderByWithRelationInput
  }

  export type StoryVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    story_id_version_number?: StoryVersionStory_idVersion_numberCompoundUniqueInput
    AND?: StoryVersionWhereInput | StoryVersionWhereInput[]
    OR?: StoryVersionWhereInput[]
    NOT?: StoryVersionWhereInput | StoryVersionWhereInput[]
    story_id?: StringFilter<"StoryVersion"> | string
    created_at?: DateTimeFilter<"StoryVersion"> | Date | string
    version_number?: IntFilter<"StoryVersion"> | number
    situation?: StringNullableFilter<"StoryVersion"> | string | null
    task?: StringNullableFilter<"StoryVersion"> | string | null
    action?: StringNullableFilter<"StoryVersion"> | string | null
    result?: StringNullableFilter<"StoryVersion"> | string | null
    full_story?: StringNullableFilter<"StoryVersion"> | string | null
    metrics?: JsonNullableFilter<"StoryVersion">
    change_summary?: StringNullableFilter<"StoryVersion"> | string | null
    created_by_ai?: BoolFilter<"StoryVersion"> | boolean
    story?: XOR<StoryScalarRelationFilter, StoryWhereInput>
  }, "id" | "story_id_version_number">

  export type StoryVersionOrderByWithAggregationInput = {
    id?: SortOrder
    story_id?: SortOrder
    created_at?: SortOrder
    version_number?: SortOrder
    situation?: SortOrderInput | SortOrder
    task?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    full_story?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    change_summary?: SortOrderInput | SortOrder
    created_by_ai?: SortOrder
    _count?: StoryVersionCountOrderByAggregateInput
    _avg?: StoryVersionAvgOrderByAggregateInput
    _max?: StoryVersionMaxOrderByAggregateInput
    _min?: StoryVersionMinOrderByAggregateInput
    _sum?: StoryVersionSumOrderByAggregateInput
  }

  export type StoryVersionScalarWhereWithAggregatesInput = {
    AND?: StoryVersionScalarWhereWithAggregatesInput | StoryVersionScalarWhereWithAggregatesInput[]
    OR?: StoryVersionScalarWhereWithAggregatesInput[]
    NOT?: StoryVersionScalarWhereWithAggregatesInput | StoryVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoryVersion"> | string
    story_id?: StringWithAggregatesFilter<"StoryVersion"> | string
    created_at?: DateTimeWithAggregatesFilter<"StoryVersion"> | Date | string
    version_number?: IntWithAggregatesFilter<"StoryVersion"> | number
    situation?: StringNullableWithAggregatesFilter<"StoryVersion"> | string | null
    task?: StringNullableWithAggregatesFilter<"StoryVersion"> | string | null
    action?: StringNullableWithAggregatesFilter<"StoryVersion"> | string | null
    result?: StringNullableWithAggregatesFilter<"StoryVersion"> | string | null
    full_story?: StringNullableWithAggregatesFilter<"StoryVersion"> | string | null
    metrics?: JsonNullableWithAggregatesFilter<"StoryVersion">
    change_summary?: StringNullableWithAggregatesFilter<"StoryVersion"> | string | null
    created_by_ai?: BoolWithAggregatesFilter<"StoryVersion"> | boolean
  }

  export type StorySkillWhereInput = {
    AND?: StorySkillWhereInput | StorySkillWhereInput[]
    OR?: StorySkillWhereInput[]
    NOT?: StorySkillWhereInput | StorySkillWhereInput[]
    id?: StringFilter<"StorySkill"> | string
    story_id?: StringFilter<"StorySkill"> | string
    skill_id?: StringFilter<"StorySkill"> | string
    created_at?: DateTimeFilter<"StorySkill"> | Date | string
    story?: XOR<StoryScalarRelationFilter, StoryWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }

  export type StorySkillOrderByWithRelationInput = {
    id?: SortOrder
    story_id?: SortOrder
    skill_id?: SortOrder
    created_at?: SortOrder
    story?: StoryOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type StorySkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    story_id_skill_id?: StorySkillStory_idSkill_idCompoundUniqueInput
    AND?: StorySkillWhereInput | StorySkillWhereInput[]
    OR?: StorySkillWhereInput[]
    NOT?: StorySkillWhereInput | StorySkillWhereInput[]
    story_id?: StringFilter<"StorySkill"> | string
    skill_id?: StringFilter<"StorySkill"> | string
    created_at?: DateTimeFilter<"StorySkill"> | Date | string
    story?: XOR<StoryScalarRelationFilter, StoryWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }, "id" | "story_id_skill_id">

  export type StorySkillOrderByWithAggregationInput = {
    id?: SortOrder
    story_id?: SortOrder
    skill_id?: SortOrder
    created_at?: SortOrder
    _count?: StorySkillCountOrderByAggregateInput
    _max?: StorySkillMaxOrderByAggregateInput
    _min?: StorySkillMinOrderByAggregateInput
  }

  export type StorySkillScalarWhereWithAggregatesInput = {
    AND?: StorySkillScalarWhereWithAggregatesInput | StorySkillScalarWhereWithAggregatesInput[]
    OR?: StorySkillScalarWhereWithAggregatesInput[]
    NOT?: StorySkillScalarWhereWithAggregatesInput | StorySkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StorySkill"> | string
    story_id?: StringWithAggregatesFilter<"StorySkill"> | string
    skill_id?: StringWithAggregatesFilter<"StorySkill"> | string
    created_at?: DateTimeWithAggregatesFilter<"StorySkill"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    username?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    username?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    username?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportHistoryCreateInput = {
    id?: string
    userId: string
    format: string
    filename: string
    fileUrl: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ExportHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    format: string
    filename: string
    fileUrl: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ExportHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportHistoryCreateManyInput = {
    id?: string
    userId: string
    format: string
    filename: string
    fileUrl: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ExportHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceCreateNestedManyWithoutProfileInput
    education?: EducationCreateNestedManyWithoutProfileInput
    skills?: SkillCreateNestedManyWithoutProfileInput
    certifications?: CertificationCreateNestedManyWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringCreateNestedManyWithoutProfileInput
    languages?: LanguageCreateNestedManyWithoutProfileInput
    organizations?: OrganizationCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceUncheckedCreateNestedManyWithoutProfileInput
    education?: EducationUncheckedCreateNestedManyWithoutProfileInput
    skills?: SkillUncheckedCreateNestedManyWithoutProfileInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutProfileInput
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringUncheckedCreateNestedManyWithoutProfileInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProfileInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentUncheckedCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryUncheckedCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUpdateManyWithoutProfileNestedInput
    education?: EducationUpdateManyWithoutProfileNestedInput
    skills?: SkillUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUpdateManyWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUpdateManyWithoutProfileNestedInput
    languages?: LanguageUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUncheckedUpdateManyWithoutProfileNestedInput
    education?: EducationUncheckedUpdateManyWithoutProfileNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutProfileNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUncheckedUpdateManyWithoutProfileNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUncheckedUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUncheckedUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedDocumentCreateInput = {
    id?: string
    user_id?: string | null
    file_name?: string | null
    storage_path?: string | null
    content_type?: string | null
    size_bytes?: number | null
    text_extracted?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: string | null
    status?: string | null
    error_text?: string | null
    parsed_at?: Date | string | null
    created_at?: Date | string
    parsing_jobs?: ParsingJobCreateNestedManyWithoutParsed_documentInput
    profile?: ProfileCreateNestedOneWithoutParsed_documentsInput
  }

  export type ParsedDocumentUncheckedCreateInput = {
    id?: string
    profile_id?: string | null
    user_id?: string | null
    file_name?: string | null
    storage_path?: string | null
    content_type?: string | null
    size_bytes?: number | null
    text_extracted?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: string | null
    status?: string | null
    error_text?: string | null
    parsed_at?: Date | string | null
    created_at?: Date | string
    parsing_jobs?: ParsingJobUncheckedCreateNestedManyWithoutParsed_documentInput
  }

  export type ParsedDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    storage_path?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    text_extracted?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsing_jobs?: ParsingJobUpdateManyWithoutParsed_documentNestedInput
    profile?: ProfileUpdateOneWithoutParsed_documentsNestedInput
  }

  export type ParsedDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    storage_path?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    text_extracted?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsing_jobs?: ParsingJobUncheckedUpdateManyWithoutParsed_documentNestedInput
  }

  export type ParsedDocumentCreateManyInput = {
    id?: string
    profile_id?: string | null
    user_id?: string | null
    file_name?: string | null
    storage_path?: string | null
    content_type?: string | null
    size_bytes?: number | null
    text_extracted?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: string | null
    status?: string | null
    error_text?: string | null
    parsed_at?: Date | string | null
    created_at?: Date | string
  }

  export type ParsedDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    storage_path?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    text_extracted?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    storage_path?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    text_extracted?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceCreateInput = {
    id?: string
    title?: string | null
    company?: string | null
    location?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_current?: boolean
    description?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: number | null
    created_at?: Date | string
    profile: ProfileCreateNestedOneWithoutExperiencesInput
    stories?: StoryCreateNestedManyWithoutExperienceInput
  }

  export type ExperienceUncheckedCreateInput = {
    id?: string
    profile_id: string
    title?: string | null
    company?: string | null
    location?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_current?: boolean
    description?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: number | null
    created_at?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutExperienceInput
  }

  export type ExperienceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutExperiencesNestedInput
    stories?: StoryUpdateManyWithoutExperienceNestedInput
  }

  export type ExperienceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutExperienceNestedInput
  }

  export type ExperienceCreateManyInput = {
    id?: string
    profile_id: string
    title?: string | null
    company?: string | null
    location?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_current?: boolean
    description?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: number | null
    created_at?: Date | string
  }

  export type ExperienceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationCreateInput = {
    id?: string
    school?: string | null
    degree?: string | null
    field_of_study?: string | null
    start_year?: number | null
    end_year?: number | null
    description?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    profile: ProfileCreateNestedOneWithoutEducationInput
  }

  export type EducationUncheckedCreateInput = {
    id?: string
    profile_id: string
    school?: string | null
    degree?: string | null
    field_of_study?: string | null
    start_year?: number | null
    end_year?: number | null
    description?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type EducationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    school?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    start_year?: NullableIntFieldUpdateOperationsInput | number | null
    end_year?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutEducationNestedInput
  }

  export type EducationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    school?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    start_year?: NullableIntFieldUpdateOperationsInput | number | null
    end_year?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationCreateManyInput = {
    id?: string
    profile_id: string
    school?: string | null
    degree?: string | null
    field_of_study?: string | null
    start_year?: number | null
    end_year?: number | null
    description?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type EducationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    school?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    start_year?: NullableIntFieldUpdateOperationsInput | number | null
    end_year?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    school?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    start_year?: NullableIntFieldUpdateOperationsInput | number | null
    end_year?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillCreateInput = {
    id?: string
    skill?: string | null
    confidence?: number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    profile: ProfileCreateNestedOneWithoutSkillsInput
    storySkills?: StorySkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: string
    profile_id: string
    skill?: string | null
    confidence?: number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    storySkills?: StorySkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutSkillsNestedInput
    storySkills?: StorySkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    storySkills?: StorySkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    id?: string
    profile_id: string
    skill?: string | null
    confidence?: number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type SkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationCreateInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    profile: ProfileCreateNestedOneWithoutCertificationsInput
  }

  export type CertificationUncheckedCreateInput = {
    id?: string
    profile_id: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type CertificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type CertificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationCreateManyInput = {
    id?: string
    profile_id: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type CertificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsingJobCreateInput = {
    id?: string
    status?: string | null
    attempts?: number | null
    worker?: string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
    parsed_document: ParsedDocumentCreateNestedOneWithoutParsing_jobsInput
  }

  export type ParsingJobUncheckedCreateInput = {
    id?: string
    parsed_document_id: string
    status?: string | null
    attempts?: number | null
    worker?: string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
  }

  export type ParsingJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    worker?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_document?: ParsedDocumentUpdateOneRequiredWithoutParsing_jobsNestedInput
  }

  export type ParsingJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parsed_document_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    worker?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsingJobCreateManyInput = {
    id?: string
    parsed_document_id: string
    status?: string | null
    attempts?: number | null
    worker?: string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
  }

  export type ParsingJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    worker?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsingJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parsed_document_id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    worker?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    profile: ProfileCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    profile_id: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyInput = {
    id?: string
    profile_id: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VolunteeringCreateInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    profile: ProfileCreateNestedOneWithoutVolunteeringInput
  }

  export type VolunteeringUncheckedCreateInput = {
    id?: string
    profile_id: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type VolunteeringUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutVolunteeringNestedInput
  }

  export type VolunteeringUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VolunteeringCreateManyInput = {
    id?: string
    profile_id: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type VolunteeringUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VolunteeringUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageCreateInput = {
    id?: string
    language?: string | null
    proficiency?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    profile: ProfileCreateNestedOneWithoutLanguagesInput
  }

  export type LanguageUncheckedCreateInput = {
    id?: string
    profile_id: string
    language?: string | null
    proficiency?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type LanguageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    proficiency?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutLanguagesNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    proficiency?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageCreateManyInput = {
    id?: string
    profile_id: string
    language?: string | null
    proficiency?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type LanguageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    proficiency?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    proficiency?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    profile: ProfileCreateNestedOneWithoutOrganizationsInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    profile_id: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutOrganizationsNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateManyInput = {
    id?: string
    profile_id: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaLibraryCreateInput = {
    id?: string
    file_name: string
    file_type: string
    mime_type: string
    file_size: bigint | number
    storage_path: string
    storage_bucket?: string
    title?: string | null
    description?: string | null
    tags?: MediaLibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    profile: ProfileCreateNestedOneWithoutMediaLibraryInput
  }

  export type MediaLibraryUncheckedCreateInput = {
    id?: string
    profile_id: string
    file_name: string
    file_type: string
    mime_type: string
    file_size: bigint | number
    storage_path: string
    storage_bucket?: string
    title?: string | null
    description?: string | null
    tags?: MediaLibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MediaLibraryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    storage_path?: StringFieldUpdateOperationsInput | string
    storage_bucket?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MediaLibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutMediaLibraryNestedInput
  }

  export type MediaLibraryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    storage_path?: StringFieldUpdateOperationsInput | string
    storage_bucket?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MediaLibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaLibraryCreateManyInput = {
    id?: string
    profile_id: string
    file_name: string
    file_type: string
    mime_type: string
    file_size: bigint | number
    storage_path: string
    storage_bucket?: string
    title?: string | null
    description?: string | null
    tags?: MediaLibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MediaLibraryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    storage_path?: StringFieldUpdateOperationsInput | string
    storage_bucket?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MediaLibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaLibraryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    storage_path?: StringFieldUpdateOperationsInput | string
    storage_bucket?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MediaLibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalityAssessmentCreateInput = {
    id?: string
    users_id: string
    assessment_date?: Date | string
    completed?: boolean
    time_taken_seconds?: number | null
    openness_score?: number | null
    conscientiousness_score?: number | null
    extraversion_score?: number | null
    agreeableness_score?: number | null
    emotional_stability_score?: number | null
    overall_score?: number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    responses_rel?: PersonalityResponseCreateNestedManyWithoutAssessmentInput
  }

  export type PersonalityAssessmentUncheckedCreateInput = {
    id?: string
    users_id: string
    assessment_date?: Date | string
    completed?: boolean
    time_taken_seconds?: number | null
    openness_score?: number | null
    conscientiousness_score?: number | null
    extraversion_score?: number | null
    agreeableness_score?: number | null
    emotional_stability_score?: number | null
    overall_score?: number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    responses_rel?: PersonalityResponseUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type PersonalityAssessmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    users_id?: StringFieldUpdateOperationsInput | string
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    time_taken_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    openness_score?: NullableIntFieldUpdateOperationsInput | number | null
    conscientiousness_score?: NullableIntFieldUpdateOperationsInput | number | null
    extraversion_score?: NullableIntFieldUpdateOperationsInput | number | null
    agreeableness_score?: NullableIntFieldUpdateOperationsInput | number | null
    emotional_stability_score?: NullableIntFieldUpdateOperationsInput | number | null
    overall_score?: NullableFloatFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responses_rel?: PersonalityResponseUpdateManyWithoutAssessmentNestedInput
  }

  export type PersonalityAssessmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    users_id?: StringFieldUpdateOperationsInput | string
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    time_taken_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    openness_score?: NullableIntFieldUpdateOperationsInput | number | null
    conscientiousness_score?: NullableIntFieldUpdateOperationsInput | number | null
    extraversion_score?: NullableIntFieldUpdateOperationsInput | number | null
    agreeableness_score?: NullableIntFieldUpdateOperationsInput | number | null
    emotional_stability_score?: NullableIntFieldUpdateOperationsInput | number | null
    overall_score?: NullableFloatFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responses_rel?: PersonalityResponseUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type PersonalityAssessmentCreateManyInput = {
    id?: string
    users_id: string
    assessment_date?: Date | string
    completed?: boolean
    time_taken_seconds?: number | null
    openness_score?: number | null
    conscientiousness_score?: number | null
    extraversion_score?: number | null
    agreeableness_score?: number | null
    emotional_stability_score?: number | null
    overall_score?: number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PersonalityAssessmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    users_id?: StringFieldUpdateOperationsInput | string
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    time_taken_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    openness_score?: NullableIntFieldUpdateOperationsInput | number | null
    conscientiousness_score?: NullableIntFieldUpdateOperationsInput | number | null
    extraversion_score?: NullableIntFieldUpdateOperationsInput | number | null
    agreeableness_score?: NullableIntFieldUpdateOperationsInput | number | null
    emotional_stability_score?: NullableIntFieldUpdateOperationsInput | number | null
    overall_score?: NullableFloatFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalityAssessmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    users_id?: StringFieldUpdateOperationsInput | string
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    time_taken_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    openness_score?: NullableIntFieldUpdateOperationsInput | number | null
    conscientiousness_score?: NullableIntFieldUpdateOperationsInput | number | null
    extraversion_score?: NullableIntFieldUpdateOperationsInput | number | null
    agreeableness_score?: NullableIntFieldUpdateOperationsInput | number | null
    emotional_stability_score?: NullableIntFieldUpdateOperationsInput | number | null
    overall_score?: NullableFloatFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalityResponseCreateInput = {
    id?: string
    question_id: string
    question_text: string
    dimension: string
    response_value: number
    created_at?: Date | string
    assessment: PersonalityAssessmentCreateNestedOneWithoutResponses_relInput
  }

  export type PersonalityResponseUncheckedCreateInput = {
    id?: string
    assessment_id: string
    question_id: string
    question_text: string
    dimension: string
    response_value: number
    created_at?: Date | string
  }

  export type PersonalityResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    dimension?: StringFieldUpdateOperationsInput | string
    response_value?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assessment?: PersonalityAssessmentUpdateOneRequiredWithoutResponses_relNestedInput
  }

  export type PersonalityResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessment_id?: StringFieldUpdateOperationsInput | string
    question_id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    dimension?: StringFieldUpdateOperationsInput | string
    response_value?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalityResponseCreateManyInput = {
    id?: string
    assessment_id: string
    question_id: string
    question_text: string
    dimension: string
    response_value: number
    created_at?: Date | string
  }

  export type PersonalityResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    dimension?: StringFieldUpdateOperationsInput | string
    response_value?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalityResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessment_id?: StringFieldUpdateOperationsInput | string
    question_id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    dimension?: StringFieldUpdateOperationsInput | string
    response_value?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppAdminCreateInput = {
    id?: string
    user_id: string
    role?: string
    permissions?: AppAdminCreatepermissionsInput | string[]
    is_active?: boolean
    email: string
    full_name?: string | null
    department?: string | null
    access_level?: number
    allowed_actions?: AppAdminCreateallowed_actionsInput | string[]
    restricted_actions?: AppAdminCreaterestricted_actionsInput | string[]
    last_login_at?: Date | string | null
    last_activity_at?: Date | string | null
    login_count?: number
    failed_login_attempts?: number
    account_locked_until?: Date | string | null
    must_change_password?: boolean
    two_factor_enabled?: boolean
    created_by?: string | null
    created_at?: Date | string
    updated_by?: string | null
    updated_at?: Date | string
    deactivated_at?: Date | string | null
    deactivated_by?: string | null
    deactivation_reason?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AppAdminUncheckedCreateInput = {
    id?: string
    user_id: string
    role?: string
    permissions?: AppAdminCreatepermissionsInput | string[]
    is_active?: boolean
    email: string
    full_name?: string | null
    department?: string | null
    access_level?: number
    allowed_actions?: AppAdminCreateallowed_actionsInput | string[]
    restricted_actions?: AppAdminCreaterestricted_actionsInput | string[]
    last_login_at?: Date | string | null
    last_activity_at?: Date | string | null
    login_count?: number
    failed_login_attempts?: number
    account_locked_until?: Date | string | null
    must_change_password?: boolean
    two_factor_enabled?: boolean
    created_by?: string | null
    created_at?: Date | string
    updated_by?: string | null
    updated_at?: Date | string
    deactivated_at?: Date | string | null
    deactivated_by?: string | null
    deactivation_reason?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AppAdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AppAdminUpdatepermissionsInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    access_level?: IntFieldUpdateOperationsInput | number
    allowed_actions?: AppAdminUpdateallowed_actionsInput | string[]
    restricted_actions?: AppAdminUpdaterestricted_actionsInput | string[]
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_activity_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_count?: IntFieldUpdateOperationsInput | number
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    account_locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deactivated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deactivation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AppAdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AppAdminUpdatepermissionsInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    access_level?: IntFieldUpdateOperationsInput | number
    allowed_actions?: AppAdminUpdateallowed_actionsInput | string[]
    restricted_actions?: AppAdminUpdaterestricted_actionsInput | string[]
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_activity_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_count?: IntFieldUpdateOperationsInput | number
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    account_locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deactivated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deactivation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AppAdminCreateManyInput = {
    id?: string
    user_id: string
    role?: string
    permissions?: AppAdminCreatepermissionsInput | string[]
    is_active?: boolean
    email: string
    full_name?: string | null
    department?: string | null
    access_level?: number
    allowed_actions?: AppAdminCreateallowed_actionsInput | string[]
    restricted_actions?: AppAdminCreaterestricted_actionsInput | string[]
    last_login_at?: Date | string | null
    last_activity_at?: Date | string | null
    login_count?: number
    failed_login_attempts?: number
    account_locked_until?: Date | string | null
    must_change_password?: boolean
    two_factor_enabled?: boolean
    created_by?: string | null
    created_at?: Date | string
    updated_by?: string | null
    updated_at?: Date | string
    deactivated_at?: Date | string | null
    deactivated_by?: string | null
    deactivation_reason?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AppAdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AppAdminUpdatepermissionsInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    access_level?: IntFieldUpdateOperationsInput | number
    allowed_actions?: AppAdminUpdateallowed_actionsInput | string[]
    restricted_actions?: AppAdminUpdaterestricted_actionsInput | string[]
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_activity_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_count?: IntFieldUpdateOperationsInput | number
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    account_locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deactivated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deactivation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AppAdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AppAdminUpdatepermissionsInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    access_level?: IntFieldUpdateOperationsInput | number
    allowed_actions?: AppAdminUpdateallowed_actionsInput | string[]
    restricted_actions?: AppAdminUpdaterestricted_actionsInput | string[]
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_activity_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_count?: IntFieldUpdateOperationsInput | number
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    account_locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    must_change_password?: BoolFieldUpdateOperationsInput | boolean
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deactivated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deactivation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TalentStoryCreateInput = {
    id?: string
    user_id: string
    story: string
    data: JsonNullValueInput | InputJsonValue
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    version?: number | null
    is_active?: boolean
  }

  export type TalentStoryUncheckedCreateInput = {
    id?: string
    user_id: string
    story: string
    data: JsonNullValueInput | InputJsonValue
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    version?: number | null
    is_active?: boolean
  }

  export type TalentStoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TalentStoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TalentStoryCreateManyInput = {
    id?: string
    user_id: string
    story: string
    data: JsonNullValueInput | InputJsonValue
    model?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    version?: number | null
    is_active?: boolean
  }

  export type TalentStoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TalentStoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobPostCreateInput = {
    id?: string
    user_id: string
    title: string
    company?: string | null
    location?: string | null
    raw_description: string
    job_url?: string | null
    parsed_data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string | null
    applied_at?: Date | string | null
    customized_stories?: CustomizedStoryCreateNestedManyWithoutJob_postInput
  }

  export type JobPostUncheckedCreateInput = {
    id?: string
    user_id: string
    title: string
    company?: string | null
    location?: string | null
    raw_description: string
    job_url?: string | null
    parsed_data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string | null
    applied_at?: Date | string | null
    customized_stories?: CustomizedStoryUncheckedCreateNestedManyWithoutJob_postInput
  }

  export type JobPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    raw_description?: StringFieldUpdateOperationsInput | string
    job_url?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customized_stories?: CustomizedStoryUpdateManyWithoutJob_postNestedInput
  }

  export type JobPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    raw_description?: StringFieldUpdateOperationsInput | string
    job_url?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customized_stories?: CustomizedStoryUncheckedUpdateManyWithoutJob_postNestedInput
  }

  export type JobPostCreateManyInput = {
    id?: string
    user_id: string
    title: string
    company?: string | null
    location?: string | null
    raw_description: string
    job_url?: string | null
    parsed_data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string | null
    applied_at?: Date | string | null
  }

  export type JobPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    raw_description?: StringFieldUpdateOperationsInput | string
    job_url?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    raw_description?: StringFieldUpdateOperationsInput | string
    job_url?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomizedStoryCreateInput = {
    id?: string
    user_id: string
    story: string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryCreatehighlighted_skillsInput | string[]
    match_score: number
    score_breakdown: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    is_active?: boolean
    version_name?: string | null
    job_post?: JobPostCreateNestedOneWithoutCustomized_storiesInput
    profile?: ProfileCreateNestedOneWithoutCustomizedStoriesInput
  }

  export type CustomizedStoryUncheckedCreateInput = {
    id?: string
    user_id: string
    profile_id?: string | null
    job_post_id?: string | null
    story: string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryCreatehighlighted_skillsInput | string[]
    match_score: number
    score_breakdown: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    is_active?: boolean
    version_name?: string | null
  }

  export type CustomizedStoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryUpdatehighlighted_skillsInput | string[]
    match_score?: IntFieldUpdateOperationsInput | number
    score_breakdown?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_post?: JobPostUpdateOneWithoutCustomized_storiesNestedInput
    profile?: ProfileUpdateOneWithoutCustomizedStoriesNestedInput
  }

  export type CustomizedStoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    profile_id?: NullableStringFieldUpdateOperationsInput | string | null
    job_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    story?: StringFieldUpdateOperationsInput | string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryUpdatehighlighted_skillsInput | string[]
    match_score?: IntFieldUpdateOperationsInput | number
    score_breakdown?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomizedStoryCreateManyInput = {
    id?: string
    user_id: string
    profile_id?: string | null
    job_post_id?: string | null
    story: string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryCreatehighlighted_skillsInput | string[]
    match_score: number
    score_breakdown: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    is_active?: boolean
    version_name?: string | null
  }

  export type CustomizedStoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryUpdatehighlighted_skillsInput | string[]
    match_score?: IntFieldUpdateOperationsInput | number
    score_breakdown?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomizedStoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    profile_id?: NullableStringFieldUpdateOperationsInput | string | null
    job_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    story?: StringFieldUpdateOperationsInput | string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryUpdatehighlighted_skillsInput | string[]
    match_score?: IntFieldUpdateOperationsInput | number
    score_breakdown?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoryCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    ai_generated?: boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: string | null
    tags?: StoryCreatetagsInput | string[]
    is_draft?: boolean
    relevance_score?: number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    experience: ExperienceCreateNestedOneWithoutStoriesInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    skills?: StorySkillCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateInput = {
    id?: string
    experience_id: string
    created_at?: Date | string
    updated_at?: Date | string
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    ai_generated?: boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: string | null
    tags?: StoryCreatetagsInput | string[]
    is_draft?: boolean
    relevance_score?: number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    skills?: StorySkillUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: BoolFieldUpdateOperationsInput | boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    is_draft?: BoolFieldUpdateOperationsInput | boolean
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    experience?: ExperienceUpdateOneRequiredWithoutStoriesNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    skills?: StorySkillUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    experience_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: BoolFieldUpdateOperationsInput | boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    is_draft?: BoolFieldUpdateOperationsInput | boolean
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    skills?: StorySkillUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryCreateManyInput = {
    id?: string
    experience_id: string
    created_at?: Date | string
    updated_at?: Date | string
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    ai_generated?: boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: string | null
    tags?: StoryCreatetagsInput | string[]
    is_draft?: boolean
    relevance_score?: number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: BoolFieldUpdateOperationsInput | boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    is_draft?: BoolFieldUpdateOperationsInput | boolean
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    experience_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: BoolFieldUpdateOperationsInput | boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    is_draft?: BoolFieldUpdateOperationsInput | boolean
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoryVersionCreateInput = {
    id?: string
    created_at?: Date | string
    version_number: number
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    change_summary?: string | null
    created_by_ai?: boolean
    story: StoryCreateNestedOneWithoutVersionsInput
  }

  export type StoryVersionUncheckedCreateInput = {
    id?: string
    story_id: string
    created_at?: Date | string
    version_number: number
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    change_summary?: string | null
    created_by_ai?: boolean
  }

  export type StoryVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    version_number?: IntFieldUpdateOperationsInput | number
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    change_summary?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_ai?: BoolFieldUpdateOperationsInput | boolean
    story?: StoryUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type StoryVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    story_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    version_number?: IntFieldUpdateOperationsInput | number
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    change_summary?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_ai?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StoryVersionCreateManyInput = {
    id?: string
    story_id: string
    created_at?: Date | string
    version_number: number
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    change_summary?: string | null
    created_by_ai?: boolean
  }

  export type StoryVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    version_number?: IntFieldUpdateOperationsInput | number
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    change_summary?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_ai?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StoryVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    story_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    version_number?: IntFieldUpdateOperationsInput | number
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    change_summary?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_ai?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StorySkillCreateInput = {
    id?: string
    created_at?: Date | string
    story: StoryCreateNestedOneWithoutSkillsInput
    skill: SkillCreateNestedOneWithoutStorySkillsInput
  }

  export type StorySkillUncheckedCreateInput = {
    id?: string
    story_id: string
    skill_id: string
    created_at?: Date | string
  }

  export type StorySkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: StoryUpdateOneRequiredWithoutSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutStorySkillsNestedInput
  }

  export type StorySkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    story_id?: StringFieldUpdateOperationsInput | string
    skill_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorySkillCreateManyInput = {
    id?: string
    story_id: string
    skill_id: string
    created_at?: Date | string
  }

  export type StorySkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorySkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    story_id?: StringFieldUpdateOperationsInput | string
    skill_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ExportHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    filename?: SortOrder
    fileUrl?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
  }

  export type ExportHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    filename?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ExportHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    format?: SortOrder
    filename?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ExperienceListRelationFilter = {
    every?: ExperienceWhereInput
    some?: ExperienceWhereInput
    none?: ExperienceWhereInput
  }

  export type EducationListRelationFilter = {
    every?: EducationWhereInput
    some?: EducationWhereInput
    none?: EducationWhereInput
  }

  export type SkillListRelationFilter = {
    every?: SkillWhereInput
    some?: SkillWhereInput
    none?: SkillWhereInput
  }

  export type CertificationListRelationFilter = {
    every?: CertificationWhereInput
    some?: CertificationWhereInput
    none?: CertificationWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type VolunteeringListRelationFilter = {
    every?: VolunteeringWhereInput
    some?: VolunteeringWhereInput
    none?: VolunteeringWhereInput
  }

  export type LanguageListRelationFilter = {
    every?: LanguageWhereInput
    some?: LanguageWhereInput
    none?: LanguageWhereInput
  }

  export type OrganizationListRelationFilter = {
    every?: OrganizationWhereInput
    some?: OrganizationWhereInput
    none?: OrganizationWhereInput
  }

  export type ParsedDocumentListRelationFilter = {
    every?: ParsedDocumentWhereInput
    some?: ParsedDocumentWhereInput
    none?: ParsedDocumentWhereInput
  }

  export type MediaLibraryListRelationFilter = {
    every?: MediaLibraryWhereInput
    some?: MediaLibraryWhereInput
    none?: MediaLibraryWhereInput
  }

  export type CustomizedStoryListRelationFilter = {
    every?: CustomizedStoryWhereInput
    some?: CustomizedStoryWhereInput
    none?: CustomizedStoryWhereInput
  }

  export type ExperienceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EducationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VolunteeringOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParsedDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaLibraryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomizedStoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    full_name?: SortOrder
    preferred_name?: SortOrder
    headline?: SortOrder
    summary?: SortOrder
    location?: SortOrder
    website?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    about?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    full_name?: SortOrder
    preferred_name?: SortOrder
    headline?: SortOrder
    summary?: SortOrder
    location?: SortOrder
    website?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    about?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    full_name?: SortOrder
    preferred_name?: SortOrder
    headline?: SortOrder
    summary?: SortOrder
    location?: SortOrder
    website?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    about?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ParsingJobListRelationFilter = {
    every?: ParsingJobWhereInput
    some?: ParsingJobWhereInput
    none?: ParsingJobWhereInput
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type ParsingJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParsedDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    user_id?: SortOrder
    file_name?: SortOrder
    storage_path?: SortOrder
    content_type?: SortOrder
    size_bytes?: SortOrder
    text_extracted?: SortOrder
    parsed_json?: SortOrder
    parser_version?: SortOrder
    status?: SortOrder
    error_text?: SortOrder
    parsed_at?: SortOrder
    created_at?: SortOrder
  }

  export type ParsedDocumentAvgOrderByAggregateInput = {
    size_bytes?: SortOrder
  }

  export type ParsedDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    user_id?: SortOrder
    file_name?: SortOrder
    storage_path?: SortOrder
    content_type?: SortOrder
    size_bytes?: SortOrder
    text_extracted?: SortOrder
    parser_version?: SortOrder
    status?: SortOrder
    error_text?: SortOrder
    parsed_at?: SortOrder
    created_at?: SortOrder
  }

  export type ParsedDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    user_id?: SortOrder
    file_name?: SortOrder
    storage_path?: SortOrder
    content_type?: SortOrder
    size_bytes?: SortOrder
    text_extracted?: SortOrder
    parser_version?: SortOrder
    status?: SortOrder
    error_text?: SortOrder
    parsed_at?: SortOrder
    created_at?: SortOrder
  }

  export type ParsedDocumentSumOrderByAggregateInput = {
    size_bytes?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProfileScalarRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type StoryListRelationFilter = {
    every?: StoryWhereInput
    some?: StoryWhereInput
    none?: StoryWhereInput
  }

  export type StoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExperienceCountOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_current?: SortOrder
    description?: SortOrder
    raw_json?: SortOrder
    order_index?: SortOrder
    created_at?: SortOrder
  }

  export type ExperienceAvgOrderByAggregateInput = {
    order_index?: SortOrder
  }

  export type ExperienceMaxOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_current?: SortOrder
    description?: SortOrder
    order_index?: SortOrder
    created_at?: SortOrder
  }

  export type ExperienceMinOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_current?: SortOrder
    description?: SortOrder
    order_index?: SortOrder
    created_at?: SortOrder
  }

  export type ExperienceSumOrderByAggregateInput = {
    order_index?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EducationCountOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    school?: SortOrder
    degree?: SortOrder
    field_of_study?: SortOrder
    start_year?: SortOrder
    end_year?: SortOrder
    description?: SortOrder
    raw_json?: SortOrder
    created_at?: SortOrder
  }

  export type EducationAvgOrderByAggregateInput = {
    start_year?: SortOrder
    end_year?: SortOrder
  }

  export type EducationMaxOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    school?: SortOrder
    degree?: SortOrder
    field_of_study?: SortOrder
    start_year?: SortOrder
    end_year?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type EducationMinOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    school?: SortOrder
    degree?: SortOrder
    field_of_study?: SortOrder
    start_year?: SortOrder
    end_year?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type EducationSumOrderByAggregateInput = {
    start_year?: SortOrder
    end_year?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StorySkillListRelationFilter = {
    every?: StorySkillWhereInput
    some?: StorySkillWhereInput
    none?: StorySkillWhereInput
  }

  export type StorySkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    skill?: SortOrder
    confidence?: SortOrder
    raw_json?: SortOrder
    created_at?: SortOrder
  }

  export type SkillAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    skill?: SortOrder
    confidence?: SortOrder
    created_at?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    skill?: SortOrder
    confidence?: SortOrder
    created_at?: SortOrder
  }

  export type SkillSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CertificationCountOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrder
    authority?: SortOrder
    issued_date?: SortOrder
    expiry_date?: SortOrder
    raw_json?: SortOrder
    created_at?: SortOrder
  }

  export type CertificationMaxOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrder
    authority?: SortOrder
    issued_date?: SortOrder
    expiry_date?: SortOrder
    created_at?: SortOrder
  }

  export type CertificationMinOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrder
    authority?: SortOrder
    issued_date?: SortOrder
    expiry_date?: SortOrder
    created_at?: SortOrder
  }

  export type ParsedDocumentScalarRelationFilter = {
    is?: ParsedDocumentWhereInput
    isNot?: ParsedDocumentWhereInput
  }

  export type ParsingJobCountOrderByAggregateInput = {
    id?: SortOrder
    parsed_document_id?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    worker?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    created_at?: SortOrder
  }

  export type ParsingJobAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type ParsingJobMaxOrderByAggregateInput = {
    id?: SortOrder
    parsed_document_id?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    worker?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    created_at?: SortOrder
  }

  export type ParsingJobMinOrderByAggregateInput = {
    id?: SortOrder
    parsed_document_id?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    worker?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    created_at?: SortOrder
  }

  export type ParsingJobSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrder
    authority?: SortOrder
    issued_date?: SortOrder
    expiry_date?: SortOrder
    raw_json?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrder
    authority?: SortOrder
    issued_date?: SortOrder
    expiry_date?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrder
    authority?: SortOrder
    issued_date?: SortOrder
    expiry_date?: SortOrder
    created_at?: SortOrder
  }

  export type VolunteeringCountOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrder
    authority?: SortOrder
    issued_date?: SortOrder
    expiry_date?: SortOrder
    raw_json?: SortOrder
    created_at?: SortOrder
  }

  export type VolunteeringMaxOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrder
    authority?: SortOrder
    issued_date?: SortOrder
    expiry_date?: SortOrder
    created_at?: SortOrder
  }

  export type VolunteeringMinOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrder
    authority?: SortOrder
    issued_date?: SortOrder
    expiry_date?: SortOrder
    created_at?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    language?: SortOrder
    proficiency?: SortOrder
    raw_json?: SortOrder
    created_at?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    language?: SortOrder
    proficiency?: SortOrder
    created_at?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    language?: SortOrder
    proficiency?: SortOrder
    created_at?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrder
    authority?: SortOrder
    issued_date?: SortOrder
    expiry_date?: SortOrder
    raw_json?: SortOrder
    created_at?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrder
    authority?: SortOrder
    issued_date?: SortOrder
    expiry_date?: SortOrder
    created_at?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    name?: SortOrder
    authority?: SortOrder
    issued_date?: SortOrder
    expiry_date?: SortOrder
    created_at?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type MediaLibraryCountOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    storage_path?: SortOrder
    storage_bucket?: SortOrder
    title?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MediaLibraryAvgOrderByAggregateInput = {
    file_size?: SortOrder
  }

  export type MediaLibraryMaxOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    storage_path?: SortOrder
    storage_bucket?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MediaLibraryMinOrderByAggregateInput = {
    id?: SortOrder
    profile_id?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    mime_type?: SortOrder
    file_size?: SortOrder
    storage_path?: SortOrder
    storage_bucket?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MediaLibrarySumOrderByAggregateInput = {
    file_size?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type PersonalityResponseListRelationFilter = {
    every?: PersonalityResponseWhereInput
    some?: PersonalityResponseWhereInput
    none?: PersonalityResponseWhereInput
  }

  export type PersonalityResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonalityAssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    assessment_date?: SortOrder
    completed?: SortOrder
    time_taken_seconds?: SortOrder
    openness_score?: SortOrder
    conscientiousness_score?: SortOrder
    extraversion_score?: SortOrder
    agreeableness_score?: SortOrder
    emotional_stability_score?: SortOrder
    overall_score?: SortOrder
    responses?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PersonalityAssessmentAvgOrderByAggregateInput = {
    time_taken_seconds?: SortOrder
    openness_score?: SortOrder
    conscientiousness_score?: SortOrder
    extraversion_score?: SortOrder
    agreeableness_score?: SortOrder
    emotional_stability_score?: SortOrder
    overall_score?: SortOrder
  }

  export type PersonalityAssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    assessment_date?: SortOrder
    completed?: SortOrder
    time_taken_seconds?: SortOrder
    openness_score?: SortOrder
    conscientiousness_score?: SortOrder
    extraversion_score?: SortOrder
    agreeableness_score?: SortOrder
    emotional_stability_score?: SortOrder
    overall_score?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PersonalityAssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    users_id?: SortOrder
    assessment_date?: SortOrder
    completed?: SortOrder
    time_taken_seconds?: SortOrder
    openness_score?: SortOrder
    conscientiousness_score?: SortOrder
    extraversion_score?: SortOrder
    agreeableness_score?: SortOrder
    emotional_stability_score?: SortOrder
    overall_score?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PersonalityAssessmentSumOrderByAggregateInput = {
    time_taken_seconds?: SortOrder
    openness_score?: SortOrder
    conscientiousness_score?: SortOrder
    extraversion_score?: SortOrder
    agreeableness_score?: SortOrder
    emotional_stability_score?: SortOrder
    overall_score?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PersonalityAssessmentScalarRelationFilter = {
    is?: PersonalityAssessmentWhereInput
    isNot?: PersonalityAssessmentWhereInput
  }

  export type PersonalityResponseCountOrderByAggregateInput = {
    id?: SortOrder
    assessment_id?: SortOrder
    question_id?: SortOrder
    question_text?: SortOrder
    dimension?: SortOrder
    response_value?: SortOrder
    created_at?: SortOrder
  }

  export type PersonalityResponseAvgOrderByAggregateInput = {
    response_value?: SortOrder
  }

  export type PersonalityResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    assessment_id?: SortOrder
    question_id?: SortOrder
    question_text?: SortOrder
    dimension?: SortOrder
    response_value?: SortOrder
    created_at?: SortOrder
  }

  export type PersonalityResponseMinOrderByAggregateInput = {
    id?: SortOrder
    assessment_id?: SortOrder
    question_id?: SortOrder
    question_text?: SortOrder
    dimension?: SortOrder
    response_value?: SortOrder
    created_at?: SortOrder
  }

  export type PersonalityResponseSumOrderByAggregateInput = {
    response_value?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AppAdminCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    is_active?: SortOrder
    email?: SortOrder
    full_name?: SortOrder
    department?: SortOrder
    access_level?: SortOrder
    allowed_actions?: SortOrder
    restricted_actions?: SortOrder
    last_login_at?: SortOrder
    last_activity_at?: SortOrder
    login_count?: SortOrder
    failed_login_attempts?: SortOrder
    account_locked_until?: SortOrder
    must_change_password?: SortOrder
    two_factor_enabled?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
    deactivated_at?: SortOrder
    deactivated_by?: SortOrder
    deactivation_reason?: SortOrder
    notes?: SortOrder
    metadata?: SortOrder
  }

  export type AppAdminAvgOrderByAggregateInput = {
    access_level?: SortOrder
    login_count?: SortOrder
    failed_login_attempts?: SortOrder
  }

  export type AppAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    email?: SortOrder
    full_name?: SortOrder
    department?: SortOrder
    access_level?: SortOrder
    last_login_at?: SortOrder
    last_activity_at?: SortOrder
    login_count?: SortOrder
    failed_login_attempts?: SortOrder
    account_locked_until?: SortOrder
    must_change_password?: SortOrder
    two_factor_enabled?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
    deactivated_at?: SortOrder
    deactivated_by?: SortOrder
    deactivation_reason?: SortOrder
    notes?: SortOrder
  }

  export type AppAdminMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    email?: SortOrder
    full_name?: SortOrder
    department?: SortOrder
    access_level?: SortOrder
    last_login_at?: SortOrder
    last_activity_at?: SortOrder
    login_count?: SortOrder
    failed_login_attempts?: SortOrder
    account_locked_until?: SortOrder
    must_change_password?: SortOrder
    two_factor_enabled?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_by?: SortOrder
    updated_at?: SortOrder
    deactivated_at?: SortOrder
    deactivated_by?: SortOrder
    deactivation_reason?: SortOrder
    notes?: SortOrder
  }

  export type AppAdminSumOrderByAggregateInput = {
    access_level?: SortOrder
    login_count?: SortOrder
    failed_login_attempts?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TalentStoryCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    story?: SortOrder
    data?: SortOrder
    model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    version?: SortOrder
    is_active?: SortOrder
  }

  export type TalentStoryAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type TalentStoryMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    story?: SortOrder
    model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    version?: SortOrder
    is_active?: SortOrder
  }

  export type TalentStoryMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    story?: SortOrder
    model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    version?: SortOrder
    is_active?: SortOrder
  }

  export type TalentStorySumOrderByAggregateInput = {
    version?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type JobPostCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrder
    raw_description?: SortOrder
    job_url?: SortOrder
    parsed_data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    applied_at?: SortOrder
  }

  export type JobPostMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrder
    raw_description?: SortOrder
    job_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    applied_at?: SortOrder
  }

  export type JobPostMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    company?: SortOrder
    location?: SortOrder
    raw_description?: SortOrder
    job_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    applied_at?: SortOrder
  }

  export type JobPostNullableScalarRelationFilter = {
    is?: JobPostWhereInput | null
    isNot?: JobPostWhereInput | null
  }

  export type CustomizedStoryCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    profile_id?: SortOrder
    job_post_id?: SortOrder
    story?: SortOrder
    reordered_experience?: SortOrder
    highlighted_skills?: SortOrder
    match_score?: SortOrder
    score_breakdown?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_active?: SortOrder
    version_name?: SortOrder
  }

  export type CustomizedStoryAvgOrderByAggregateInput = {
    match_score?: SortOrder
  }

  export type CustomizedStoryMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    profile_id?: SortOrder
    job_post_id?: SortOrder
    story?: SortOrder
    match_score?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_active?: SortOrder
    version_name?: SortOrder
  }

  export type CustomizedStoryMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    profile_id?: SortOrder
    job_post_id?: SortOrder
    story?: SortOrder
    match_score?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_active?: SortOrder
    version_name?: SortOrder
  }

  export type CustomizedStorySumOrderByAggregateInput = {
    match_score?: SortOrder
  }

  export type ExperienceScalarRelationFilter = {
    is?: ExperienceWhereInput
    isNot?: ExperienceWhereInput
  }

  export type StoryVersionListRelationFilter = {
    every?: StoryVersionWhereInput
    some?: StoryVersionWhereInput
    none?: StoryVersionWhereInput
  }

  export type StoryVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryCountOrderByAggregateInput = {
    id?: SortOrder
    experience_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    situation?: SortOrder
    task?: SortOrder
    action?: SortOrder
    result?: SortOrder
    full_story?: SortOrder
    ai_generated?: SortOrder
    metrics?: SortOrder
    title?: SortOrder
    tags?: SortOrder
    is_draft?: SortOrder
    relevance_score?: SortOrder
    job_match_scores?: SortOrder
  }

  export type StoryAvgOrderByAggregateInput = {
    relevance_score?: SortOrder
  }

  export type StoryMaxOrderByAggregateInput = {
    id?: SortOrder
    experience_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    situation?: SortOrder
    task?: SortOrder
    action?: SortOrder
    result?: SortOrder
    full_story?: SortOrder
    ai_generated?: SortOrder
    title?: SortOrder
    is_draft?: SortOrder
    relevance_score?: SortOrder
  }

  export type StoryMinOrderByAggregateInput = {
    id?: SortOrder
    experience_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    situation?: SortOrder
    task?: SortOrder
    action?: SortOrder
    result?: SortOrder
    full_story?: SortOrder
    ai_generated?: SortOrder
    title?: SortOrder
    is_draft?: SortOrder
    relevance_score?: SortOrder
  }

  export type StorySumOrderByAggregateInput = {
    relevance_score?: SortOrder
  }

  export type StoryScalarRelationFilter = {
    is?: StoryWhereInput
    isNot?: StoryWhereInput
  }

  export type StoryVersionStory_idVersion_numberCompoundUniqueInput = {
    story_id: string
    version_number: number
  }

  export type StoryVersionCountOrderByAggregateInput = {
    id?: SortOrder
    story_id?: SortOrder
    created_at?: SortOrder
    version_number?: SortOrder
    situation?: SortOrder
    task?: SortOrder
    action?: SortOrder
    result?: SortOrder
    full_story?: SortOrder
    metrics?: SortOrder
    change_summary?: SortOrder
    created_by_ai?: SortOrder
  }

  export type StoryVersionAvgOrderByAggregateInput = {
    version_number?: SortOrder
  }

  export type StoryVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    story_id?: SortOrder
    created_at?: SortOrder
    version_number?: SortOrder
    situation?: SortOrder
    task?: SortOrder
    action?: SortOrder
    result?: SortOrder
    full_story?: SortOrder
    change_summary?: SortOrder
    created_by_ai?: SortOrder
  }

  export type StoryVersionMinOrderByAggregateInput = {
    id?: SortOrder
    story_id?: SortOrder
    created_at?: SortOrder
    version_number?: SortOrder
    situation?: SortOrder
    task?: SortOrder
    action?: SortOrder
    result?: SortOrder
    full_story?: SortOrder
    change_summary?: SortOrder
    created_by_ai?: SortOrder
  }

  export type StoryVersionSumOrderByAggregateInput = {
    version_number?: SortOrder
  }

  export type SkillScalarRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type StorySkillStory_idSkill_idCompoundUniqueInput = {
    story_id: string
    skill_id: string
  }

  export type StorySkillCountOrderByAggregateInput = {
    id?: SortOrder
    story_id?: SortOrder
    skill_id?: SortOrder
    created_at?: SortOrder
  }

  export type StorySkillMaxOrderByAggregateInput = {
    id?: SortOrder
    story_id?: SortOrder
    skill_id?: SortOrder
    created_at?: SortOrder
  }

  export type StorySkillMinOrderByAggregateInput = {
    id?: SortOrder
    story_id?: SortOrder
    skill_id?: SortOrder
    created_at?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ExperienceCreateNestedManyWithoutProfileInput = {
    create?: XOR<ExperienceCreateWithoutProfileInput, ExperienceUncheckedCreateWithoutProfileInput> | ExperienceCreateWithoutProfileInput[] | ExperienceUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutProfileInput | ExperienceCreateOrConnectWithoutProfileInput[]
    createMany?: ExperienceCreateManyProfileInputEnvelope
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
  }

  export type EducationCreateNestedManyWithoutProfileInput = {
    create?: XOR<EducationCreateWithoutProfileInput, EducationUncheckedCreateWithoutProfileInput> | EducationCreateWithoutProfileInput[] | EducationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutProfileInput | EducationCreateOrConnectWithoutProfileInput[]
    createMany?: EducationCreateManyProfileInputEnvelope
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
  }

  export type SkillCreateNestedManyWithoutProfileInput = {
    create?: XOR<SkillCreateWithoutProfileInput, SkillUncheckedCreateWithoutProfileInput> | SkillCreateWithoutProfileInput[] | SkillUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutProfileInput | SkillCreateOrConnectWithoutProfileInput[]
    createMany?: SkillCreateManyProfileInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type CertificationCreateNestedManyWithoutProfileInput = {
    create?: XOR<CertificationCreateWithoutProfileInput, CertificationUncheckedCreateWithoutProfileInput> | CertificationCreateWithoutProfileInput[] | CertificationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutProfileInput | CertificationCreateOrConnectWithoutProfileInput[]
    createMany?: CertificationCreateManyProfileInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProjectCreateWithoutProfileInput, ProjectUncheckedCreateWithoutProfileInput> | ProjectCreateWithoutProfileInput[] | ProjectUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProfileInput | ProjectCreateOrConnectWithoutProfileInput[]
    createMany?: ProjectCreateManyProfileInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type VolunteeringCreateNestedManyWithoutProfileInput = {
    create?: XOR<VolunteeringCreateWithoutProfileInput, VolunteeringUncheckedCreateWithoutProfileInput> | VolunteeringCreateWithoutProfileInput[] | VolunteeringUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: VolunteeringCreateOrConnectWithoutProfileInput | VolunteeringCreateOrConnectWithoutProfileInput[]
    createMany?: VolunteeringCreateManyProfileInputEnvelope
    connect?: VolunteeringWhereUniqueInput | VolunteeringWhereUniqueInput[]
  }

  export type LanguageCreateNestedManyWithoutProfileInput = {
    create?: XOR<LanguageCreateWithoutProfileInput, LanguageUncheckedCreateWithoutProfileInput> | LanguageCreateWithoutProfileInput[] | LanguageUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutProfileInput | LanguageCreateOrConnectWithoutProfileInput[]
    createMany?: LanguageCreateManyProfileInputEnvelope
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
  }

  export type OrganizationCreateNestedManyWithoutProfileInput = {
    create?: XOR<OrganizationCreateWithoutProfileInput, OrganizationUncheckedCreateWithoutProfileInput> | OrganizationCreateWithoutProfileInput[] | OrganizationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutProfileInput | OrganizationCreateOrConnectWithoutProfileInput[]
    createMany?: OrganizationCreateManyProfileInputEnvelope
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
  }

  export type ParsedDocumentCreateNestedManyWithoutProfileInput = {
    create?: XOR<ParsedDocumentCreateWithoutProfileInput, ParsedDocumentUncheckedCreateWithoutProfileInput> | ParsedDocumentCreateWithoutProfileInput[] | ParsedDocumentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ParsedDocumentCreateOrConnectWithoutProfileInput | ParsedDocumentCreateOrConnectWithoutProfileInput[]
    createMany?: ParsedDocumentCreateManyProfileInputEnvelope
    connect?: ParsedDocumentWhereUniqueInput | ParsedDocumentWhereUniqueInput[]
  }

  export type MediaLibraryCreateNestedManyWithoutProfileInput = {
    create?: XOR<MediaLibraryCreateWithoutProfileInput, MediaLibraryUncheckedCreateWithoutProfileInput> | MediaLibraryCreateWithoutProfileInput[] | MediaLibraryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MediaLibraryCreateOrConnectWithoutProfileInput | MediaLibraryCreateOrConnectWithoutProfileInput[]
    createMany?: MediaLibraryCreateManyProfileInputEnvelope
    connect?: MediaLibraryWhereUniqueInput | MediaLibraryWhereUniqueInput[]
  }

  export type CustomizedStoryCreateNestedManyWithoutProfileInput = {
    create?: XOR<CustomizedStoryCreateWithoutProfileInput, CustomizedStoryUncheckedCreateWithoutProfileInput> | CustomizedStoryCreateWithoutProfileInput[] | CustomizedStoryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CustomizedStoryCreateOrConnectWithoutProfileInput | CustomizedStoryCreateOrConnectWithoutProfileInput[]
    createMany?: CustomizedStoryCreateManyProfileInputEnvelope
    connect?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
  }

  export type ExperienceUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ExperienceCreateWithoutProfileInput, ExperienceUncheckedCreateWithoutProfileInput> | ExperienceCreateWithoutProfileInput[] | ExperienceUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutProfileInput | ExperienceCreateOrConnectWithoutProfileInput[]
    createMany?: ExperienceCreateManyProfileInputEnvelope
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
  }

  export type EducationUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<EducationCreateWithoutProfileInput, EducationUncheckedCreateWithoutProfileInput> | EducationCreateWithoutProfileInput[] | EducationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutProfileInput | EducationCreateOrConnectWithoutProfileInput[]
    createMany?: EducationCreateManyProfileInputEnvelope
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
  }

  export type SkillUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<SkillCreateWithoutProfileInput, SkillUncheckedCreateWithoutProfileInput> | SkillCreateWithoutProfileInput[] | SkillUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutProfileInput | SkillCreateOrConnectWithoutProfileInput[]
    createMany?: SkillCreateManyProfileInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type CertificationUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<CertificationCreateWithoutProfileInput, CertificationUncheckedCreateWithoutProfileInput> | CertificationCreateWithoutProfileInput[] | CertificationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutProfileInput | CertificationCreateOrConnectWithoutProfileInput[]
    createMany?: CertificationCreateManyProfileInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProjectCreateWithoutProfileInput, ProjectUncheckedCreateWithoutProfileInput> | ProjectCreateWithoutProfileInput[] | ProjectUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProfileInput | ProjectCreateOrConnectWithoutProfileInput[]
    createMany?: ProjectCreateManyProfileInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type VolunteeringUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<VolunteeringCreateWithoutProfileInput, VolunteeringUncheckedCreateWithoutProfileInput> | VolunteeringCreateWithoutProfileInput[] | VolunteeringUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: VolunteeringCreateOrConnectWithoutProfileInput | VolunteeringCreateOrConnectWithoutProfileInput[]
    createMany?: VolunteeringCreateManyProfileInputEnvelope
    connect?: VolunteeringWhereUniqueInput | VolunteeringWhereUniqueInput[]
  }

  export type LanguageUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<LanguageCreateWithoutProfileInput, LanguageUncheckedCreateWithoutProfileInput> | LanguageCreateWithoutProfileInput[] | LanguageUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutProfileInput | LanguageCreateOrConnectWithoutProfileInput[]
    createMany?: LanguageCreateManyProfileInputEnvelope
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
  }

  export type OrganizationUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<OrganizationCreateWithoutProfileInput, OrganizationUncheckedCreateWithoutProfileInput> | OrganizationCreateWithoutProfileInput[] | OrganizationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutProfileInput | OrganizationCreateOrConnectWithoutProfileInput[]
    createMany?: OrganizationCreateManyProfileInputEnvelope
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
  }

  export type ParsedDocumentUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ParsedDocumentCreateWithoutProfileInput, ParsedDocumentUncheckedCreateWithoutProfileInput> | ParsedDocumentCreateWithoutProfileInput[] | ParsedDocumentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ParsedDocumentCreateOrConnectWithoutProfileInput | ParsedDocumentCreateOrConnectWithoutProfileInput[]
    createMany?: ParsedDocumentCreateManyProfileInputEnvelope
    connect?: ParsedDocumentWhereUniqueInput | ParsedDocumentWhereUniqueInput[]
  }

  export type MediaLibraryUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<MediaLibraryCreateWithoutProfileInput, MediaLibraryUncheckedCreateWithoutProfileInput> | MediaLibraryCreateWithoutProfileInput[] | MediaLibraryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MediaLibraryCreateOrConnectWithoutProfileInput | MediaLibraryCreateOrConnectWithoutProfileInput[]
    createMany?: MediaLibraryCreateManyProfileInputEnvelope
    connect?: MediaLibraryWhereUniqueInput | MediaLibraryWhereUniqueInput[]
  }

  export type CustomizedStoryUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<CustomizedStoryCreateWithoutProfileInput, CustomizedStoryUncheckedCreateWithoutProfileInput> | CustomizedStoryCreateWithoutProfileInput[] | CustomizedStoryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CustomizedStoryCreateOrConnectWithoutProfileInput | CustomizedStoryCreateOrConnectWithoutProfileInput[]
    createMany?: CustomizedStoryCreateManyProfileInputEnvelope
    connect?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
  }

  export type ExperienceUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ExperienceCreateWithoutProfileInput, ExperienceUncheckedCreateWithoutProfileInput> | ExperienceCreateWithoutProfileInput[] | ExperienceUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutProfileInput | ExperienceCreateOrConnectWithoutProfileInput[]
    upsert?: ExperienceUpsertWithWhereUniqueWithoutProfileInput | ExperienceUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ExperienceCreateManyProfileInputEnvelope
    set?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    disconnect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    delete?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    update?: ExperienceUpdateWithWhereUniqueWithoutProfileInput | ExperienceUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ExperienceUpdateManyWithWhereWithoutProfileInput | ExperienceUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ExperienceScalarWhereInput | ExperienceScalarWhereInput[]
  }

  export type EducationUpdateManyWithoutProfileNestedInput = {
    create?: XOR<EducationCreateWithoutProfileInput, EducationUncheckedCreateWithoutProfileInput> | EducationCreateWithoutProfileInput[] | EducationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutProfileInput | EducationCreateOrConnectWithoutProfileInput[]
    upsert?: EducationUpsertWithWhereUniqueWithoutProfileInput | EducationUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: EducationCreateManyProfileInputEnvelope
    set?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    disconnect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    delete?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    update?: EducationUpdateWithWhereUniqueWithoutProfileInput | EducationUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: EducationUpdateManyWithWhereWithoutProfileInput | EducationUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: EducationScalarWhereInput | EducationScalarWhereInput[]
  }

  export type SkillUpdateManyWithoutProfileNestedInput = {
    create?: XOR<SkillCreateWithoutProfileInput, SkillUncheckedCreateWithoutProfileInput> | SkillCreateWithoutProfileInput[] | SkillUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutProfileInput | SkillCreateOrConnectWithoutProfileInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutProfileInput | SkillUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: SkillCreateManyProfileInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutProfileInput | SkillUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutProfileInput | SkillUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type CertificationUpdateManyWithoutProfileNestedInput = {
    create?: XOR<CertificationCreateWithoutProfileInput, CertificationUncheckedCreateWithoutProfileInput> | CertificationCreateWithoutProfileInput[] | CertificationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutProfileInput | CertificationCreateOrConnectWithoutProfileInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutProfileInput | CertificationUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: CertificationCreateManyProfileInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutProfileInput | CertificationUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutProfileInput | CertificationUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProjectCreateWithoutProfileInput, ProjectUncheckedCreateWithoutProfileInput> | ProjectCreateWithoutProfileInput[] | ProjectUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProfileInput | ProjectCreateOrConnectWithoutProfileInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProfileInput | ProjectUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProjectCreateManyProfileInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProfileInput | ProjectUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProfileInput | ProjectUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type VolunteeringUpdateManyWithoutProfileNestedInput = {
    create?: XOR<VolunteeringCreateWithoutProfileInput, VolunteeringUncheckedCreateWithoutProfileInput> | VolunteeringCreateWithoutProfileInput[] | VolunteeringUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: VolunteeringCreateOrConnectWithoutProfileInput | VolunteeringCreateOrConnectWithoutProfileInput[]
    upsert?: VolunteeringUpsertWithWhereUniqueWithoutProfileInput | VolunteeringUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: VolunteeringCreateManyProfileInputEnvelope
    set?: VolunteeringWhereUniqueInput | VolunteeringWhereUniqueInput[]
    disconnect?: VolunteeringWhereUniqueInput | VolunteeringWhereUniqueInput[]
    delete?: VolunteeringWhereUniqueInput | VolunteeringWhereUniqueInput[]
    connect?: VolunteeringWhereUniqueInput | VolunteeringWhereUniqueInput[]
    update?: VolunteeringUpdateWithWhereUniqueWithoutProfileInput | VolunteeringUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: VolunteeringUpdateManyWithWhereWithoutProfileInput | VolunteeringUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: VolunteeringScalarWhereInput | VolunteeringScalarWhereInput[]
  }

  export type LanguageUpdateManyWithoutProfileNestedInput = {
    create?: XOR<LanguageCreateWithoutProfileInput, LanguageUncheckedCreateWithoutProfileInput> | LanguageCreateWithoutProfileInput[] | LanguageUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutProfileInput | LanguageCreateOrConnectWithoutProfileInput[]
    upsert?: LanguageUpsertWithWhereUniqueWithoutProfileInput | LanguageUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: LanguageCreateManyProfileInputEnvelope
    set?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    disconnect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    delete?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    update?: LanguageUpdateWithWhereUniqueWithoutProfileInput | LanguageUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: LanguageUpdateManyWithWhereWithoutProfileInput | LanguageUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
  }

  export type OrganizationUpdateManyWithoutProfileNestedInput = {
    create?: XOR<OrganizationCreateWithoutProfileInput, OrganizationUncheckedCreateWithoutProfileInput> | OrganizationCreateWithoutProfileInput[] | OrganizationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutProfileInput | OrganizationCreateOrConnectWithoutProfileInput[]
    upsert?: OrganizationUpsertWithWhereUniqueWithoutProfileInput | OrganizationUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: OrganizationCreateManyProfileInputEnvelope
    set?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    disconnect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    delete?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    update?: OrganizationUpdateWithWhereUniqueWithoutProfileInput | OrganizationUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: OrganizationUpdateManyWithWhereWithoutProfileInput | OrganizationUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: OrganizationScalarWhereInput | OrganizationScalarWhereInput[]
  }

  export type ParsedDocumentUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ParsedDocumentCreateWithoutProfileInput, ParsedDocumentUncheckedCreateWithoutProfileInput> | ParsedDocumentCreateWithoutProfileInput[] | ParsedDocumentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ParsedDocumentCreateOrConnectWithoutProfileInput | ParsedDocumentCreateOrConnectWithoutProfileInput[]
    upsert?: ParsedDocumentUpsertWithWhereUniqueWithoutProfileInput | ParsedDocumentUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ParsedDocumentCreateManyProfileInputEnvelope
    set?: ParsedDocumentWhereUniqueInput | ParsedDocumentWhereUniqueInput[]
    disconnect?: ParsedDocumentWhereUniqueInput | ParsedDocumentWhereUniqueInput[]
    delete?: ParsedDocumentWhereUniqueInput | ParsedDocumentWhereUniqueInput[]
    connect?: ParsedDocumentWhereUniqueInput | ParsedDocumentWhereUniqueInput[]
    update?: ParsedDocumentUpdateWithWhereUniqueWithoutProfileInput | ParsedDocumentUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ParsedDocumentUpdateManyWithWhereWithoutProfileInput | ParsedDocumentUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ParsedDocumentScalarWhereInput | ParsedDocumentScalarWhereInput[]
  }

  export type MediaLibraryUpdateManyWithoutProfileNestedInput = {
    create?: XOR<MediaLibraryCreateWithoutProfileInput, MediaLibraryUncheckedCreateWithoutProfileInput> | MediaLibraryCreateWithoutProfileInput[] | MediaLibraryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MediaLibraryCreateOrConnectWithoutProfileInput | MediaLibraryCreateOrConnectWithoutProfileInput[]
    upsert?: MediaLibraryUpsertWithWhereUniqueWithoutProfileInput | MediaLibraryUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: MediaLibraryCreateManyProfileInputEnvelope
    set?: MediaLibraryWhereUniqueInput | MediaLibraryWhereUniqueInput[]
    disconnect?: MediaLibraryWhereUniqueInput | MediaLibraryWhereUniqueInput[]
    delete?: MediaLibraryWhereUniqueInput | MediaLibraryWhereUniqueInput[]
    connect?: MediaLibraryWhereUniqueInput | MediaLibraryWhereUniqueInput[]
    update?: MediaLibraryUpdateWithWhereUniqueWithoutProfileInput | MediaLibraryUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: MediaLibraryUpdateManyWithWhereWithoutProfileInput | MediaLibraryUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: MediaLibraryScalarWhereInput | MediaLibraryScalarWhereInput[]
  }

  export type CustomizedStoryUpdateManyWithoutProfileNestedInput = {
    create?: XOR<CustomizedStoryCreateWithoutProfileInput, CustomizedStoryUncheckedCreateWithoutProfileInput> | CustomizedStoryCreateWithoutProfileInput[] | CustomizedStoryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CustomizedStoryCreateOrConnectWithoutProfileInput | CustomizedStoryCreateOrConnectWithoutProfileInput[]
    upsert?: CustomizedStoryUpsertWithWhereUniqueWithoutProfileInput | CustomizedStoryUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: CustomizedStoryCreateManyProfileInputEnvelope
    set?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    disconnect?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    delete?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    connect?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    update?: CustomizedStoryUpdateWithWhereUniqueWithoutProfileInput | CustomizedStoryUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: CustomizedStoryUpdateManyWithWhereWithoutProfileInput | CustomizedStoryUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: CustomizedStoryScalarWhereInput | CustomizedStoryScalarWhereInput[]
  }

  export type ExperienceUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ExperienceCreateWithoutProfileInput, ExperienceUncheckedCreateWithoutProfileInput> | ExperienceCreateWithoutProfileInput[] | ExperienceUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutProfileInput | ExperienceCreateOrConnectWithoutProfileInput[]
    upsert?: ExperienceUpsertWithWhereUniqueWithoutProfileInput | ExperienceUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ExperienceCreateManyProfileInputEnvelope
    set?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    disconnect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    delete?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    update?: ExperienceUpdateWithWhereUniqueWithoutProfileInput | ExperienceUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ExperienceUpdateManyWithWhereWithoutProfileInput | ExperienceUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ExperienceScalarWhereInput | ExperienceScalarWhereInput[]
  }

  export type EducationUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<EducationCreateWithoutProfileInput, EducationUncheckedCreateWithoutProfileInput> | EducationCreateWithoutProfileInput[] | EducationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutProfileInput | EducationCreateOrConnectWithoutProfileInput[]
    upsert?: EducationUpsertWithWhereUniqueWithoutProfileInput | EducationUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: EducationCreateManyProfileInputEnvelope
    set?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    disconnect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    delete?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    update?: EducationUpdateWithWhereUniqueWithoutProfileInput | EducationUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: EducationUpdateManyWithWhereWithoutProfileInput | EducationUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: EducationScalarWhereInput | EducationScalarWhereInput[]
  }

  export type SkillUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<SkillCreateWithoutProfileInput, SkillUncheckedCreateWithoutProfileInput> | SkillCreateWithoutProfileInput[] | SkillUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutProfileInput | SkillCreateOrConnectWithoutProfileInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutProfileInput | SkillUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: SkillCreateManyProfileInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutProfileInput | SkillUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutProfileInput | SkillUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type CertificationUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<CertificationCreateWithoutProfileInput, CertificationUncheckedCreateWithoutProfileInput> | CertificationCreateWithoutProfileInput[] | CertificationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutProfileInput | CertificationCreateOrConnectWithoutProfileInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutProfileInput | CertificationUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: CertificationCreateManyProfileInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutProfileInput | CertificationUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutProfileInput | CertificationUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProjectCreateWithoutProfileInput, ProjectUncheckedCreateWithoutProfileInput> | ProjectCreateWithoutProfileInput[] | ProjectUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProfileInput | ProjectCreateOrConnectWithoutProfileInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProfileInput | ProjectUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProjectCreateManyProfileInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProfileInput | ProjectUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProfileInput | ProjectUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type VolunteeringUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<VolunteeringCreateWithoutProfileInput, VolunteeringUncheckedCreateWithoutProfileInput> | VolunteeringCreateWithoutProfileInput[] | VolunteeringUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: VolunteeringCreateOrConnectWithoutProfileInput | VolunteeringCreateOrConnectWithoutProfileInput[]
    upsert?: VolunteeringUpsertWithWhereUniqueWithoutProfileInput | VolunteeringUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: VolunteeringCreateManyProfileInputEnvelope
    set?: VolunteeringWhereUniqueInput | VolunteeringWhereUniqueInput[]
    disconnect?: VolunteeringWhereUniqueInput | VolunteeringWhereUniqueInput[]
    delete?: VolunteeringWhereUniqueInput | VolunteeringWhereUniqueInput[]
    connect?: VolunteeringWhereUniqueInput | VolunteeringWhereUniqueInput[]
    update?: VolunteeringUpdateWithWhereUniqueWithoutProfileInput | VolunteeringUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: VolunteeringUpdateManyWithWhereWithoutProfileInput | VolunteeringUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: VolunteeringScalarWhereInput | VolunteeringScalarWhereInput[]
  }

  export type LanguageUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<LanguageCreateWithoutProfileInput, LanguageUncheckedCreateWithoutProfileInput> | LanguageCreateWithoutProfileInput[] | LanguageUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutProfileInput | LanguageCreateOrConnectWithoutProfileInput[]
    upsert?: LanguageUpsertWithWhereUniqueWithoutProfileInput | LanguageUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: LanguageCreateManyProfileInputEnvelope
    set?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    disconnect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    delete?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    update?: LanguageUpdateWithWhereUniqueWithoutProfileInput | LanguageUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: LanguageUpdateManyWithWhereWithoutProfileInput | LanguageUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
  }

  export type OrganizationUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<OrganizationCreateWithoutProfileInput, OrganizationUncheckedCreateWithoutProfileInput> | OrganizationCreateWithoutProfileInput[] | OrganizationUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutProfileInput | OrganizationCreateOrConnectWithoutProfileInput[]
    upsert?: OrganizationUpsertWithWhereUniqueWithoutProfileInput | OrganizationUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: OrganizationCreateManyProfileInputEnvelope
    set?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    disconnect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    delete?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    update?: OrganizationUpdateWithWhereUniqueWithoutProfileInput | OrganizationUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: OrganizationUpdateManyWithWhereWithoutProfileInput | OrganizationUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: OrganizationScalarWhereInput | OrganizationScalarWhereInput[]
  }

  export type ParsedDocumentUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ParsedDocumentCreateWithoutProfileInput, ParsedDocumentUncheckedCreateWithoutProfileInput> | ParsedDocumentCreateWithoutProfileInput[] | ParsedDocumentUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ParsedDocumentCreateOrConnectWithoutProfileInput | ParsedDocumentCreateOrConnectWithoutProfileInput[]
    upsert?: ParsedDocumentUpsertWithWhereUniqueWithoutProfileInput | ParsedDocumentUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ParsedDocumentCreateManyProfileInputEnvelope
    set?: ParsedDocumentWhereUniqueInput | ParsedDocumentWhereUniqueInput[]
    disconnect?: ParsedDocumentWhereUniqueInput | ParsedDocumentWhereUniqueInput[]
    delete?: ParsedDocumentWhereUniqueInput | ParsedDocumentWhereUniqueInput[]
    connect?: ParsedDocumentWhereUniqueInput | ParsedDocumentWhereUniqueInput[]
    update?: ParsedDocumentUpdateWithWhereUniqueWithoutProfileInput | ParsedDocumentUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ParsedDocumentUpdateManyWithWhereWithoutProfileInput | ParsedDocumentUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ParsedDocumentScalarWhereInput | ParsedDocumentScalarWhereInput[]
  }

  export type MediaLibraryUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<MediaLibraryCreateWithoutProfileInput, MediaLibraryUncheckedCreateWithoutProfileInput> | MediaLibraryCreateWithoutProfileInput[] | MediaLibraryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MediaLibraryCreateOrConnectWithoutProfileInput | MediaLibraryCreateOrConnectWithoutProfileInput[]
    upsert?: MediaLibraryUpsertWithWhereUniqueWithoutProfileInput | MediaLibraryUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: MediaLibraryCreateManyProfileInputEnvelope
    set?: MediaLibraryWhereUniqueInput | MediaLibraryWhereUniqueInput[]
    disconnect?: MediaLibraryWhereUniqueInput | MediaLibraryWhereUniqueInput[]
    delete?: MediaLibraryWhereUniqueInput | MediaLibraryWhereUniqueInput[]
    connect?: MediaLibraryWhereUniqueInput | MediaLibraryWhereUniqueInput[]
    update?: MediaLibraryUpdateWithWhereUniqueWithoutProfileInput | MediaLibraryUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: MediaLibraryUpdateManyWithWhereWithoutProfileInput | MediaLibraryUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: MediaLibraryScalarWhereInput | MediaLibraryScalarWhereInput[]
  }

  export type CustomizedStoryUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<CustomizedStoryCreateWithoutProfileInput, CustomizedStoryUncheckedCreateWithoutProfileInput> | CustomizedStoryCreateWithoutProfileInput[] | CustomizedStoryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CustomizedStoryCreateOrConnectWithoutProfileInput | CustomizedStoryCreateOrConnectWithoutProfileInput[]
    upsert?: CustomizedStoryUpsertWithWhereUniqueWithoutProfileInput | CustomizedStoryUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: CustomizedStoryCreateManyProfileInputEnvelope
    set?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    disconnect?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    delete?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    connect?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    update?: CustomizedStoryUpdateWithWhereUniqueWithoutProfileInput | CustomizedStoryUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: CustomizedStoryUpdateManyWithWhereWithoutProfileInput | CustomizedStoryUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: CustomizedStoryScalarWhereInput | CustomizedStoryScalarWhereInput[]
  }

  export type ParsingJobCreateNestedManyWithoutParsed_documentInput = {
    create?: XOR<ParsingJobCreateWithoutParsed_documentInput, ParsingJobUncheckedCreateWithoutParsed_documentInput> | ParsingJobCreateWithoutParsed_documentInput[] | ParsingJobUncheckedCreateWithoutParsed_documentInput[]
    connectOrCreate?: ParsingJobCreateOrConnectWithoutParsed_documentInput | ParsingJobCreateOrConnectWithoutParsed_documentInput[]
    createMany?: ParsingJobCreateManyParsed_documentInputEnvelope
    connect?: ParsingJobWhereUniqueInput | ParsingJobWhereUniqueInput[]
  }

  export type ProfileCreateNestedOneWithoutParsed_documentsInput = {
    create?: XOR<ProfileCreateWithoutParsed_documentsInput, ProfileUncheckedCreateWithoutParsed_documentsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutParsed_documentsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ParsingJobUncheckedCreateNestedManyWithoutParsed_documentInput = {
    create?: XOR<ParsingJobCreateWithoutParsed_documentInput, ParsingJobUncheckedCreateWithoutParsed_documentInput> | ParsingJobCreateWithoutParsed_documentInput[] | ParsingJobUncheckedCreateWithoutParsed_documentInput[]
    connectOrCreate?: ParsingJobCreateOrConnectWithoutParsed_documentInput | ParsingJobCreateOrConnectWithoutParsed_documentInput[]
    createMany?: ParsingJobCreateManyParsed_documentInputEnvelope
    connect?: ParsingJobWhereUniqueInput | ParsingJobWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ParsingJobUpdateManyWithoutParsed_documentNestedInput = {
    create?: XOR<ParsingJobCreateWithoutParsed_documentInput, ParsingJobUncheckedCreateWithoutParsed_documentInput> | ParsingJobCreateWithoutParsed_documentInput[] | ParsingJobUncheckedCreateWithoutParsed_documentInput[]
    connectOrCreate?: ParsingJobCreateOrConnectWithoutParsed_documentInput | ParsingJobCreateOrConnectWithoutParsed_documentInput[]
    upsert?: ParsingJobUpsertWithWhereUniqueWithoutParsed_documentInput | ParsingJobUpsertWithWhereUniqueWithoutParsed_documentInput[]
    createMany?: ParsingJobCreateManyParsed_documentInputEnvelope
    set?: ParsingJobWhereUniqueInput | ParsingJobWhereUniqueInput[]
    disconnect?: ParsingJobWhereUniqueInput | ParsingJobWhereUniqueInput[]
    delete?: ParsingJobWhereUniqueInput | ParsingJobWhereUniqueInput[]
    connect?: ParsingJobWhereUniqueInput | ParsingJobWhereUniqueInput[]
    update?: ParsingJobUpdateWithWhereUniqueWithoutParsed_documentInput | ParsingJobUpdateWithWhereUniqueWithoutParsed_documentInput[]
    updateMany?: ParsingJobUpdateManyWithWhereWithoutParsed_documentInput | ParsingJobUpdateManyWithWhereWithoutParsed_documentInput[]
    deleteMany?: ParsingJobScalarWhereInput | ParsingJobScalarWhereInput[]
  }

  export type ProfileUpdateOneWithoutParsed_documentsNestedInput = {
    create?: XOR<ProfileCreateWithoutParsed_documentsInput, ProfileUncheckedCreateWithoutParsed_documentsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutParsed_documentsInput
    upsert?: ProfileUpsertWithoutParsed_documentsInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutParsed_documentsInput, ProfileUpdateWithoutParsed_documentsInput>, ProfileUncheckedUpdateWithoutParsed_documentsInput>
  }

  export type ParsingJobUncheckedUpdateManyWithoutParsed_documentNestedInput = {
    create?: XOR<ParsingJobCreateWithoutParsed_documentInput, ParsingJobUncheckedCreateWithoutParsed_documentInput> | ParsingJobCreateWithoutParsed_documentInput[] | ParsingJobUncheckedCreateWithoutParsed_documentInput[]
    connectOrCreate?: ParsingJobCreateOrConnectWithoutParsed_documentInput | ParsingJobCreateOrConnectWithoutParsed_documentInput[]
    upsert?: ParsingJobUpsertWithWhereUniqueWithoutParsed_documentInput | ParsingJobUpsertWithWhereUniqueWithoutParsed_documentInput[]
    createMany?: ParsingJobCreateManyParsed_documentInputEnvelope
    set?: ParsingJobWhereUniqueInput | ParsingJobWhereUniqueInput[]
    disconnect?: ParsingJobWhereUniqueInput | ParsingJobWhereUniqueInput[]
    delete?: ParsingJobWhereUniqueInput | ParsingJobWhereUniqueInput[]
    connect?: ParsingJobWhereUniqueInput | ParsingJobWhereUniqueInput[]
    update?: ParsingJobUpdateWithWhereUniqueWithoutParsed_documentInput | ParsingJobUpdateWithWhereUniqueWithoutParsed_documentInput[]
    updateMany?: ParsingJobUpdateManyWithWhereWithoutParsed_documentInput | ParsingJobUpdateManyWithWhereWithoutParsed_documentInput[]
    deleteMany?: ParsingJobScalarWhereInput | ParsingJobScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutExperiencesInput = {
    create?: XOR<ProfileCreateWithoutExperiencesInput, ProfileUncheckedCreateWithoutExperiencesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutExperiencesInput
    connect?: ProfileWhereUniqueInput
  }

  export type StoryCreateNestedManyWithoutExperienceInput = {
    create?: XOR<StoryCreateWithoutExperienceInput, StoryUncheckedCreateWithoutExperienceInput> | StoryCreateWithoutExperienceInput[] | StoryUncheckedCreateWithoutExperienceInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutExperienceInput | StoryCreateOrConnectWithoutExperienceInput[]
    createMany?: StoryCreateManyExperienceInputEnvelope
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type StoryUncheckedCreateNestedManyWithoutExperienceInput = {
    create?: XOR<StoryCreateWithoutExperienceInput, StoryUncheckedCreateWithoutExperienceInput> | StoryCreateWithoutExperienceInput[] | StoryUncheckedCreateWithoutExperienceInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutExperienceInput | StoryCreateOrConnectWithoutExperienceInput[]
    createMany?: StoryCreateManyExperienceInputEnvelope
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProfileUpdateOneRequiredWithoutExperiencesNestedInput = {
    create?: XOR<ProfileCreateWithoutExperiencesInput, ProfileUncheckedCreateWithoutExperiencesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutExperiencesInput
    upsert?: ProfileUpsertWithoutExperiencesInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutExperiencesInput, ProfileUpdateWithoutExperiencesInput>, ProfileUncheckedUpdateWithoutExperiencesInput>
  }

  export type StoryUpdateManyWithoutExperienceNestedInput = {
    create?: XOR<StoryCreateWithoutExperienceInput, StoryUncheckedCreateWithoutExperienceInput> | StoryCreateWithoutExperienceInput[] | StoryUncheckedCreateWithoutExperienceInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutExperienceInput | StoryCreateOrConnectWithoutExperienceInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutExperienceInput | StoryUpsertWithWhereUniqueWithoutExperienceInput[]
    createMany?: StoryCreateManyExperienceInputEnvelope
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutExperienceInput | StoryUpdateWithWhereUniqueWithoutExperienceInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutExperienceInput | StoryUpdateManyWithWhereWithoutExperienceInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type StoryUncheckedUpdateManyWithoutExperienceNestedInput = {
    create?: XOR<StoryCreateWithoutExperienceInput, StoryUncheckedCreateWithoutExperienceInput> | StoryCreateWithoutExperienceInput[] | StoryUncheckedCreateWithoutExperienceInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutExperienceInput | StoryCreateOrConnectWithoutExperienceInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutExperienceInput | StoryUpsertWithWhereUniqueWithoutExperienceInput[]
    createMany?: StoryCreateManyExperienceInputEnvelope
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutExperienceInput | StoryUpdateWithWhereUniqueWithoutExperienceInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutExperienceInput | StoryUpdateManyWithWhereWithoutExperienceInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutEducationInput = {
    create?: XOR<ProfileCreateWithoutEducationInput, ProfileUncheckedCreateWithoutEducationInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutEducationInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutEducationNestedInput = {
    create?: XOR<ProfileCreateWithoutEducationInput, ProfileUncheckedCreateWithoutEducationInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutEducationInput
    upsert?: ProfileUpsertWithoutEducationInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutEducationInput, ProfileUpdateWithoutEducationInput>, ProfileUncheckedUpdateWithoutEducationInput>
  }

  export type ProfileCreateNestedOneWithoutSkillsInput = {
    create?: XOR<ProfileCreateWithoutSkillsInput, ProfileUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSkillsInput
    connect?: ProfileWhereUniqueInput
  }

  export type StorySkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<StorySkillCreateWithoutSkillInput, StorySkillUncheckedCreateWithoutSkillInput> | StorySkillCreateWithoutSkillInput[] | StorySkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: StorySkillCreateOrConnectWithoutSkillInput | StorySkillCreateOrConnectWithoutSkillInput[]
    createMany?: StorySkillCreateManySkillInputEnvelope
    connect?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
  }

  export type StorySkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<StorySkillCreateWithoutSkillInput, StorySkillUncheckedCreateWithoutSkillInput> | StorySkillCreateWithoutSkillInput[] | StorySkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: StorySkillCreateOrConnectWithoutSkillInput | StorySkillCreateOrConnectWithoutSkillInput[]
    createMany?: StorySkillCreateManySkillInputEnvelope
    connect?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProfileUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<ProfileCreateWithoutSkillsInput, ProfileUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSkillsInput
    upsert?: ProfileUpsertWithoutSkillsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutSkillsInput, ProfileUpdateWithoutSkillsInput>, ProfileUncheckedUpdateWithoutSkillsInput>
  }

  export type StorySkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<StorySkillCreateWithoutSkillInput, StorySkillUncheckedCreateWithoutSkillInput> | StorySkillCreateWithoutSkillInput[] | StorySkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: StorySkillCreateOrConnectWithoutSkillInput | StorySkillCreateOrConnectWithoutSkillInput[]
    upsert?: StorySkillUpsertWithWhereUniqueWithoutSkillInput | StorySkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: StorySkillCreateManySkillInputEnvelope
    set?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    disconnect?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    delete?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    connect?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    update?: StorySkillUpdateWithWhereUniqueWithoutSkillInput | StorySkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: StorySkillUpdateManyWithWhereWithoutSkillInput | StorySkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: StorySkillScalarWhereInput | StorySkillScalarWhereInput[]
  }

  export type StorySkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<StorySkillCreateWithoutSkillInput, StorySkillUncheckedCreateWithoutSkillInput> | StorySkillCreateWithoutSkillInput[] | StorySkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: StorySkillCreateOrConnectWithoutSkillInput | StorySkillCreateOrConnectWithoutSkillInput[]
    upsert?: StorySkillUpsertWithWhereUniqueWithoutSkillInput | StorySkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: StorySkillCreateManySkillInputEnvelope
    set?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    disconnect?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    delete?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    connect?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    update?: StorySkillUpdateWithWhereUniqueWithoutSkillInput | StorySkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: StorySkillUpdateManyWithWhereWithoutSkillInput | StorySkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: StorySkillScalarWhereInput | StorySkillScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutCertificationsInput = {
    create?: XOR<ProfileCreateWithoutCertificationsInput, ProfileUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCertificationsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutCertificationsNestedInput = {
    create?: XOR<ProfileCreateWithoutCertificationsInput, ProfileUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCertificationsInput
    upsert?: ProfileUpsertWithoutCertificationsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutCertificationsInput, ProfileUpdateWithoutCertificationsInput>, ProfileUncheckedUpdateWithoutCertificationsInput>
  }

  export type ParsedDocumentCreateNestedOneWithoutParsing_jobsInput = {
    create?: XOR<ParsedDocumentCreateWithoutParsing_jobsInput, ParsedDocumentUncheckedCreateWithoutParsing_jobsInput>
    connectOrCreate?: ParsedDocumentCreateOrConnectWithoutParsing_jobsInput
    connect?: ParsedDocumentWhereUniqueInput
  }

  export type ParsedDocumentUpdateOneRequiredWithoutParsing_jobsNestedInput = {
    create?: XOR<ParsedDocumentCreateWithoutParsing_jobsInput, ParsedDocumentUncheckedCreateWithoutParsing_jobsInput>
    connectOrCreate?: ParsedDocumentCreateOrConnectWithoutParsing_jobsInput
    upsert?: ParsedDocumentUpsertWithoutParsing_jobsInput
    connect?: ParsedDocumentWhereUniqueInput
    update?: XOR<XOR<ParsedDocumentUpdateToOneWithWhereWithoutParsing_jobsInput, ParsedDocumentUpdateWithoutParsing_jobsInput>, ParsedDocumentUncheckedUpdateWithoutParsing_jobsInput>
  }

  export type ProfileCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ProfileCreateWithoutProjectsInput, ProfileUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutProjectsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<ProfileCreateWithoutProjectsInput, ProfileUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutProjectsInput
    upsert?: ProfileUpsertWithoutProjectsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutProjectsInput, ProfileUpdateWithoutProjectsInput>, ProfileUncheckedUpdateWithoutProjectsInput>
  }

  export type ProfileCreateNestedOneWithoutVolunteeringInput = {
    create?: XOR<ProfileCreateWithoutVolunteeringInput, ProfileUncheckedCreateWithoutVolunteeringInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutVolunteeringInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutVolunteeringNestedInput = {
    create?: XOR<ProfileCreateWithoutVolunteeringInput, ProfileUncheckedCreateWithoutVolunteeringInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutVolunteeringInput
    upsert?: ProfileUpsertWithoutVolunteeringInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutVolunteeringInput, ProfileUpdateWithoutVolunteeringInput>, ProfileUncheckedUpdateWithoutVolunteeringInput>
  }

  export type ProfileCreateNestedOneWithoutLanguagesInput = {
    create?: XOR<ProfileCreateWithoutLanguagesInput, ProfileUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLanguagesInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutLanguagesNestedInput = {
    create?: XOR<ProfileCreateWithoutLanguagesInput, ProfileUncheckedCreateWithoutLanguagesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLanguagesInput
    upsert?: ProfileUpsertWithoutLanguagesInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutLanguagesInput, ProfileUpdateWithoutLanguagesInput>, ProfileUncheckedUpdateWithoutLanguagesInput>
  }

  export type ProfileCreateNestedOneWithoutOrganizationsInput = {
    create?: XOR<ProfileCreateWithoutOrganizationsInput, ProfileUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutOrganizationsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutOrganizationsNestedInput = {
    create?: XOR<ProfileCreateWithoutOrganizationsInput, ProfileUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutOrganizationsInput
    upsert?: ProfileUpsertWithoutOrganizationsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutOrganizationsInput, ProfileUpdateWithoutOrganizationsInput>, ProfileUncheckedUpdateWithoutOrganizationsInput>
  }

  export type MediaLibraryCreatetagsInput = {
    set: string[]
  }

  export type ProfileCreateNestedOneWithoutMediaLibraryInput = {
    create?: XOR<ProfileCreateWithoutMediaLibraryInput, ProfileUncheckedCreateWithoutMediaLibraryInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMediaLibraryInput
    connect?: ProfileWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type MediaLibraryUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProfileUpdateOneRequiredWithoutMediaLibraryNestedInput = {
    create?: XOR<ProfileCreateWithoutMediaLibraryInput, ProfileUncheckedCreateWithoutMediaLibraryInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMediaLibraryInput
    upsert?: ProfileUpsertWithoutMediaLibraryInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutMediaLibraryInput, ProfileUpdateWithoutMediaLibraryInput>, ProfileUncheckedUpdateWithoutMediaLibraryInput>
  }

  export type PersonalityResponseCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<PersonalityResponseCreateWithoutAssessmentInput, PersonalityResponseUncheckedCreateWithoutAssessmentInput> | PersonalityResponseCreateWithoutAssessmentInput[] | PersonalityResponseUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: PersonalityResponseCreateOrConnectWithoutAssessmentInput | PersonalityResponseCreateOrConnectWithoutAssessmentInput[]
    createMany?: PersonalityResponseCreateManyAssessmentInputEnvelope
    connect?: PersonalityResponseWhereUniqueInput | PersonalityResponseWhereUniqueInput[]
  }

  export type PersonalityResponseUncheckedCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<PersonalityResponseCreateWithoutAssessmentInput, PersonalityResponseUncheckedCreateWithoutAssessmentInput> | PersonalityResponseCreateWithoutAssessmentInput[] | PersonalityResponseUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: PersonalityResponseCreateOrConnectWithoutAssessmentInput | PersonalityResponseCreateOrConnectWithoutAssessmentInput[]
    createMany?: PersonalityResponseCreateManyAssessmentInputEnvelope
    connect?: PersonalityResponseWhereUniqueInput | PersonalityResponseWhereUniqueInput[]
  }

  export type PersonalityResponseUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<PersonalityResponseCreateWithoutAssessmentInput, PersonalityResponseUncheckedCreateWithoutAssessmentInput> | PersonalityResponseCreateWithoutAssessmentInput[] | PersonalityResponseUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: PersonalityResponseCreateOrConnectWithoutAssessmentInput | PersonalityResponseCreateOrConnectWithoutAssessmentInput[]
    upsert?: PersonalityResponseUpsertWithWhereUniqueWithoutAssessmentInput | PersonalityResponseUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: PersonalityResponseCreateManyAssessmentInputEnvelope
    set?: PersonalityResponseWhereUniqueInput | PersonalityResponseWhereUniqueInput[]
    disconnect?: PersonalityResponseWhereUniqueInput | PersonalityResponseWhereUniqueInput[]
    delete?: PersonalityResponseWhereUniqueInput | PersonalityResponseWhereUniqueInput[]
    connect?: PersonalityResponseWhereUniqueInput | PersonalityResponseWhereUniqueInput[]
    update?: PersonalityResponseUpdateWithWhereUniqueWithoutAssessmentInput | PersonalityResponseUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: PersonalityResponseUpdateManyWithWhereWithoutAssessmentInput | PersonalityResponseUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: PersonalityResponseScalarWhereInput | PersonalityResponseScalarWhereInput[]
  }

  export type PersonalityResponseUncheckedUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<PersonalityResponseCreateWithoutAssessmentInput, PersonalityResponseUncheckedCreateWithoutAssessmentInput> | PersonalityResponseCreateWithoutAssessmentInput[] | PersonalityResponseUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: PersonalityResponseCreateOrConnectWithoutAssessmentInput | PersonalityResponseCreateOrConnectWithoutAssessmentInput[]
    upsert?: PersonalityResponseUpsertWithWhereUniqueWithoutAssessmentInput | PersonalityResponseUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: PersonalityResponseCreateManyAssessmentInputEnvelope
    set?: PersonalityResponseWhereUniqueInput | PersonalityResponseWhereUniqueInput[]
    disconnect?: PersonalityResponseWhereUniqueInput | PersonalityResponseWhereUniqueInput[]
    delete?: PersonalityResponseWhereUniqueInput | PersonalityResponseWhereUniqueInput[]
    connect?: PersonalityResponseWhereUniqueInput | PersonalityResponseWhereUniqueInput[]
    update?: PersonalityResponseUpdateWithWhereUniqueWithoutAssessmentInput | PersonalityResponseUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: PersonalityResponseUpdateManyWithWhereWithoutAssessmentInput | PersonalityResponseUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: PersonalityResponseScalarWhereInput | PersonalityResponseScalarWhereInput[]
  }

  export type PersonalityAssessmentCreateNestedOneWithoutResponses_relInput = {
    create?: XOR<PersonalityAssessmentCreateWithoutResponses_relInput, PersonalityAssessmentUncheckedCreateWithoutResponses_relInput>
    connectOrCreate?: PersonalityAssessmentCreateOrConnectWithoutResponses_relInput
    connect?: PersonalityAssessmentWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PersonalityAssessmentUpdateOneRequiredWithoutResponses_relNestedInput = {
    create?: XOR<PersonalityAssessmentCreateWithoutResponses_relInput, PersonalityAssessmentUncheckedCreateWithoutResponses_relInput>
    connectOrCreate?: PersonalityAssessmentCreateOrConnectWithoutResponses_relInput
    upsert?: PersonalityAssessmentUpsertWithoutResponses_relInput
    connect?: PersonalityAssessmentWhereUniqueInput
    update?: XOR<XOR<PersonalityAssessmentUpdateToOneWithWhereWithoutResponses_relInput, PersonalityAssessmentUpdateWithoutResponses_relInput>, PersonalityAssessmentUncheckedUpdateWithoutResponses_relInput>
  }

  export type AppAdminCreatepermissionsInput = {
    set: string[]
  }

  export type AppAdminCreateallowed_actionsInput = {
    set: string[]
  }

  export type AppAdminCreaterestricted_actionsInput = {
    set: string[]
  }

  export type AppAdminUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AppAdminUpdateallowed_actionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AppAdminUpdaterestricted_actionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CustomizedStoryCreateNestedManyWithoutJob_postInput = {
    create?: XOR<CustomizedStoryCreateWithoutJob_postInput, CustomizedStoryUncheckedCreateWithoutJob_postInput> | CustomizedStoryCreateWithoutJob_postInput[] | CustomizedStoryUncheckedCreateWithoutJob_postInput[]
    connectOrCreate?: CustomizedStoryCreateOrConnectWithoutJob_postInput | CustomizedStoryCreateOrConnectWithoutJob_postInput[]
    createMany?: CustomizedStoryCreateManyJob_postInputEnvelope
    connect?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
  }

  export type CustomizedStoryUncheckedCreateNestedManyWithoutJob_postInput = {
    create?: XOR<CustomizedStoryCreateWithoutJob_postInput, CustomizedStoryUncheckedCreateWithoutJob_postInput> | CustomizedStoryCreateWithoutJob_postInput[] | CustomizedStoryUncheckedCreateWithoutJob_postInput[]
    connectOrCreate?: CustomizedStoryCreateOrConnectWithoutJob_postInput | CustomizedStoryCreateOrConnectWithoutJob_postInput[]
    createMany?: CustomizedStoryCreateManyJob_postInputEnvelope
    connect?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
  }

  export type CustomizedStoryUpdateManyWithoutJob_postNestedInput = {
    create?: XOR<CustomizedStoryCreateWithoutJob_postInput, CustomizedStoryUncheckedCreateWithoutJob_postInput> | CustomizedStoryCreateWithoutJob_postInput[] | CustomizedStoryUncheckedCreateWithoutJob_postInput[]
    connectOrCreate?: CustomizedStoryCreateOrConnectWithoutJob_postInput | CustomizedStoryCreateOrConnectWithoutJob_postInput[]
    upsert?: CustomizedStoryUpsertWithWhereUniqueWithoutJob_postInput | CustomizedStoryUpsertWithWhereUniqueWithoutJob_postInput[]
    createMany?: CustomizedStoryCreateManyJob_postInputEnvelope
    set?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    disconnect?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    delete?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    connect?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    update?: CustomizedStoryUpdateWithWhereUniqueWithoutJob_postInput | CustomizedStoryUpdateWithWhereUniqueWithoutJob_postInput[]
    updateMany?: CustomizedStoryUpdateManyWithWhereWithoutJob_postInput | CustomizedStoryUpdateManyWithWhereWithoutJob_postInput[]
    deleteMany?: CustomizedStoryScalarWhereInput | CustomizedStoryScalarWhereInput[]
  }

  export type CustomizedStoryUncheckedUpdateManyWithoutJob_postNestedInput = {
    create?: XOR<CustomizedStoryCreateWithoutJob_postInput, CustomizedStoryUncheckedCreateWithoutJob_postInput> | CustomizedStoryCreateWithoutJob_postInput[] | CustomizedStoryUncheckedCreateWithoutJob_postInput[]
    connectOrCreate?: CustomizedStoryCreateOrConnectWithoutJob_postInput | CustomizedStoryCreateOrConnectWithoutJob_postInput[]
    upsert?: CustomizedStoryUpsertWithWhereUniqueWithoutJob_postInput | CustomizedStoryUpsertWithWhereUniqueWithoutJob_postInput[]
    createMany?: CustomizedStoryCreateManyJob_postInputEnvelope
    set?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    disconnect?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    delete?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    connect?: CustomizedStoryWhereUniqueInput | CustomizedStoryWhereUniqueInput[]
    update?: CustomizedStoryUpdateWithWhereUniqueWithoutJob_postInput | CustomizedStoryUpdateWithWhereUniqueWithoutJob_postInput[]
    updateMany?: CustomizedStoryUpdateManyWithWhereWithoutJob_postInput | CustomizedStoryUpdateManyWithWhereWithoutJob_postInput[]
    deleteMany?: CustomizedStoryScalarWhereInput | CustomizedStoryScalarWhereInput[]
  }

  export type CustomizedStoryCreatehighlighted_skillsInput = {
    set: string[]
  }

  export type JobPostCreateNestedOneWithoutCustomized_storiesInput = {
    create?: XOR<JobPostCreateWithoutCustomized_storiesInput, JobPostUncheckedCreateWithoutCustomized_storiesInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutCustomized_storiesInput
    connect?: JobPostWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutCustomizedStoriesInput = {
    create?: XOR<ProfileCreateWithoutCustomizedStoriesInput, ProfileUncheckedCreateWithoutCustomizedStoriesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCustomizedStoriesInput
    connect?: ProfileWhereUniqueInput
  }

  export type CustomizedStoryUpdatehighlighted_skillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type JobPostUpdateOneWithoutCustomized_storiesNestedInput = {
    create?: XOR<JobPostCreateWithoutCustomized_storiesInput, JobPostUncheckedCreateWithoutCustomized_storiesInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutCustomized_storiesInput
    upsert?: JobPostUpsertWithoutCustomized_storiesInput
    disconnect?: JobPostWhereInput | boolean
    delete?: JobPostWhereInput | boolean
    connect?: JobPostWhereUniqueInput
    update?: XOR<XOR<JobPostUpdateToOneWithWhereWithoutCustomized_storiesInput, JobPostUpdateWithoutCustomized_storiesInput>, JobPostUncheckedUpdateWithoutCustomized_storiesInput>
  }

  export type ProfileUpdateOneWithoutCustomizedStoriesNestedInput = {
    create?: XOR<ProfileCreateWithoutCustomizedStoriesInput, ProfileUncheckedCreateWithoutCustomizedStoriesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCustomizedStoriesInput
    upsert?: ProfileUpsertWithoutCustomizedStoriesInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutCustomizedStoriesInput, ProfileUpdateWithoutCustomizedStoriesInput>, ProfileUncheckedUpdateWithoutCustomizedStoriesInput>
  }

  export type StoryCreatetagsInput = {
    set: string[]
  }

  export type ExperienceCreateNestedOneWithoutStoriesInput = {
    create?: XOR<ExperienceCreateWithoutStoriesInput, ExperienceUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: ExperienceCreateOrConnectWithoutStoriesInput
    connect?: ExperienceWhereUniqueInput
  }

  export type StoryVersionCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryVersionCreateWithoutStoryInput, StoryVersionUncheckedCreateWithoutStoryInput> | StoryVersionCreateWithoutStoryInput[] | StoryVersionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutStoryInput | StoryVersionCreateOrConnectWithoutStoryInput[]
    createMany?: StoryVersionCreateManyStoryInputEnvelope
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
  }

  export type StorySkillCreateNestedManyWithoutStoryInput = {
    create?: XOR<StorySkillCreateWithoutStoryInput, StorySkillUncheckedCreateWithoutStoryInput> | StorySkillCreateWithoutStoryInput[] | StorySkillUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StorySkillCreateOrConnectWithoutStoryInput | StorySkillCreateOrConnectWithoutStoryInput[]
    createMany?: StorySkillCreateManyStoryInputEnvelope
    connect?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
  }

  export type StoryVersionUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryVersionCreateWithoutStoryInput, StoryVersionUncheckedCreateWithoutStoryInput> | StoryVersionCreateWithoutStoryInput[] | StoryVersionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutStoryInput | StoryVersionCreateOrConnectWithoutStoryInput[]
    createMany?: StoryVersionCreateManyStoryInputEnvelope
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
  }

  export type StorySkillUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<StorySkillCreateWithoutStoryInput, StorySkillUncheckedCreateWithoutStoryInput> | StorySkillCreateWithoutStoryInput[] | StorySkillUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StorySkillCreateOrConnectWithoutStoryInput | StorySkillCreateOrConnectWithoutStoryInput[]
    createMany?: StorySkillCreateManyStoryInputEnvelope
    connect?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
  }

  export type StoryUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExperienceUpdateOneRequiredWithoutStoriesNestedInput = {
    create?: XOR<ExperienceCreateWithoutStoriesInput, ExperienceUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: ExperienceCreateOrConnectWithoutStoriesInput
    upsert?: ExperienceUpsertWithoutStoriesInput
    connect?: ExperienceWhereUniqueInput
    update?: XOR<XOR<ExperienceUpdateToOneWithWhereWithoutStoriesInput, ExperienceUpdateWithoutStoriesInput>, ExperienceUncheckedUpdateWithoutStoriesInput>
  }

  export type StoryVersionUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryVersionCreateWithoutStoryInput, StoryVersionUncheckedCreateWithoutStoryInput> | StoryVersionCreateWithoutStoryInput[] | StoryVersionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutStoryInput | StoryVersionCreateOrConnectWithoutStoryInput[]
    upsert?: StoryVersionUpsertWithWhereUniqueWithoutStoryInput | StoryVersionUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryVersionCreateManyStoryInputEnvelope
    set?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    disconnect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    delete?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    update?: StoryVersionUpdateWithWhereUniqueWithoutStoryInput | StoryVersionUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryVersionUpdateManyWithWhereWithoutStoryInput | StoryVersionUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryVersionScalarWhereInput | StoryVersionScalarWhereInput[]
  }

  export type StorySkillUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StorySkillCreateWithoutStoryInput, StorySkillUncheckedCreateWithoutStoryInput> | StorySkillCreateWithoutStoryInput[] | StorySkillUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StorySkillCreateOrConnectWithoutStoryInput | StorySkillCreateOrConnectWithoutStoryInput[]
    upsert?: StorySkillUpsertWithWhereUniqueWithoutStoryInput | StorySkillUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StorySkillCreateManyStoryInputEnvelope
    set?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    disconnect?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    delete?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    connect?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    update?: StorySkillUpdateWithWhereUniqueWithoutStoryInput | StorySkillUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StorySkillUpdateManyWithWhereWithoutStoryInput | StorySkillUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StorySkillScalarWhereInput | StorySkillScalarWhereInput[]
  }

  export type StoryVersionUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryVersionCreateWithoutStoryInput, StoryVersionUncheckedCreateWithoutStoryInput> | StoryVersionCreateWithoutStoryInput[] | StoryVersionUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryVersionCreateOrConnectWithoutStoryInput | StoryVersionCreateOrConnectWithoutStoryInput[]
    upsert?: StoryVersionUpsertWithWhereUniqueWithoutStoryInput | StoryVersionUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryVersionCreateManyStoryInputEnvelope
    set?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    disconnect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    delete?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    connect?: StoryVersionWhereUniqueInput | StoryVersionWhereUniqueInput[]
    update?: StoryVersionUpdateWithWhereUniqueWithoutStoryInput | StoryVersionUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryVersionUpdateManyWithWhereWithoutStoryInput | StoryVersionUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryVersionScalarWhereInput | StoryVersionScalarWhereInput[]
  }

  export type StorySkillUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StorySkillCreateWithoutStoryInput, StorySkillUncheckedCreateWithoutStoryInput> | StorySkillCreateWithoutStoryInput[] | StorySkillUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StorySkillCreateOrConnectWithoutStoryInput | StorySkillCreateOrConnectWithoutStoryInput[]
    upsert?: StorySkillUpsertWithWhereUniqueWithoutStoryInput | StorySkillUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StorySkillCreateManyStoryInputEnvelope
    set?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    disconnect?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    delete?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    connect?: StorySkillWhereUniqueInput | StorySkillWhereUniqueInput[]
    update?: StorySkillUpdateWithWhereUniqueWithoutStoryInput | StorySkillUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StorySkillUpdateManyWithWhereWithoutStoryInput | StorySkillUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StorySkillScalarWhereInput | StorySkillScalarWhereInput[]
  }

  export type StoryCreateNestedOneWithoutVersionsInput = {
    create?: XOR<StoryCreateWithoutVersionsInput, StoryUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutVersionsInput
    connect?: StoryWhereUniqueInput
  }

  export type StoryUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<StoryCreateWithoutVersionsInput, StoryUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutVersionsInput
    upsert?: StoryUpsertWithoutVersionsInput
    connect?: StoryWhereUniqueInput
    update?: XOR<XOR<StoryUpdateToOneWithWhereWithoutVersionsInput, StoryUpdateWithoutVersionsInput>, StoryUncheckedUpdateWithoutVersionsInput>
  }

  export type StoryCreateNestedOneWithoutSkillsInput = {
    create?: XOR<StoryCreateWithoutSkillsInput, StoryUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutSkillsInput
    connect?: StoryWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutStorySkillsInput = {
    create?: XOR<SkillCreateWithoutStorySkillsInput, SkillUncheckedCreateWithoutStorySkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutStorySkillsInput
    connect?: SkillWhereUniqueInput
  }

  export type StoryUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<StoryCreateWithoutSkillsInput, StoryUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutSkillsInput
    upsert?: StoryUpsertWithoutSkillsInput
    connect?: StoryWhereUniqueInput
    update?: XOR<XOR<StoryUpdateToOneWithWhereWithoutSkillsInput, StoryUpdateWithoutSkillsInput>, StoryUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutStorySkillsNestedInput = {
    create?: XOR<SkillCreateWithoutStorySkillsInput, SkillUncheckedCreateWithoutStorySkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutStorySkillsInput
    upsert?: SkillUpsertWithoutStorySkillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutStorySkillsInput, SkillUpdateWithoutStorySkillsInput>, SkillUncheckedUpdateWithoutStorySkillsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ExperienceCreateWithoutProfileInput = {
    id?: string
    title?: string | null
    company?: string | null
    location?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_current?: boolean
    description?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: number | null
    created_at?: Date | string
    stories?: StoryCreateNestedManyWithoutExperienceInput
  }

  export type ExperienceUncheckedCreateWithoutProfileInput = {
    id?: string
    title?: string | null
    company?: string | null
    location?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_current?: boolean
    description?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: number | null
    created_at?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutExperienceInput
  }

  export type ExperienceCreateOrConnectWithoutProfileInput = {
    where: ExperienceWhereUniqueInput
    create: XOR<ExperienceCreateWithoutProfileInput, ExperienceUncheckedCreateWithoutProfileInput>
  }

  export type ExperienceCreateManyProfileInputEnvelope = {
    data: ExperienceCreateManyProfileInput | ExperienceCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type EducationCreateWithoutProfileInput = {
    id?: string
    school?: string | null
    degree?: string | null
    field_of_study?: string | null
    start_year?: number | null
    end_year?: number | null
    description?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type EducationUncheckedCreateWithoutProfileInput = {
    id?: string
    school?: string | null
    degree?: string | null
    field_of_study?: string | null
    start_year?: number | null
    end_year?: number | null
    description?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type EducationCreateOrConnectWithoutProfileInput = {
    where: EducationWhereUniqueInput
    create: XOR<EducationCreateWithoutProfileInput, EducationUncheckedCreateWithoutProfileInput>
  }

  export type EducationCreateManyProfileInputEnvelope = {
    data: EducationCreateManyProfileInput | EducationCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type SkillCreateWithoutProfileInput = {
    id?: string
    skill?: string | null
    confidence?: number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    storySkills?: StorySkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutProfileInput = {
    id?: string
    skill?: string | null
    confidence?: number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    storySkills?: StorySkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutProfileInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutProfileInput, SkillUncheckedCreateWithoutProfileInput>
  }

  export type SkillCreateManyProfileInputEnvelope = {
    data: SkillCreateManyProfileInput | SkillCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type CertificationCreateWithoutProfileInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type CertificationUncheckedCreateWithoutProfileInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type CertificationCreateOrConnectWithoutProfileInput = {
    where: CertificationWhereUniqueInput
    create: XOR<CertificationCreateWithoutProfileInput, CertificationUncheckedCreateWithoutProfileInput>
  }

  export type CertificationCreateManyProfileInputEnvelope = {
    data: CertificationCreateManyProfileInput | CertificationCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutProfileInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ProjectUncheckedCreateWithoutProfileInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ProjectCreateOrConnectWithoutProfileInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProfileInput, ProjectUncheckedCreateWithoutProfileInput>
  }

  export type ProjectCreateManyProfileInputEnvelope = {
    data: ProjectCreateManyProfileInput | ProjectCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type VolunteeringCreateWithoutProfileInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type VolunteeringUncheckedCreateWithoutProfileInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type VolunteeringCreateOrConnectWithoutProfileInput = {
    where: VolunteeringWhereUniqueInput
    create: XOR<VolunteeringCreateWithoutProfileInput, VolunteeringUncheckedCreateWithoutProfileInput>
  }

  export type VolunteeringCreateManyProfileInputEnvelope = {
    data: VolunteeringCreateManyProfileInput | VolunteeringCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type LanguageCreateWithoutProfileInput = {
    id?: string
    language?: string | null
    proficiency?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type LanguageUncheckedCreateWithoutProfileInput = {
    id?: string
    language?: string | null
    proficiency?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type LanguageCreateOrConnectWithoutProfileInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutProfileInput, LanguageUncheckedCreateWithoutProfileInput>
  }

  export type LanguageCreateManyProfileInputEnvelope = {
    data: LanguageCreateManyProfileInput | LanguageCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationCreateWithoutProfileInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type OrganizationUncheckedCreateWithoutProfileInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type OrganizationCreateOrConnectWithoutProfileInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProfileInput, OrganizationUncheckedCreateWithoutProfileInput>
  }

  export type OrganizationCreateManyProfileInputEnvelope = {
    data: OrganizationCreateManyProfileInput | OrganizationCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ParsedDocumentCreateWithoutProfileInput = {
    id?: string
    user_id?: string | null
    file_name?: string | null
    storage_path?: string | null
    content_type?: string | null
    size_bytes?: number | null
    text_extracted?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: string | null
    status?: string | null
    error_text?: string | null
    parsed_at?: Date | string | null
    created_at?: Date | string
    parsing_jobs?: ParsingJobCreateNestedManyWithoutParsed_documentInput
  }

  export type ParsedDocumentUncheckedCreateWithoutProfileInput = {
    id?: string
    user_id?: string | null
    file_name?: string | null
    storage_path?: string | null
    content_type?: string | null
    size_bytes?: number | null
    text_extracted?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: string | null
    status?: string | null
    error_text?: string | null
    parsed_at?: Date | string | null
    created_at?: Date | string
    parsing_jobs?: ParsingJobUncheckedCreateNestedManyWithoutParsed_documentInput
  }

  export type ParsedDocumentCreateOrConnectWithoutProfileInput = {
    where: ParsedDocumentWhereUniqueInput
    create: XOR<ParsedDocumentCreateWithoutProfileInput, ParsedDocumentUncheckedCreateWithoutProfileInput>
  }

  export type ParsedDocumentCreateManyProfileInputEnvelope = {
    data: ParsedDocumentCreateManyProfileInput | ParsedDocumentCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type MediaLibraryCreateWithoutProfileInput = {
    id?: string
    file_name: string
    file_type: string
    mime_type: string
    file_size: bigint | number
    storage_path: string
    storage_bucket?: string
    title?: string | null
    description?: string | null
    tags?: MediaLibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MediaLibraryUncheckedCreateWithoutProfileInput = {
    id?: string
    file_name: string
    file_type: string
    mime_type: string
    file_size: bigint | number
    storage_path: string
    storage_bucket?: string
    title?: string | null
    description?: string | null
    tags?: MediaLibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MediaLibraryCreateOrConnectWithoutProfileInput = {
    where: MediaLibraryWhereUniqueInput
    create: XOR<MediaLibraryCreateWithoutProfileInput, MediaLibraryUncheckedCreateWithoutProfileInput>
  }

  export type MediaLibraryCreateManyProfileInputEnvelope = {
    data: MediaLibraryCreateManyProfileInput | MediaLibraryCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type CustomizedStoryCreateWithoutProfileInput = {
    id?: string
    user_id: string
    story: string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryCreatehighlighted_skillsInput | string[]
    match_score: number
    score_breakdown: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    is_active?: boolean
    version_name?: string | null
    job_post?: JobPostCreateNestedOneWithoutCustomized_storiesInput
  }

  export type CustomizedStoryUncheckedCreateWithoutProfileInput = {
    id?: string
    user_id: string
    job_post_id?: string | null
    story: string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryCreatehighlighted_skillsInput | string[]
    match_score: number
    score_breakdown: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    is_active?: boolean
    version_name?: string | null
  }

  export type CustomizedStoryCreateOrConnectWithoutProfileInput = {
    where: CustomizedStoryWhereUniqueInput
    create: XOR<CustomizedStoryCreateWithoutProfileInput, CustomizedStoryUncheckedCreateWithoutProfileInput>
  }

  export type CustomizedStoryCreateManyProfileInputEnvelope = {
    data: CustomizedStoryCreateManyProfileInput | CustomizedStoryCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ExperienceUpsertWithWhereUniqueWithoutProfileInput = {
    where: ExperienceWhereUniqueInput
    update: XOR<ExperienceUpdateWithoutProfileInput, ExperienceUncheckedUpdateWithoutProfileInput>
    create: XOR<ExperienceCreateWithoutProfileInput, ExperienceUncheckedCreateWithoutProfileInput>
  }

  export type ExperienceUpdateWithWhereUniqueWithoutProfileInput = {
    where: ExperienceWhereUniqueInput
    data: XOR<ExperienceUpdateWithoutProfileInput, ExperienceUncheckedUpdateWithoutProfileInput>
  }

  export type ExperienceUpdateManyWithWhereWithoutProfileInput = {
    where: ExperienceScalarWhereInput
    data: XOR<ExperienceUpdateManyMutationInput, ExperienceUncheckedUpdateManyWithoutProfileInput>
  }

  export type ExperienceScalarWhereInput = {
    AND?: ExperienceScalarWhereInput | ExperienceScalarWhereInput[]
    OR?: ExperienceScalarWhereInput[]
    NOT?: ExperienceScalarWhereInput | ExperienceScalarWhereInput[]
    id?: StringFilter<"Experience"> | string
    profile_id?: StringFilter<"Experience"> | string
    title?: StringNullableFilter<"Experience"> | string | null
    company?: StringNullableFilter<"Experience"> | string | null
    location?: StringNullableFilter<"Experience"> | string | null
    start_date?: DateTimeNullableFilter<"Experience"> | Date | string | null
    end_date?: DateTimeNullableFilter<"Experience"> | Date | string | null
    is_current?: BoolFilter<"Experience"> | boolean
    description?: StringNullableFilter<"Experience"> | string | null
    raw_json?: JsonNullableFilter<"Experience">
    order_index?: IntNullableFilter<"Experience"> | number | null
    created_at?: DateTimeFilter<"Experience"> | Date | string
  }

  export type EducationUpsertWithWhereUniqueWithoutProfileInput = {
    where: EducationWhereUniqueInput
    update: XOR<EducationUpdateWithoutProfileInput, EducationUncheckedUpdateWithoutProfileInput>
    create: XOR<EducationCreateWithoutProfileInput, EducationUncheckedCreateWithoutProfileInput>
  }

  export type EducationUpdateWithWhereUniqueWithoutProfileInput = {
    where: EducationWhereUniqueInput
    data: XOR<EducationUpdateWithoutProfileInput, EducationUncheckedUpdateWithoutProfileInput>
  }

  export type EducationUpdateManyWithWhereWithoutProfileInput = {
    where: EducationScalarWhereInput
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyWithoutProfileInput>
  }

  export type EducationScalarWhereInput = {
    AND?: EducationScalarWhereInput | EducationScalarWhereInput[]
    OR?: EducationScalarWhereInput[]
    NOT?: EducationScalarWhereInput | EducationScalarWhereInput[]
    id?: StringFilter<"Education"> | string
    profile_id?: StringFilter<"Education"> | string
    school?: StringNullableFilter<"Education"> | string | null
    degree?: StringNullableFilter<"Education"> | string | null
    field_of_study?: StringNullableFilter<"Education"> | string | null
    start_year?: IntNullableFilter<"Education"> | number | null
    end_year?: IntNullableFilter<"Education"> | number | null
    description?: StringNullableFilter<"Education"> | string | null
    raw_json?: JsonNullableFilter<"Education">
    created_at?: DateTimeFilter<"Education"> | Date | string
  }

  export type SkillUpsertWithWhereUniqueWithoutProfileInput = {
    where: SkillWhereUniqueInput
    update: XOR<SkillUpdateWithoutProfileInput, SkillUncheckedUpdateWithoutProfileInput>
    create: XOR<SkillCreateWithoutProfileInput, SkillUncheckedCreateWithoutProfileInput>
  }

  export type SkillUpdateWithWhereUniqueWithoutProfileInput = {
    where: SkillWhereUniqueInput
    data: XOR<SkillUpdateWithoutProfileInput, SkillUncheckedUpdateWithoutProfileInput>
  }

  export type SkillUpdateManyWithWhereWithoutProfileInput = {
    where: SkillScalarWhereInput
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyWithoutProfileInput>
  }

  export type SkillScalarWhereInput = {
    AND?: SkillScalarWhereInput | SkillScalarWhereInput[]
    OR?: SkillScalarWhereInput[]
    NOT?: SkillScalarWhereInput | SkillScalarWhereInput[]
    id?: StringFilter<"Skill"> | string
    profile_id?: StringFilter<"Skill"> | string
    skill?: StringNullableFilter<"Skill"> | string | null
    confidence?: FloatNullableFilter<"Skill"> | number | null
    raw_json?: JsonNullableFilter<"Skill">
    created_at?: DateTimeFilter<"Skill"> | Date | string
  }

  export type CertificationUpsertWithWhereUniqueWithoutProfileInput = {
    where: CertificationWhereUniqueInput
    update: XOR<CertificationUpdateWithoutProfileInput, CertificationUncheckedUpdateWithoutProfileInput>
    create: XOR<CertificationCreateWithoutProfileInput, CertificationUncheckedCreateWithoutProfileInput>
  }

  export type CertificationUpdateWithWhereUniqueWithoutProfileInput = {
    where: CertificationWhereUniqueInput
    data: XOR<CertificationUpdateWithoutProfileInput, CertificationUncheckedUpdateWithoutProfileInput>
  }

  export type CertificationUpdateManyWithWhereWithoutProfileInput = {
    where: CertificationScalarWhereInput
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyWithoutProfileInput>
  }

  export type CertificationScalarWhereInput = {
    AND?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
    OR?: CertificationScalarWhereInput[]
    NOT?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
    id?: StringFilter<"Certification"> | string
    profile_id?: StringFilter<"Certification"> | string
    name?: StringNullableFilter<"Certification"> | string | null
    authority?: StringNullableFilter<"Certification"> | string | null
    issued_date?: DateTimeNullableFilter<"Certification"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"Certification"> | Date | string | null
    raw_json?: JsonNullableFilter<"Certification">
    created_at?: DateTimeFilter<"Certification"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutProfileInput, ProjectUncheckedUpdateWithoutProfileInput>
    create: XOR<ProjectCreateWithoutProfileInput, ProjectUncheckedCreateWithoutProfileInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutProfileInput, ProjectUncheckedUpdateWithoutProfileInput>
  }

  export type ProjectUpdateManyWithWhereWithoutProfileInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProfileInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    profile_id?: StringFilter<"Project"> | string
    name?: StringNullableFilter<"Project"> | string | null
    authority?: StringNullableFilter<"Project"> | string | null
    issued_date?: DateTimeNullableFilter<"Project"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"Project"> | Date | string | null
    raw_json?: JsonNullableFilter<"Project">
    created_at?: DateTimeFilter<"Project"> | Date | string
  }

  export type VolunteeringUpsertWithWhereUniqueWithoutProfileInput = {
    where: VolunteeringWhereUniqueInput
    update: XOR<VolunteeringUpdateWithoutProfileInput, VolunteeringUncheckedUpdateWithoutProfileInput>
    create: XOR<VolunteeringCreateWithoutProfileInput, VolunteeringUncheckedCreateWithoutProfileInput>
  }

  export type VolunteeringUpdateWithWhereUniqueWithoutProfileInput = {
    where: VolunteeringWhereUniqueInput
    data: XOR<VolunteeringUpdateWithoutProfileInput, VolunteeringUncheckedUpdateWithoutProfileInput>
  }

  export type VolunteeringUpdateManyWithWhereWithoutProfileInput = {
    where: VolunteeringScalarWhereInput
    data: XOR<VolunteeringUpdateManyMutationInput, VolunteeringUncheckedUpdateManyWithoutProfileInput>
  }

  export type VolunteeringScalarWhereInput = {
    AND?: VolunteeringScalarWhereInput | VolunteeringScalarWhereInput[]
    OR?: VolunteeringScalarWhereInput[]
    NOT?: VolunteeringScalarWhereInput | VolunteeringScalarWhereInput[]
    id?: StringFilter<"Volunteering"> | string
    profile_id?: StringFilter<"Volunteering"> | string
    name?: StringNullableFilter<"Volunteering"> | string | null
    authority?: StringNullableFilter<"Volunteering"> | string | null
    issued_date?: DateTimeNullableFilter<"Volunteering"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"Volunteering"> | Date | string | null
    raw_json?: JsonNullableFilter<"Volunteering">
    created_at?: DateTimeFilter<"Volunteering"> | Date | string
  }

  export type LanguageUpsertWithWhereUniqueWithoutProfileInput = {
    where: LanguageWhereUniqueInput
    update: XOR<LanguageUpdateWithoutProfileInput, LanguageUncheckedUpdateWithoutProfileInput>
    create: XOR<LanguageCreateWithoutProfileInput, LanguageUncheckedCreateWithoutProfileInput>
  }

  export type LanguageUpdateWithWhereUniqueWithoutProfileInput = {
    where: LanguageWhereUniqueInput
    data: XOR<LanguageUpdateWithoutProfileInput, LanguageUncheckedUpdateWithoutProfileInput>
  }

  export type LanguageUpdateManyWithWhereWithoutProfileInput = {
    where: LanguageScalarWhereInput
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyWithoutProfileInput>
  }

  export type LanguageScalarWhereInput = {
    AND?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
    OR?: LanguageScalarWhereInput[]
    NOT?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
    id?: StringFilter<"Language"> | string
    profile_id?: StringFilter<"Language"> | string
    language?: StringNullableFilter<"Language"> | string | null
    proficiency?: StringNullableFilter<"Language"> | string | null
    raw_json?: JsonNullableFilter<"Language">
    created_at?: DateTimeFilter<"Language"> | Date | string
  }

  export type OrganizationUpsertWithWhereUniqueWithoutProfileInput = {
    where: OrganizationWhereUniqueInput
    update: XOR<OrganizationUpdateWithoutProfileInput, OrganizationUncheckedUpdateWithoutProfileInput>
    create: XOR<OrganizationCreateWithoutProfileInput, OrganizationUncheckedCreateWithoutProfileInput>
  }

  export type OrganizationUpdateWithWhereUniqueWithoutProfileInput = {
    where: OrganizationWhereUniqueInput
    data: XOR<OrganizationUpdateWithoutProfileInput, OrganizationUncheckedUpdateWithoutProfileInput>
  }

  export type OrganizationUpdateManyWithWhereWithoutProfileInput = {
    where: OrganizationScalarWhereInput
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyWithoutProfileInput>
  }

  export type OrganizationScalarWhereInput = {
    AND?: OrganizationScalarWhereInput | OrganizationScalarWhereInput[]
    OR?: OrganizationScalarWhereInput[]
    NOT?: OrganizationScalarWhereInput | OrganizationScalarWhereInput[]
    id?: StringFilter<"Organization"> | string
    profile_id?: StringFilter<"Organization"> | string
    name?: StringNullableFilter<"Organization"> | string | null
    authority?: StringNullableFilter<"Organization"> | string | null
    issued_date?: DateTimeNullableFilter<"Organization"> | Date | string | null
    expiry_date?: DateTimeNullableFilter<"Organization"> | Date | string | null
    raw_json?: JsonNullableFilter<"Organization">
    created_at?: DateTimeFilter<"Organization"> | Date | string
  }

  export type ParsedDocumentUpsertWithWhereUniqueWithoutProfileInput = {
    where: ParsedDocumentWhereUniqueInput
    update: XOR<ParsedDocumentUpdateWithoutProfileInput, ParsedDocumentUncheckedUpdateWithoutProfileInput>
    create: XOR<ParsedDocumentCreateWithoutProfileInput, ParsedDocumentUncheckedCreateWithoutProfileInput>
  }

  export type ParsedDocumentUpdateWithWhereUniqueWithoutProfileInput = {
    where: ParsedDocumentWhereUniqueInput
    data: XOR<ParsedDocumentUpdateWithoutProfileInput, ParsedDocumentUncheckedUpdateWithoutProfileInput>
  }

  export type ParsedDocumentUpdateManyWithWhereWithoutProfileInput = {
    where: ParsedDocumentScalarWhereInput
    data: XOR<ParsedDocumentUpdateManyMutationInput, ParsedDocumentUncheckedUpdateManyWithoutProfileInput>
  }

  export type ParsedDocumentScalarWhereInput = {
    AND?: ParsedDocumentScalarWhereInput | ParsedDocumentScalarWhereInput[]
    OR?: ParsedDocumentScalarWhereInput[]
    NOT?: ParsedDocumentScalarWhereInput | ParsedDocumentScalarWhereInput[]
    id?: StringFilter<"ParsedDocument"> | string
    profile_id?: StringNullableFilter<"ParsedDocument"> | string | null
    user_id?: StringNullableFilter<"ParsedDocument"> | string | null
    file_name?: StringNullableFilter<"ParsedDocument"> | string | null
    storage_path?: StringNullableFilter<"ParsedDocument"> | string | null
    content_type?: StringNullableFilter<"ParsedDocument"> | string | null
    size_bytes?: IntNullableFilter<"ParsedDocument"> | number | null
    text_extracted?: StringNullableFilter<"ParsedDocument"> | string | null
    parsed_json?: JsonNullableFilter<"ParsedDocument">
    parser_version?: StringNullableFilter<"ParsedDocument"> | string | null
    status?: StringNullableFilter<"ParsedDocument"> | string | null
    error_text?: StringNullableFilter<"ParsedDocument"> | string | null
    parsed_at?: DateTimeNullableFilter<"ParsedDocument"> | Date | string | null
    created_at?: DateTimeFilter<"ParsedDocument"> | Date | string
  }

  export type MediaLibraryUpsertWithWhereUniqueWithoutProfileInput = {
    where: MediaLibraryWhereUniqueInput
    update: XOR<MediaLibraryUpdateWithoutProfileInput, MediaLibraryUncheckedUpdateWithoutProfileInput>
    create: XOR<MediaLibraryCreateWithoutProfileInput, MediaLibraryUncheckedCreateWithoutProfileInput>
  }

  export type MediaLibraryUpdateWithWhereUniqueWithoutProfileInput = {
    where: MediaLibraryWhereUniqueInput
    data: XOR<MediaLibraryUpdateWithoutProfileInput, MediaLibraryUncheckedUpdateWithoutProfileInput>
  }

  export type MediaLibraryUpdateManyWithWhereWithoutProfileInput = {
    where: MediaLibraryScalarWhereInput
    data: XOR<MediaLibraryUpdateManyMutationInput, MediaLibraryUncheckedUpdateManyWithoutProfileInput>
  }

  export type MediaLibraryScalarWhereInput = {
    AND?: MediaLibraryScalarWhereInput | MediaLibraryScalarWhereInput[]
    OR?: MediaLibraryScalarWhereInput[]
    NOT?: MediaLibraryScalarWhereInput | MediaLibraryScalarWhereInput[]
    id?: StringFilter<"MediaLibrary"> | string
    profile_id?: StringFilter<"MediaLibrary"> | string
    file_name?: StringFilter<"MediaLibrary"> | string
    file_type?: StringFilter<"MediaLibrary"> | string
    mime_type?: StringFilter<"MediaLibrary"> | string
    file_size?: BigIntFilter<"MediaLibrary"> | bigint | number
    storage_path?: StringFilter<"MediaLibrary"> | string
    storage_bucket?: StringFilter<"MediaLibrary"> | string
    title?: StringNullableFilter<"MediaLibrary"> | string | null
    description?: StringNullableFilter<"MediaLibrary"> | string | null
    tags?: StringNullableListFilter<"MediaLibrary">
    metadata?: JsonNullableFilter<"MediaLibrary">
    created_at?: DateTimeFilter<"MediaLibrary"> | Date | string
    updated_at?: DateTimeFilter<"MediaLibrary"> | Date | string
  }

  export type CustomizedStoryUpsertWithWhereUniqueWithoutProfileInput = {
    where: CustomizedStoryWhereUniqueInput
    update: XOR<CustomizedStoryUpdateWithoutProfileInput, CustomizedStoryUncheckedUpdateWithoutProfileInput>
    create: XOR<CustomizedStoryCreateWithoutProfileInput, CustomizedStoryUncheckedCreateWithoutProfileInput>
  }

  export type CustomizedStoryUpdateWithWhereUniqueWithoutProfileInput = {
    where: CustomizedStoryWhereUniqueInput
    data: XOR<CustomizedStoryUpdateWithoutProfileInput, CustomizedStoryUncheckedUpdateWithoutProfileInput>
  }

  export type CustomizedStoryUpdateManyWithWhereWithoutProfileInput = {
    where: CustomizedStoryScalarWhereInput
    data: XOR<CustomizedStoryUpdateManyMutationInput, CustomizedStoryUncheckedUpdateManyWithoutProfileInput>
  }

  export type CustomizedStoryScalarWhereInput = {
    AND?: CustomizedStoryScalarWhereInput | CustomizedStoryScalarWhereInput[]
    OR?: CustomizedStoryScalarWhereInput[]
    NOT?: CustomizedStoryScalarWhereInput | CustomizedStoryScalarWhereInput[]
    id?: StringFilter<"CustomizedStory"> | string
    user_id?: StringFilter<"CustomizedStory"> | string
    profile_id?: StringNullableFilter<"CustomizedStory"> | string | null
    job_post_id?: StringNullableFilter<"CustomizedStory"> | string | null
    story?: StringFilter<"CustomizedStory"> | string
    reordered_experience?: JsonNullableFilter<"CustomizedStory">
    highlighted_skills?: StringNullableListFilter<"CustomizedStory">
    match_score?: IntFilter<"CustomizedStory"> | number
    score_breakdown?: JsonFilter<"CustomizedStory">
    created_at?: DateTimeFilter<"CustomizedStory"> | Date | string
    updated_at?: DateTimeFilter<"CustomizedStory"> | Date | string
    is_active?: BoolFilter<"CustomizedStory"> | boolean
    version_name?: StringNullableFilter<"CustomizedStory"> | string | null
  }

  export type ParsingJobCreateWithoutParsed_documentInput = {
    id?: string
    status?: string | null
    attempts?: number | null
    worker?: string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
  }

  export type ParsingJobUncheckedCreateWithoutParsed_documentInput = {
    id?: string
    status?: string | null
    attempts?: number | null
    worker?: string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
  }

  export type ParsingJobCreateOrConnectWithoutParsed_documentInput = {
    where: ParsingJobWhereUniqueInput
    create: XOR<ParsingJobCreateWithoutParsed_documentInput, ParsingJobUncheckedCreateWithoutParsed_documentInput>
  }

  export type ParsingJobCreateManyParsed_documentInputEnvelope = {
    data: ParsingJobCreateManyParsed_documentInput | ParsingJobCreateManyParsed_documentInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutParsed_documentsInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceCreateNestedManyWithoutProfileInput
    education?: EducationCreateNestedManyWithoutProfileInput
    skills?: SkillCreateNestedManyWithoutProfileInput
    certifications?: CertificationCreateNestedManyWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringCreateNestedManyWithoutProfileInput
    languages?: LanguageCreateNestedManyWithoutProfileInput
    organizations?: OrganizationCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutParsed_documentsInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceUncheckedCreateNestedManyWithoutProfileInput
    education?: EducationUncheckedCreateNestedManyWithoutProfileInput
    skills?: SkillUncheckedCreateNestedManyWithoutProfileInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutProfileInput
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringUncheckedCreateNestedManyWithoutProfileInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProfileInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryUncheckedCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutParsed_documentsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutParsed_documentsInput, ProfileUncheckedCreateWithoutParsed_documentsInput>
  }

  export type ParsingJobUpsertWithWhereUniqueWithoutParsed_documentInput = {
    where: ParsingJobWhereUniqueInput
    update: XOR<ParsingJobUpdateWithoutParsed_documentInput, ParsingJobUncheckedUpdateWithoutParsed_documentInput>
    create: XOR<ParsingJobCreateWithoutParsed_documentInput, ParsingJobUncheckedCreateWithoutParsed_documentInput>
  }

  export type ParsingJobUpdateWithWhereUniqueWithoutParsed_documentInput = {
    where: ParsingJobWhereUniqueInput
    data: XOR<ParsingJobUpdateWithoutParsed_documentInput, ParsingJobUncheckedUpdateWithoutParsed_documentInput>
  }

  export type ParsingJobUpdateManyWithWhereWithoutParsed_documentInput = {
    where: ParsingJobScalarWhereInput
    data: XOR<ParsingJobUpdateManyMutationInput, ParsingJobUncheckedUpdateManyWithoutParsed_documentInput>
  }

  export type ParsingJobScalarWhereInput = {
    AND?: ParsingJobScalarWhereInput | ParsingJobScalarWhereInput[]
    OR?: ParsingJobScalarWhereInput[]
    NOT?: ParsingJobScalarWhereInput | ParsingJobScalarWhereInput[]
    id?: StringFilter<"ParsingJob"> | string
    parsed_document_id?: StringFilter<"ParsingJob"> | string
    status?: StringNullableFilter<"ParsingJob"> | string | null
    attempts?: IntNullableFilter<"ParsingJob"> | number | null
    worker?: StringNullableFilter<"ParsingJob"> | string | null
    started_at?: DateTimeNullableFilter<"ParsingJob"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"ParsingJob"> | Date | string | null
    created_at?: DateTimeFilter<"ParsingJob"> | Date | string
  }

  export type ProfileUpsertWithoutParsed_documentsInput = {
    update: XOR<ProfileUpdateWithoutParsed_documentsInput, ProfileUncheckedUpdateWithoutParsed_documentsInput>
    create: XOR<ProfileCreateWithoutParsed_documentsInput, ProfileUncheckedCreateWithoutParsed_documentsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutParsed_documentsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutParsed_documentsInput, ProfileUncheckedUpdateWithoutParsed_documentsInput>
  }

  export type ProfileUpdateWithoutParsed_documentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUpdateManyWithoutProfileNestedInput
    education?: EducationUpdateManyWithoutProfileNestedInput
    skills?: SkillUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUpdateManyWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUpdateManyWithoutProfileNestedInput
    languages?: LanguageUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutParsed_documentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUncheckedUpdateManyWithoutProfileNestedInput
    education?: EducationUncheckedUpdateManyWithoutProfileNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutProfileNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUncheckedUpdateManyWithoutProfileNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUncheckedUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateWithoutExperiencesInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    education?: EducationCreateNestedManyWithoutProfileInput
    skills?: SkillCreateNestedManyWithoutProfileInput
    certifications?: CertificationCreateNestedManyWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringCreateNestedManyWithoutProfileInput
    languages?: LanguageCreateNestedManyWithoutProfileInput
    organizations?: OrganizationCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutExperiencesInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    education?: EducationUncheckedCreateNestedManyWithoutProfileInput
    skills?: SkillUncheckedCreateNestedManyWithoutProfileInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutProfileInput
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringUncheckedCreateNestedManyWithoutProfileInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProfileInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentUncheckedCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryUncheckedCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutExperiencesInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutExperiencesInput, ProfileUncheckedCreateWithoutExperiencesInput>
  }

  export type StoryCreateWithoutExperienceInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    ai_generated?: boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: string | null
    tags?: StoryCreatetagsInput | string[]
    is_draft?: boolean
    relevance_score?: number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
    skills?: StorySkillCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutExperienceInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    ai_generated?: boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: string | null
    tags?: StoryCreatetagsInput | string[]
    is_draft?: boolean
    relevance_score?: number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
    skills?: StorySkillUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutExperienceInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutExperienceInput, StoryUncheckedCreateWithoutExperienceInput>
  }

  export type StoryCreateManyExperienceInputEnvelope = {
    data: StoryCreateManyExperienceInput | StoryCreateManyExperienceInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutExperiencesInput = {
    update: XOR<ProfileUpdateWithoutExperiencesInput, ProfileUncheckedUpdateWithoutExperiencesInput>
    create: XOR<ProfileCreateWithoutExperiencesInput, ProfileUncheckedCreateWithoutExperiencesInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutExperiencesInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutExperiencesInput, ProfileUncheckedUpdateWithoutExperiencesInput>
  }

  export type ProfileUpdateWithoutExperiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    education?: EducationUpdateManyWithoutProfileNestedInput
    skills?: SkillUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUpdateManyWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUpdateManyWithoutProfileNestedInput
    languages?: LanguageUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutExperiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    education?: EducationUncheckedUpdateManyWithoutProfileNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutProfileNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUncheckedUpdateManyWithoutProfileNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUncheckedUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUncheckedUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type StoryUpsertWithWhereUniqueWithoutExperienceInput = {
    where: StoryWhereUniqueInput
    update: XOR<StoryUpdateWithoutExperienceInput, StoryUncheckedUpdateWithoutExperienceInput>
    create: XOR<StoryCreateWithoutExperienceInput, StoryUncheckedCreateWithoutExperienceInput>
  }

  export type StoryUpdateWithWhereUniqueWithoutExperienceInput = {
    where: StoryWhereUniqueInput
    data: XOR<StoryUpdateWithoutExperienceInput, StoryUncheckedUpdateWithoutExperienceInput>
  }

  export type StoryUpdateManyWithWhereWithoutExperienceInput = {
    where: StoryScalarWhereInput
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyWithoutExperienceInput>
  }

  export type StoryScalarWhereInput = {
    AND?: StoryScalarWhereInput | StoryScalarWhereInput[]
    OR?: StoryScalarWhereInput[]
    NOT?: StoryScalarWhereInput | StoryScalarWhereInput[]
    id?: StringFilter<"Story"> | string
    experience_id?: StringFilter<"Story"> | string
    created_at?: DateTimeFilter<"Story"> | Date | string
    updated_at?: DateTimeFilter<"Story"> | Date | string
    situation?: StringNullableFilter<"Story"> | string | null
    task?: StringNullableFilter<"Story"> | string | null
    action?: StringNullableFilter<"Story"> | string | null
    result?: StringNullableFilter<"Story"> | string | null
    full_story?: StringNullableFilter<"Story"> | string | null
    ai_generated?: BoolFilter<"Story"> | boolean
    metrics?: JsonNullableFilter<"Story">
    title?: StringNullableFilter<"Story"> | string | null
    tags?: StringNullableListFilter<"Story">
    is_draft?: BoolFilter<"Story"> | boolean
    relevance_score?: FloatNullableFilter<"Story"> | number | null
    job_match_scores?: JsonNullableFilter<"Story">
  }

  export type ProfileCreateWithoutEducationInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceCreateNestedManyWithoutProfileInput
    skills?: SkillCreateNestedManyWithoutProfileInput
    certifications?: CertificationCreateNestedManyWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringCreateNestedManyWithoutProfileInput
    languages?: LanguageCreateNestedManyWithoutProfileInput
    organizations?: OrganizationCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutEducationInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceUncheckedCreateNestedManyWithoutProfileInput
    skills?: SkillUncheckedCreateNestedManyWithoutProfileInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutProfileInput
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringUncheckedCreateNestedManyWithoutProfileInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProfileInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentUncheckedCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryUncheckedCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutEducationInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutEducationInput, ProfileUncheckedCreateWithoutEducationInput>
  }

  export type ProfileUpsertWithoutEducationInput = {
    update: XOR<ProfileUpdateWithoutEducationInput, ProfileUncheckedUpdateWithoutEducationInput>
    create: XOR<ProfileCreateWithoutEducationInput, ProfileUncheckedCreateWithoutEducationInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutEducationInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutEducationInput, ProfileUncheckedUpdateWithoutEducationInput>
  }

  export type ProfileUpdateWithoutEducationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUpdateManyWithoutProfileNestedInput
    skills?: SkillUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUpdateManyWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUpdateManyWithoutProfileNestedInput
    languages?: LanguageUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutEducationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUncheckedUpdateManyWithoutProfileNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutProfileNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUncheckedUpdateManyWithoutProfileNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUncheckedUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUncheckedUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateWithoutSkillsInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceCreateNestedManyWithoutProfileInput
    education?: EducationCreateNestedManyWithoutProfileInput
    certifications?: CertificationCreateNestedManyWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringCreateNestedManyWithoutProfileInput
    languages?: LanguageCreateNestedManyWithoutProfileInput
    organizations?: OrganizationCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutSkillsInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceUncheckedCreateNestedManyWithoutProfileInput
    education?: EducationUncheckedCreateNestedManyWithoutProfileInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutProfileInput
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringUncheckedCreateNestedManyWithoutProfileInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProfileInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentUncheckedCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryUncheckedCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutSkillsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutSkillsInput, ProfileUncheckedCreateWithoutSkillsInput>
  }

  export type StorySkillCreateWithoutSkillInput = {
    id?: string
    created_at?: Date | string
    story: StoryCreateNestedOneWithoutSkillsInput
  }

  export type StorySkillUncheckedCreateWithoutSkillInput = {
    id?: string
    story_id: string
    created_at?: Date | string
  }

  export type StorySkillCreateOrConnectWithoutSkillInput = {
    where: StorySkillWhereUniqueInput
    create: XOR<StorySkillCreateWithoutSkillInput, StorySkillUncheckedCreateWithoutSkillInput>
  }

  export type StorySkillCreateManySkillInputEnvelope = {
    data: StorySkillCreateManySkillInput | StorySkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutSkillsInput = {
    update: XOR<ProfileUpdateWithoutSkillsInput, ProfileUncheckedUpdateWithoutSkillsInput>
    create: XOR<ProfileCreateWithoutSkillsInput, ProfileUncheckedCreateWithoutSkillsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutSkillsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutSkillsInput, ProfileUncheckedUpdateWithoutSkillsInput>
  }

  export type ProfileUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUpdateManyWithoutProfileNestedInput
    education?: EducationUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUpdateManyWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUpdateManyWithoutProfileNestedInput
    languages?: LanguageUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUncheckedUpdateManyWithoutProfileNestedInput
    education?: EducationUncheckedUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutProfileNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUncheckedUpdateManyWithoutProfileNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUncheckedUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUncheckedUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type StorySkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: StorySkillWhereUniqueInput
    update: XOR<StorySkillUpdateWithoutSkillInput, StorySkillUncheckedUpdateWithoutSkillInput>
    create: XOR<StorySkillCreateWithoutSkillInput, StorySkillUncheckedCreateWithoutSkillInput>
  }

  export type StorySkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: StorySkillWhereUniqueInput
    data: XOR<StorySkillUpdateWithoutSkillInput, StorySkillUncheckedUpdateWithoutSkillInput>
  }

  export type StorySkillUpdateManyWithWhereWithoutSkillInput = {
    where: StorySkillScalarWhereInput
    data: XOR<StorySkillUpdateManyMutationInput, StorySkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type StorySkillScalarWhereInput = {
    AND?: StorySkillScalarWhereInput | StorySkillScalarWhereInput[]
    OR?: StorySkillScalarWhereInput[]
    NOT?: StorySkillScalarWhereInput | StorySkillScalarWhereInput[]
    id?: StringFilter<"StorySkill"> | string
    story_id?: StringFilter<"StorySkill"> | string
    skill_id?: StringFilter<"StorySkill"> | string
    created_at?: DateTimeFilter<"StorySkill"> | Date | string
  }

  export type ProfileCreateWithoutCertificationsInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceCreateNestedManyWithoutProfileInput
    education?: EducationCreateNestedManyWithoutProfileInput
    skills?: SkillCreateNestedManyWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringCreateNestedManyWithoutProfileInput
    languages?: LanguageCreateNestedManyWithoutProfileInput
    organizations?: OrganizationCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutCertificationsInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceUncheckedCreateNestedManyWithoutProfileInput
    education?: EducationUncheckedCreateNestedManyWithoutProfileInput
    skills?: SkillUncheckedCreateNestedManyWithoutProfileInput
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringUncheckedCreateNestedManyWithoutProfileInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProfileInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentUncheckedCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryUncheckedCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutCertificationsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutCertificationsInput, ProfileUncheckedCreateWithoutCertificationsInput>
  }

  export type ProfileUpsertWithoutCertificationsInput = {
    update: XOR<ProfileUpdateWithoutCertificationsInput, ProfileUncheckedUpdateWithoutCertificationsInput>
    create: XOR<ProfileCreateWithoutCertificationsInput, ProfileUncheckedCreateWithoutCertificationsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutCertificationsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutCertificationsInput, ProfileUncheckedUpdateWithoutCertificationsInput>
  }

  export type ProfileUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUpdateManyWithoutProfileNestedInput
    education?: EducationUpdateManyWithoutProfileNestedInput
    skills?: SkillUpdateManyWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUpdateManyWithoutProfileNestedInput
    languages?: LanguageUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUncheckedUpdateManyWithoutProfileNestedInput
    education?: EducationUncheckedUpdateManyWithoutProfileNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProfileNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUncheckedUpdateManyWithoutProfileNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUncheckedUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUncheckedUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ParsedDocumentCreateWithoutParsing_jobsInput = {
    id?: string
    user_id?: string | null
    file_name?: string | null
    storage_path?: string | null
    content_type?: string | null
    size_bytes?: number | null
    text_extracted?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: string | null
    status?: string | null
    error_text?: string | null
    parsed_at?: Date | string | null
    created_at?: Date | string
    profile?: ProfileCreateNestedOneWithoutParsed_documentsInput
  }

  export type ParsedDocumentUncheckedCreateWithoutParsing_jobsInput = {
    id?: string
    profile_id?: string | null
    user_id?: string | null
    file_name?: string | null
    storage_path?: string | null
    content_type?: string | null
    size_bytes?: number | null
    text_extracted?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: string | null
    status?: string | null
    error_text?: string | null
    parsed_at?: Date | string | null
    created_at?: Date | string
  }

  export type ParsedDocumentCreateOrConnectWithoutParsing_jobsInput = {
    where: ParsedDocumentWhereUniqueInput
    create: XOR<ParsedDocumentCreateWithoutParsing_jobsInput, ParsedDocumentUncheckedCreateWithoutParsing_jobsInput>
  }

  export type ParsedDocumentUpsertWithoutParsing_jobsInput = {
    update: XOR<ParsedDocumentUpdateWithoutParsing_jobsInput, ParsedDocumentUncheckedUpdateWithoutParsing_jobsInput>
    create: XOR<ParsedDocumentCreateWithoutParsing_jobsInput, ParsedDocumentUncheckedCreateWithoutParsing_jobsInput>
    where?: ParsedDocumentWhereInput
  }

  export type ParsedDocumentUpdateToOneWithWhereWithoutParsing_jobsInput = {
    where?: ParsedDocumentWhereInput
    data: XOR<ParsedDocumentUpdateWithoutParsing_jobsInput, ParsedDocumentUncheckedUpdateWithoutParsing_jobsInput>
  }

  export type ParsedDocumentUpdateWithoutParsing_jobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    storage_path?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    text_extracted?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutParsed_documentsNestedInput
  }

  export type ParsedDocumentUncheckedUpdateWithoutParsing_jobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    storage_path?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    text_extracted?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateWithoutProjectsInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceCreateNestedManyWithoutProfileInput
    education?: EducationCreateNestedManyWithoutProfileInput
    skills?: SkillCreateNestedManyWithoutProfileInput
    certifications?: CertificationCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringCreateNestedManyWithoutProfileInput
    languages?: LanguageCreateNestedManyWithoutProfileInput
    organizations?: OrganizationCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutProjectsInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceUncheckedCreateNestedManyWithoutProfileInput
    education?: EducationUncheckedCreateNestedManyWithoutProfileInput
    skills?: SkillUncheckedCreateNestedManyWithoutProfileInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringUncheckedCreateNestedManyWithoutProfileInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProfileInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentUncheckedCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryUncheckedCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutProjectsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutProjectsInput, ProfileUncheckedCreateWithoutProjectsInput>
  }

  export type ProfileUpsertWithoutProjectsInput = {
    update: XOR<ProfileUpdateWithoutProjectsInput, ProfileUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProfileCreateWithoutProjectsInput, ProfileUncheckedCreateWithoutProjectsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutProjectsInput, ProfileUncheckedUpdateWithoutProjectsInput>
  }

  export type ProfileUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUpdateManyWithoutProfileNestedInput
    education?: EducationUpdateManyWithoutProfileNestedInput
    skills?: SkillUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUpdateManyWithoutProfileNestedInput
    languages?: LanguageUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUncheckedUpdateManyWithoutProfileNestedInput
    education?: EducationUncheckedUpdateManyWithoutProfileNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUncheckedUpdateManyWithoutProfileNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUncheckedUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUncheckedUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateWithoutVolunteeringInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceCreateNestedManyWithoutProfileInput
    education?: EducationCreateNestedManyWithoutProfileInput
    skills?: SkillCreateNestedManyWithoutProfileInput
    certifications?: CertificationCreateNestedManyWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
    languages?: LanguageCreateNestedManyWithoutProfileInput
    organizations?: OrganizationCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutVolunteeringInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceUncheckedCreateNestedManyWithoutProfileInput
    education?: EducationUncheckedCreateNestedManyWithoutProfileInput
    skills?: SkillUncheckedCreateNestedManyWithoutProfileInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutProfileInput
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProfileInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentUncheckedCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryUncheckedCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutVolunteeringInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutVolunteeringInput, ProfileUncheckedCreateWithoutVolunteeringInput>
  }

  export type ProfileUpsertWithoutVolunteeringInput = {
    update: XOR<ProfileUpdateWithoutVolunteeringInput, ProfileUncheckedUpdateWithoutVolunteeringInput>
    create: XOR<ProfileCreateWithoutVolunteeringInput, ProfileUncheckedCreateWithoutVolunteeringInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutVolunteeringInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutVolunteeringInput, ProfileUncheckedUpdateWithoutVolunteeringInput>
  }

  export type ProfileUpdateWithoutVolunteeringInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUpdateManyWithoutProfileNestedInput
    education?: EducationUpdateManyWithoutProfileNestedInput
    skills?: SkillUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUpdateManyWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
    languages?: LanguageUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutVolunteeringInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUncheckedUpdateManyWithoutProfileNestedInput
    education?: EducationUncheckedUpdateManyWithoutProfileNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutProfileNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUncheckedUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUncheckedUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateWithoutLanguagesInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceCreateNestedManyWithoutProfileInput
    education?: EducationCreateNestedManyWithoutProfileInput
    skills?: SkillCreateNestedManyWithoutProfileInput
    certifications?: CertificationCreateNestedManyWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringCreateNestedManyWithoutProfileInput
    organizations?: OrganizationCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutLanguagesInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceUncheckedCreateNestedManyWithoutProfileInput
    education?: EducationUncheckedCreateNestedManyWithoutProfileInput
    skills?: SkillUncheckedCreateNestedManyWithoutProfileInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutProfileInput
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringUncheckedCreateNestedManyWithoutProfileInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentUncheckedCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryUncheckedCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutLanguagesInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutLanguagesInput, ProfileUncheckedCreateWithoutLanguagesInput>
  }

  export type ProfileUpsertWithoutLanguagesInput = {
    update: XOR<ProfileUpdateWithoutLanguagesInput, ProfileUncheckedUpdateWithoutLanguagesInput>
    create: XOR<ProfileCreateWithoutLanguagesInput, ProfileUncheckedCreateWithoutLanguagesInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutLanguagesInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutLanguagesInput, ProfileUncheckedUpdateWithoutLanguagesInput>
  }

  export type ProfileUpdateWithoutLanguagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUpdateManyWithoutProfileNestedInput
    education?: EducationUpdateManyWithoutProfileNestedInput
    skills?: SkillUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUpdateManyWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutLanguagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUncheckedUpdateManyWithoutProfileNestedInput
    education?: EducationUncheckedUpdateManyWithoutProfileNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutProfileNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUncheckedUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUncheckedUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUncheckedUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateWithoutOrganizationsInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceCreateNestedManyWithoutProfileInput
    education?: EducationCreateNestedManyWithoutProfileInput
    skills?: SkillCreateNestedManyWithoutProfileInput
    certifications?: CertificationCreateNestedManyWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringCreateNestedManyWithoutProfileInput
    languages?: LanguageCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutOrganizationsInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceUncheckedCreateNestedManyWithoutProfileInput
    education?: EducationUncheckedCreateNestedManyWithoutProfileInput
    skills?: SkillUncheckedCreateNestedManyWithoutProfileInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutProfileInput
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringUncheckedCreateNestedManyWithoutProfileInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentUncheckedCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryUncheckedCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutOrganizationsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutOrganizationsInput, ProfileUncheckedCreateWithoutOrganizationsInput>
  }

  export type ProfileUpsertWithoutOrganizationsInput = {
    update: XOR<ProfileUpdateWithoutOrganizationsInput, ProfileUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<ProfileCreateWithoutOrganizationsInput, ProfileUncheckedCreateWithoutOrganizationsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutOrganizationsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutOrganizationsInput, ProfileUncheckedUpdateWithoutOrganizationsInput>
  }

  export type ProfileUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUpdateManyWithoutProfileNestedInput
    education?: EducationUpdateManyWithoutProfileNestedInput
    skills?: SkillUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUpdateManyWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUpdateManyWithoutProfileNestedInput
    languages?: LanguageUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUncheckedUpdateManyWithoutProfileNestedInput
    education?: EducationUncheckedUpdateManyWithoutProfileNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutProfileNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUncheckedUpdateManyWithoutProfileNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUncheckedUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUncheckedUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateWithoutMediaLibraryInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceCreateNestedManyWithoutProfileInput
    education?: EducationCreateNestedManyWithoutProfileInput
    skills?: SkillCreateNestedManyWithoutProfileInput
    certifications?: CertificationCreateNestedManyWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringCreateNestedManyWithoutProfileInput
    languages?: LanguageCreateNestedManyWithoutProfileInput
    organizations?: OrganizationCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutMediaLibraryInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceUncheckedCreateNestedManyWithoutProfileInput
    education?: EducationUncheckedCreateNestedManyWithoutProfileInput
    skills?: SkillUncheckedCreateNestedManyWithoutProfileInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutProfileInput
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringUncheckedCreateNestedManyWithoutProfileInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProfileInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentUncheckedCreateNestedManyWithoutProfileInput
    customizedStories?: CustomizedStoryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutMediaLibraryInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutMediaLibraryInput, ProfileUncheckedCreateWithoutMediaLibraryInput>
  }

  export type ProfileUpsertWithoutMediaLibraryInput = {
    update: XOR<ProfileUpdateWithoutMediaLibraryInput, ProfileUncheckedUpdateWithoutMediaLibraryInput>
    create: XOR<ProfileCreateWithoutMediaLibraryInput, ProfileUncheckedCreateWithoutMediaLibraryInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutMediaLibraryInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutMediaLibraryInput, ProfileUncheckedUpdateWithoutMediaLibraryInput>
  }

  export type ProfileUpdateWithoutMediaLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUpdateManyWithoutProfileNestedInput
    education?: EducationUpdateManyWithoutProfileNestedInput
    skills?: SkillUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUpdateManyWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUpdateManyWithoutProfileNestedInput
    languages?: LanguageUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutMediaLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUncheckedUpdateManyWithoutProfileNestedInput
    education?: EducationUncheckedUpdateManyWithoutProfileNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutProfileNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUncheckedUpdateManyWithoutProfileNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUncheckedUpdateManyWithoutProfileNestedInput
    customizedStories?: CustomizedStoryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type PersonalityResponseCreateWithoutAssessmentInput = {
    id?: string
    question_id: string
    question_text: string
    dimension: string
    response_value: number
    created_at?: Date | string
  }

  export type PersonalityResponseUncheckedCreateWithoutAssessmentInput = {
    id?: string
    question_id: string
    question_text: string
    dimension: string
    response_value: number
    created_at?: Date | string
  }

  export type PersonalityResponseCreateOrConnectWithoutAssessmentInput = {
    where: PersonalityResponseWhereUniqueInput
    create: XOR<PersonalityResponseCreateWithoutAssessmentInput, PersonalityResponseUncheckedCreateWithoutAssessmentInput>
  }

  export type PersonalityResponseCreateManyAssessmentInputEnvelope = {
    data: PersonalityResponseCreateManyAssessmentInput | PersonalityResponseCreateManyAssessmentInput[]
    skipDuplicates?: boolean
  }

  export type PersonalityResponseUpsertWithWhereUniqueWithoutAssessmentInput = {
    where: PersonalityResponseWhereUniqueInput
    update: XOR<PersonalityResponseUpdateWithoutAssessmentInput, PersonalityResponseUncheckedUpdateWithoutAssessmentInput>
    create: XOR<PersonalityResponseCreateWithoutAssessmentInput, PersonalityResponseUncheckedCreateWithoutAssessmentInput>
  }

  export type PersonalityResponseUpdateWithWhereUniqueWithoutAssessmentInput = {
    where: PersonalityResponseWhereUniqueInput
    data: XOR<PersonalityResponseUpdateWithoutAssessmentInput, PersonalityResponseUncheckedUpdateWithoutAssessmentInput>
  }

  export type PersonalityResponseUpdateManyWithWhereWithoutAssessmentInput = {
    where: PersonalityResponseScalarWhereInput
    data: XOR<PersonalityResponseUpdateManyMutationInput, PersonalityResponseUncheckedUpdateManyWithoutAssessmentInput>
  }

  export type PersonalityResponseScalarWhereInput = {
    AND?: PersonalityResponseScalarWhereInput | PersonalityResponseScalarWhereInput[]
    OR?: PersonalityResponseScalarWhereInput[]
    NOT?: PersonalityResponseScalarWhereInput | PersonalityResponseScalarWhereInput[]
    id?: StringFilter<"PersonalityResponse"> | string
    assessment_id?: StringFilter<"PersonalityResponse"> | string
    question_id?: StringFilter<"PersonalityResponse"> | string
    question_text?: StringFilter<"PersonalityResponse"> | string
    dimension?: StringFilter<"PersonalityResponse"> | string
    response_value?: IntFilter<"PersonalityResponse"> | number
    created_at?: DateTimeFilter<"PersonalityResponse"> | Date | string
  }

  export type PersonalityAssessmentCreateWithoutResponses_relInput = {
    id?: string
    users_id: string
    assessment_date?: Date | string
    completed?: boolean
    time_taken_seconds?: number | null
    openness_score?: number | null
    conscientiousness_score?: number | null
    extraversion_score?: number | null
    agreeableness_score?: number | null
    emotional_stability_score?: number | null
    overall_score?: number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PersonalityAssessmentUncheckedCreateWithoutResponses_relInput = {
    id?: string
    users_id: string
    assessment_date?: Date | string
    completed?: boolean
    time_taken_seconds?: number | null
    openness_score?: number | null
    conscientiousness_score?: number | null
    extraversion_score?: number | null
    agreeableness_score?: number | null
    emotional_stability_score?: number | null
    overall_score?: number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PersonalityAssessmentCreateOrConnectWithoutResponses_relInput = {
    where: PersonalityAssessmentWhereUniqueInput
    create: XOR<PersonalityAssessmentCreateWithoutResponses_relInput, PersonalityAssessmentUncheckedCreateWithoutResponses_relInput>
  }

  export type PersonalityAssessmentUpsertWithoutResponses_relInput = {
    update: XOR<PersonalityAssessmentUpdateWithoutResponses_relInput, PersonalityAssessmentUncheckedUpdateWithoutResponses_relInput>
    create: XOR<PersonalityAssessmentCreateWithoutResponses_relInput, PersonalityAssessmentUncheckedCreateWithoutResponses_relInput>
    where?: PersonalityAssessmentWhereInput
  }

  export type PersonalityAssessmentUpdateToOneWithWhereWithoutResponses_relInput = {
    where?: PersonalityAssessmentWhereInput
    data: XOR<PersonalityAssessmentUpdateWithoutResponses_relInput, PersonalityAssessmentUncheckedUpdateWithoutResponses_relInput>
  }

  export type PersonalityAssessmentUpdateWithoutResponses_relInput = {
    id?: StringFieldUpdateOperationsInput | string
    users_id?: StringFieldUpdateOperationsInput | string
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    time_taken_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    openness_score?: NullableIntFieldUpdateOperationsInput | number | null
    conscientiousness_score?: NullableIntFieldUpdateOperationsInput | number | null
    extraversion_score?: NullableIntFieldUpdateOperationsInput | number | null
    agreeableness_score?: NullableIntFieldUpdateOperationsInput | number | null
    emotional_stability_score?: NullableIntFieldUpdateOperationsInput | number | null
    overall_score?: NullableFloatFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalityAssessmentUncheckedUpdateWithoutResponses_relInput = {
    id?: StringFieldUpdateOperationsInput | string
    users_id?: StringFieldUpdateOperationsInput | string
    assessment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    time_taken_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    openness_score?: NullableIntFieldUpdateOperationsInput | number | null
    conscientiousness_score?: NullableIntFieldUpdateOperationsInput | number | null
    extraversion_score?: NullableIntFieldUpdateOperationsInput | number | null
    agreeableness_score?: NullableIntFieldUpdateOperationsInput | number | null
    emotional_stability_score?: NullableIntFieldUpdateOperationsInput | number | null
    overall_score?: NullableFloatFieldUpdateOperationsInput | number | null
    responses?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomizedStoryCreateWithoutJob_postInput = {
    id?: string
    user_id: string
    story: string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryCreatehighlighted_skillsInput | string[]
    match_score: number
    score_breakdown: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    is_active?: boolean
    version_name?: string | null
    profile?: ProfileCreateNestedOneWithoutCustomizedStoriesInput
  }

  export type CustomizedStoryUncheckedCreateWithoutJob_postInput = {
    id?: string
    user_id: string
    profile_id?: string | null
    story: string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryCreatehighlighted_skillsInput | string[]
    match_score: number
    score_breakdown: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    is_active?: boolean
    version_name?: string | null
  }

  export type CustomizedStoryCreateOrConnectWithoutJob_postInput = {
    where: CustomizedStoryWhereUniqueInput
    create: XOR<CustomizedStoryCreateWithoutJob_postInput, CustomizedStoryUncheckedCreateWithoutJob_postInput>
  }

  export type CustomizedStoryCreateManyJob_postInputEnvelope = {
    data: CustomizedStoryCreateManyJob_postInput | CustomizedStoryCreateManyJob_postInput[]
    skipDuplicates?: boolean
  }

  export type CustomizedStoryUpsertWithWhereUniqueWithoutJob_postInput = {
    where: CustomizedStoryWhereUniqueInput
    update: XOR<CustomizedStoryUpdateWithoutJob_postInput, CustomizedStoryUncheckedUpdateWithoutJob_postInput>
    create: XOR<CustomizedStoryCreateWithoutJob_postInput, CustomizedStoryUncheckedCreateWithoutJob_postInput>
  }

  export type CustomizedStoryUpdateWithWhereUniqueWithoutJob_postInput = {
    where: CustomizedStoryWhereUniqueInput
    data: XOR<CustomizedStoryUpdateWithoutJob_postInput, CustomizedStoryUncheckedUpdateWithoutJob_postInput>
  }

  export type CustomizedStoryUpdateManyWithWhereWithoutJob_postInput = {
    where: CustomizedStoryScalarWhereInput
    data: XOR<CustomizedStoryUpdateManyMutationInput, CustomizedStoryUncheckedUpdateManyWithoutJob_postInput>
  }

  export type JobPostCreateWithoutCustomized_storiesInput = {
    id?: string
    user_id: string
    title: string
    company?: string | null
    location?: string | null
    raw_description: string
    job_url?: string | null
    parsed_data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string | null
    applied_at?: Date | string | null
  }

  export type JobPostUncheckedCreateWithoutCustomized_storiesInput = {
    id?: string
    user_id: string
    title: string
    company?: string | null
    location?: string | null
    raw_description: string
    job_url?: string | null
    parsed_data: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    status?: string | null
    applied_at?: Date | string | null
  }

  export type JobPostCreateOrConnectWithoutCustomized_storiesInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutCustomized_storiesInput, JobPostUncheckedCreateWithoutCustomized_storiesInput>
  }

  export type ProfileCreateWithoutCustomizedStoriesInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceCreateNestedManyWithoutProfileInput
    education?: EducationCreateNestedManyWithoutProfileInput
    skills?: SkillCreateNestedManyWithoutProfileInput
    certifications?: CertificationCreateNestedManyWithoutProfileInput
    projects?: ProjectCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringCreateNestedManyWithoutProfileInput
    languages?: LanguageCreateNestedManyWithoutProfileInput
    organizations?: OrganizationCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutCustomizedStoriesInput = {
    id?: string
    user_id?: string | null
    full_name?: string | null
    preferred_name?: string | null
    headline?: string | null
    summary?: string | null
    location?: string | null
    website?: string | null
    email?: string | null
    phone?: string | null
    about?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    experiences?: ExperienceUncheckedCreateNestedManyWithoutProfileInput
    education?: EducationUncheckedCreateNestedManyWithoutProfileInput
    skills?: SkillUncheckedCreateNestedManyWithoutProfileInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutProfileInput
    projects?: ProjectUncheckedCreateNestedManyWithoutProfileInput
    volunteering?: VolunteeringUncheckedCreateNestedManyWithoutProfileInput
    languages?: LanguageUncheckedCreateNestedManyWithoutProfileInput
    organizations?: OrganizationUncheckedCreateNestedManyWithoutProfileInput
    parsed_documents?: ParsedDocumentUncheckedCreateNestedManyWithoutProfileInput
    mediaLibrary?: MediaLibraryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutCustomizedStoriesInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutCustomizedStoriesInput, ProfileUncheckedCreateWithoutCustomizedStoriesInput>
  }

  export type JobPostUpsertWithoutCustomized_storiesInput = {
    update: XOR<JobPostUpdateWithoutCustomized_storiesInput, JobPostUncheckedUpdateWithoutCustomized_storiesInput>
    create: XOR<JobPostCreateWithoutCustomized_storiesInput, JobPostUncheckedCreateWithoutCustomized_storiesInput>
    where?: JobPostWhereInput
  }

  export type JobPostUpdateToOneWithWhereWithoutCustomized_storiesInput = {
    where?: JobPostWhereInput
    data: XOR<JobPostUpdateWithoutCustomized_storiesInput, JobPostUncheckedUpdateWithoutCustomized_storiesInput>
  }

  export type JobPostUpdateWithoutCustomized_storiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    raw_description?: StringFieldUpdateOperationsInput | string
    job_url?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobPostUncheckedUpdateWithoutCustomized_storiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    raw_description?: StringFieldUpdateOperationsInput | string
    job_url?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProfileUpsertWithoutCustomizedStoriesInput = {
    update: XOR<ProfileUpdateWithoutCustomizedStoriesInput, ProfileUncheckedUpdateWithoutCustomizedStoriesInput>
    create: XOR<ProfileCreateWithoutCustomizedStoriesInput, ProfileUncheckedCreateWithoutCustomizedStoriesInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutCustomizedStoriesInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutCustomizedStoriesInput, ProfileUncheckedUpdateWithoutCustomizedStoriesInput>
  }

  export type ProfileUpdateWithoutCustomizedStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUpdateManyWithoutProfileNestedInput
    education?: EducationUpdateManyWithoutProfileNestedInput
    skills?: SkillUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUpdateManyWithoutProfileNestedInput
    projects?: ProjectUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUpdateManyWithoutProfileNestedInput
    languages?: LanguageUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutCustomizedStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_name?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUncheckedUpdateManyWithoutProfileNestedInput
    education?: EducationUncheckedUpdateManyWithoutProfileNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProfileNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutProfileNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutProfileNestedInput
    volunteering?: VolunteeringUncheckedUpdateManyWithoutProfileNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutProfileNestedInput
    organizations?: OrganizationUncheckedUpdateManyWithoutProfileNestedInput
    parsed_documents?: ParsedDocumentUncheckedUpdateManyWithoutProfileNestedInput
    mediaLibrary?: MediaLibraryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ExperienceCreateWithoutStoriesInput = {
    id?: string
    title?: string | null
    company?: string | null
    location?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_current?: boolean
    description?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: number | null
    created_at?: Date | string
    profile: ProfileCreateNestedOneWithoutExperiencesInput
  }

  export type ExperienceUncheckedCreateWithoutStoriesInput = {
    id?: string
    profile_id: string
    title?: string | null
    company?: string | null
    location?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_current?: boolean
    description?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: number | null
    created_at?: Date | string
  }

  export type ExperienceCreateOrConnectWithoutStoriesInput = {
    where: ExperienceWhereUniqueInput
    create: XOR<ExperienceCreateWithoutStoriesInput, ExperienceUncheckedCreateWithoutStoriesInput>
  }

  export type StoryVersionCreateWithoutStoryInput = {
    id?: string
    created_at?: Date | string
    version_number: number
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    change_summary?: string | null
    created_by_ai?: boolean
  }

  export type StoryVersionUncheckedCreateWithoutStoryInput = {
    id?: string
    created_at?: Date | string
    version_number: number
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    change_summary?: string | null
    created_by_ai?: boolean
  }

  export type StoryVersionCreateOrConnectWithoutStoryInput = {
    where: StoryVersionWhereUniqueInput
    create: XOR<StoryVersionCreateWithoutStoryInput, StoryVersionUncheckedCreateWithoutStoryInput>
  }

  export type StoryVersionCreateManyStoryInputEnvelope = {
    data: StoryVersionCreateManyStoryInput | StoryVersionCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type StorySkillCreateWithoutStoryInput = {
    id?: string
    created_at?: Date | string
    skill: SkillCreateNestedOneWithoutStorySkillsInput
  }

  export type StorySkillUncheckedCreateWithoutStoryInput = {
    id?: string
    skill_id: string
    created_at?: Date | string
  }

  export type StorySkillCreateOrConnectWithoutStoryInput = {
    where: StorySkillWhereUniqueInput
    create: XOR<StorySkillCreateWithoutStoryInput, StorySkillUncheckedCreateWithoutStoryInput>
  }

  export type StorySkillCreateManyStoryInputEnvelope = {
    data: StorySkillCreateManyStoryInput | StorySkillCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type ExperienceUpsertWithoutStoriesInput = {
    update: XOR<ExperienceUpdateWithoutStoriesInput, ExperienceUncheckedUpdateWithoutStoriesInput>
    create: XOR<ExperienceCreateWithoutStoriesInput, ExperienceUncheckedCreateWithoutStoriesInput>
    where?: ExperienceWhereInput
  }

  export type ExperienceUpdateToOneWithWhereWithoutStoriesInput = {
    where?: ExperienceWhereInput
    data: XOR<ExperienceUpdateWithoutStoriesInput, ExperienceUncheckedUpdateWithoutStoriesInput>
  }

  export type ExperienceUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutExperiencesNestedInput
  }

  export type ExperienceUncheckedUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryVersionUpsertWithWhereUniqueWithoutStoryInput = {
    where: StoryVersionWhereUniqueInput
    update: XOR<StoryVersionUpdateWithoutStoryInput, StoryVersionUncheckedUpdateWithoutStoryInput>
    create: XOR<StoryVersionCreateWithoutStoryInput, StoryVersionUncheckedCreateWithoutStoryInput>
  }

  export type StoryVersionUpdateWithWhereUniqueWithoutStoryInput = {
    where: StoryVersionWhereUniqueInput
    data: XOR<StoryVersionUpdateWithoutStoryInput, StoryVersionUncheckedUpdateWithoutStoryInput>
  }

  export type StoryVersionUpdateManyWithWhereWithoutStoryInput = {
    where: StoryVersionScalarWhereInput
    data: XOR<StoryVersionUpdateManyMutationInput, StoryVersionUncheckedUpdateManyWithoutStoryInput>
  }

  export type StoryVersionScalarWhereInput = {
    AND?: StoryVersionScalarWhereInput | StoryVersionScalarWhereInput[]
    OR?: StoryVersionScalarWhereInput[]
    NOT?: StoryVersionScalarWhereInput | StoryVersionScalarWhereInput[]
    id?: StringFilter<"StoryVersion"> | string
    story_id?: StringFilter<"StoryVersion"> | string
    created_at?: DateTimeFilter<"StoryVersion"> | Date | string
    version_number?: IntFilter<"StoryVersion"> | number
    situation?: StringNullableFilter<"StoryVersion"> | string | null
    task?: StringNullableFilter<"StoryVersion"> | string | null
    action?: StringNullableFilter<"StoryVersion"> | string | null
    result?: StringNullableFilter<"StoryVersion"> | string | null
    full_story?: StringNullableFilter<"StoryVersion"> | string | null
    metrics?: JsonNullableFilter<"StoryVersion">
    change_summary?: StringNullableFilter<"StoryVersion"> | string | null
    created_by_ai?: BoolFilter<"StoryVersion"> | boolean
  }

  export type StorySkillUpsertWithWhereUniqueWithoutStoryInput = {
    where: StorySkillWhereUniqueInput
    update: XOR<StorySkillUpdateWithoutStoryInput, StorySkillUncheckedUpdateWithoutStoryInput>
    create: XOR<StorySkillCreateWithoutStoryInput, StorySkillUncheckedCreateWithoutStoryInput>
  }

  export type StorySkillUpdateWithWhereUniqueWithoutStoryInput = {
    where: StorySkillWhereUniqueInput
    data: XOR<StorySkillUpdateWithoutStoryInput, StorySkillUncheckedUpdateWithoutStoryInput>
  }

  export type StorySkillUpdateManyWithWhereWithoutStoryInput = {
    where: StorySkillScalarWhereInput
    data: XOR<StorySkillUpdateManyMutationInput, StorySkillUncheckedUpdateManyWithoutStoryInput>
  }

  export type StoryCreateWithoutVersionsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    ai_generated?: boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: string | null
    tags?: StoryCreatetagsInput | string[]
    is_draft?: boolean
    relevance_score?: number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    experience: ExperienceCreateNestedOneWithoutStoriesInput
    skills?: StorySkillCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutVersionsInput = {
    id?: string
    experience_id: string
    created_at?: Date | string
    updated_at?: Date | string
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    ai_generated?: boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: string | null
    tags?: StoryCreatetagsInput | string[]
    is_draft?: boolean
    relevance_score?: number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    skills?: StorySkillUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutVersionsInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutVersionsInput, StoryUncheckedCreateWithoutVersionsInput>
  }

  export type StoryUpsertWithoutVersionsInput = {
    update: XOR<StoryUpdateWithoutVersionsInput, StoryUncheckedUpdateWithoutVersionsInput>
    create: XOR<StoryCreateWithoutVersionsInput, StoryUncheckedCreateWithoutVersionsInput>
    where?: StoryWhereInput
  }

  export type StoryUpdateToOneWithWhereWithoutVersionsInput = {
    where?: StoryWhereInput
    data: XOR<StoryUpdateWithoutVersionsInput, StoryUncheckedUpdateWithoutVersionsInput>
  }

  export type StoryUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: BoolFieldUpdateOperationsInput | boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    is_draft?: BoolFieldUpdateOperationsInput | boolean
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    experience?: ExperienceUpdateOneRequiredWithoutStoriesNestedInput
    skills?: StorySkillUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    experience_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: BoolFieldUpdateOperationsInput | boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    is_draft?: BoolFieldUpdateOperationsInput | boolean
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    skills?: StorySkillUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryCreateWithoutSkillsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    ai_generated?: boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: string | null
    tags?: StoryCreatetagsInput | string[]
    is_draft?: boolean
    relevance_score?: number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    experience: ExperienceCreateNestedOneWithoutStoriesInput
    versions?: StoryVersionCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutSkillsInput = {
    id?: string
    experience_id: string
    created_at?: Date | string
    updated_at?: Date | string
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    ai_generated?: boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: string | null
    tags?: StoryCreatetagsInput | string[]
    is_draft?: boolean
    relevance_score?: number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    versions?: StoryVersionUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutSkillsInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutSkillsInput, StoryUncheckedCreateWithoutSkillsInput>
  }

  export type SkillCreateWithoutStorySkillsInput = {
    id?: string
    skill?: string | null
    confidence?: number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    profile: ProfileCreateNestedOneWithoutSkillsInput
  }

  export type SkillUncheckedCreateWithoutStorySkillsInput = {
    id?: string
    profile_id: string
    skill?: string | null
    confidence?: number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type SkillCreateOrConnectWithoutStorySkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutStorySkillsInput, SkillUncheckedCreateWithoutStorySkillsInput>
  }

  export type StoryUpsertWithoutSkillsInput = {
    update: XOR<StoryUpdateWithoutSkillsInput, StoryUncheckedUpdateWithoutSkillsInput>
    create: XOR<StoryCreateWithoutSkillsInput, StoryUncheckedCreateWithoutSkillsInput>
    where?: StoryWhereInput
  }

  export type StoryUpdateToOneWithWhereWithoutSkillsInput = {
    where?: StoryWhereInput
    data: XOR<StoryUpdateWithoutSkillsInput, StoryUncheckedUpdateWithoutSkillsInput>
  }

  export type StoryUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: BoolFieldUpdateOperationsInput | boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    is_draft?: BoolFieldUpdateOperationsInput | boolean
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    experience?: ExperienceUpdateOneRequiredWithoutStoriesNestedInput
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    experience_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: BoolFieldUpdateOperationsInput | boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    is_draft?: BoolFieldUpdateOperationsInput | boolean
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type SkillUpsertWithoutStorySkillsInput = {
    update: XOR<SkillUpdateWithoutStorySkillsInput, SkillUncheckedUpdateWithoutStorySkillsInput>
    create: XOR<SkillCreateWithoutStorySkillsInput, SkillUncheckedCreateWithoutStorySkillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutStorySkillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutStorySkillsInput, SkillUncheckedUpdateWithoutStorySkillsInput>
  }

  export type SkillUpdateWithoutStorySkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type SkillUncheckedUpdateWithoutStorySkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_id?: StringFieldUpdateOperationsInput | string
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceCreateManyProfileInput = {
    id?: string
    title?: string | null
    company?: string | null
    location?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_current?: boolean
    description?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: number | null
    created_at?: Date | string
  }

  export type EducationCreateManyProfileInput = {
    id?: string
    school?: string | null
    degree?: string | null
    field_of_study?: string | null
    start_year?: number | null
    end_year?: number | null
    description?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type SkillCreateManyProfileInput = {
    id?: string
    skill?: string | null
    confidence?: number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type CertificationCreateManyProfileInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ProjectCreateManyProfileInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type VolunteeringCreateManyProfileInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type LanguageCreateManyProfileInput = {
    id?: string
    language?: string | null
    proficiency?: string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type OrganizationCreateManyProfileInput = {
    id?: string
    name?: string | null
    authority?: string | null
    issued_date?: Date | string | null
    expiry_date?: Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ParsedDocumentCreateManyProfileInput = {
    id?: string
    user_id?: string | null
    file_name?: string | null
    storage_path?: string | null
    content_type?: string | null
    size_bytes?: number | null
    text_extracted?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: string | null
    status?: string | null
    error_text?: string | null
    parsed_at?: Date | string | null
    created_at?: Date | string
  }

  export type MediaLibraryCreateManyProfileInput = {
    id?: string
    file_name: string
    file_type: string
    mime_type: string
    file_size: bigint | number
    storage_path: string
    storage_bucket?: string
    title?: string | null
    description?: string | null
    tags?: MediaLibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomizedStoryCreateManyProfileInput = {
    id?: string
    user_id: string
    job_post_id?: string | null
    story: string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryCreatehighlighted_skillsInput | string[]
    match_score: number
    score_breakdown: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    is_active?: boolean
    version_name?: string | null
  }

  export type ExperienceUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUpdateManyWithoutExperienceNestedInput
  }

  export type ExperienceUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutExperienceNestedInput
  }

  export type ExperienceUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_current?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    order_index?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    school?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    start_year?: NullableIntFieldUpdateOperationsInput | number | null
    end_year?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    school?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    start_year?: NullableIntFieldUpdateOperationsInput | number | null
    end_year?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    school?: NullableStringFieldUpdateOperationsInput | string | null
    degree?: NullableStringFieldUpdateOperationsInput | string | null
    field_of_study?: NullableStringFieldUpdateOperationsInput | string | null
    start_year?: NullableIntFieldUpdateOperationsInput | number | null
    end_year?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    storySkills?: StorySkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    storySkills?: StorySkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VolunteeringUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VolunteeringUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VolunteeringUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    proficiency?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    proficiency?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    proficiency?: NullableStringFieldUpdateOperationsInput | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiry_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    raw_json?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsedDocumentUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    storage_path?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    text_extracted?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsing_jobs?: ParsingJobUpdateManyWithoutParsed_documentNestedInput
  }

  export type ParsedDocumentUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    storage_path?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    text_extracted?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsing_jobs?: ParsingJobUncheckedUpdateManyWithoutParsed_documentNestedInput
  }

  export type ParsedDocumentUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    storage_path?: NullableStringFieldUpdateOperationsInput | string | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    text_extracted?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    parser_version?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaLibraryUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    storage_path?: StringFieldUpdateOperationsInput | string
    storage_bucket?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MediaLibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaLibraryUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    storage_path?: StringFieldUpdateOperationsInput | string
    storage_bucket?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MediaLibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaLibraryUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    mime_type?: StringFieldUpdateOperationsInput | string
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    storage_path?: StringFieldUpdateOperationsInput | string
    storage_bucket?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MediaLibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomizedStoryUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryUpdatehighlighted_skillsInput | string[]
    match_score?: IntFieldUpdateOperationsInput | number
    score_breakdown?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version_name?: NullableStringFieldUpdateOperationsInput | string | null
    job_post?: JobPostUpdateOneWithoutCustomized_storiesNestedInput
  }

  export type CustomizedStoryUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    job_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    story?: StringFieldUpdateOperationsInput | string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryUpdatehighlighted_skillsInput | string[]
    match_score?: IntFieldUpdateOperationsInput | number
    score_breakdown?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomizedStoryUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    job_post_id?: NullableStringFieldUpdateOperationsInput | string | null
    story?: StringFieldUpdateOperationsInput | string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryUpdatehighlighted_skillsInput | string[]
    match_score?: IntFieldUpdateOperationsInput | number
    score_breakdown?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParsingJobCreateManyParsed_documentInput = {
    id?: string
    status?: string | null
    attempts?: number | null
    worker?: string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    created_at?: Date | string
  }

  export type ParsingJobUpdateWithoutParsed_documentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    worker?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsingJobUncheckedUpdateWithoutParsed_documentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    worker?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParsingJobUncheckedUpdateManyWithoutParsed_documentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: NullableIntFieldUpdateOperationsInput | number | null
    worker?: NullableStringFieldUpdateOperationsInput | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryCreateManyExperienceInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    ai_generated?: boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: string | null
    tags?: StoryCreatetagsInput | string[]
    is_draft?: boolean
    relevance_score?: number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoryUpdateWithoutExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: BoolFieldUpdateOperationsInput | boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    is_draft?: BoolFieldUpdateOperationsInput | boolean
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    versions?: StoryVersionUpdateManyWithoutStoryNestedInput
    skills?: StorySkillUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: BoolFieldUpdateOperationsInput | boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    is_draft?: BoolFieldUpdateOperationsInput | boolean
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
    versions?: StoryVersionUncheckedUpdateManyWithoutStoryNestedInput
    skills?: StorySkillUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateManyWithoutExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: BoolFieldUpdateOperationsInput | boolean
    metrics?: NullableJsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    is_draft?: BoolFieldUpdateOperationsInput | boolean
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    job_match_scores?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StorySkillCreateManySkillInput = {
    id?: string
    story_id: string
    created_at?: Date | string
  }

  export type StorySkillUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: StoryUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type StorySkillUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    story_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorySkillUncheckedUpdateManyWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    story_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalityResponseCreateManyAssessmentInput = {
    id?: string
    question_id: string
    question_text: string
    dimension: string
    response_value: number
    created_at?: Date | string
  }

  export type PersonalityResponseUpdateWithoutAssessmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    dimension?: StringFieldUpdateOperationsInput | string
    response_value?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalityResponseUncheckedUpdateWithoutAssessmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    dimension?: StringFieldUpdateOperationsInput | string
    response_value?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalityResponseUncheckedUpdateManyWithoutAssessmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    dimension?: StringFieldUpdateOperationsInput | string
    response_value?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomizedStoryCreateManyJob_postInput = {
    id?: string
    user_id: string
    profile_id?: string | null
    story: string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryCreatehighlighted_skillsInput | string[]
    match_score: number
    score_breakdown: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    is_active?: boolean
    version_name?: string | null
  }

  export type CustomizedStoryUpdateWithoutJob_postInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    story?: StringFieldUpdateOperationsInput | string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryUpdatehighlighted_skillsInput | string[]
    match_score?: IntFieldUpdateOperationsInput | number
    score_breakdown?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version_name?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutCustomizedStoriesNestedInput
  }

  export type CustomizedStoryUncheckedUpdateWithoutJob_postInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    profile_id?: NullableStringFieldUpdateOperationsInput | string | null
    story?: StringFieldUpdateOperationsInput | string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryUpdatehighlighted_skillsInput | string[]
    match_score?: IntFieldUpdateOperationsInput | number
    score_breakdown?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomizedStoryUncheckedUpdateManyWithoutJob_postInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    profile_id?: NullableStringFieldUpdateOperationsInput | string | null
    story?: StringFieldUpdateOperationsInput | string
    reordered_experience?: NullableJsonNullValueInput | InputJsonValue
    highlighted_skills?: CustomizedStoryUpdatehighlighted_skillsInput | string[]
    match_score?: IntFieldUpdateOperationsInput | number
    score_breakdown?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    version_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoryVersionCreateManyStoryInput = {
    id?: string
    created_at?: Date | string
    version_number: number
    situation?: string | null
    task?: string | null
    action?: string | null
    result?: string | null
    full_story?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    change_summary?: string | null
    created_by_ai?: boolean
  }

  export type StorySkillCreateManyStoryInput = {
    id?: string
    skill_id: string
    created_at?: Date | string
  }

  export type StoryVersionUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    version_number?: IntFieldUpdateOperationsInput | number
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    change_summary?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_ai?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StoryVersionUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    version_number?: IntFieldUpdateOperationsInput | number
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    change_summary?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_ai?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StoryVersionUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    version_number?: IntFieldUpdateOperationsInput | number
    situation?: NullableStringFieldUpdateOperationsInput | string | null
    task?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    full_story?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    change_summary?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_ai?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StorySkillUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutStorySkillsNestedInput
  }

  export type StorySkillUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorySkillUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}